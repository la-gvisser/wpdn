// 802.1 + 802.11
// someone should break it out one day!

// -------------------------------------------------------------------
// -------------------------------------------------------------------
//	Spanning Tree
//
//	globals i use:
//		g[0xa] = message type
//		g[0xb] = protocol version id
// -------------------------------------------------------------------
// -------------------------------------------------------------------

void 802.1()
{
	LABL 0 0 0 b1 802.1 - Bridge Spanning Tree\802.1:;
	DWRD 0 1 90 c2 Protocol Identifier:\Proto ID:;
	TEQU 1 1  0  0 GARP;
	DBYT 0 b 90 c2 Protocol Version ID:\Ver ID:;
	DBYT 0 1 90 c2 Message Type:\Type:;
	 CEQU  0 1 0 14 Configuration Message;
	 CEQU  2 1 0 14 Rapid/Multiple Spanning Tree;
	 CEQU 80 1 0 14 Topology Change Notification;

	g[0xa] = g[1];
	TEQU  0 1 0 0 802.1 Config;						//si: ok, only these message types can go on...
	TEQU  2 1 0 0 802.1 Config_RSTP;
	TEQU 80 1 0 0 802.1 Config;
	TRTS;
}

void 802.1 Config()
{
	BBYT 0 1 90 c9 Flags:;
	 CBIT 7 1 0 d4 1... .... Topology Change Ack;
	 CLSE 0 0 0 d4 0... .... No Topology Change Ack;
	 CBIT 6 1 0 d4 .1.. .... Agreement;
	 CLSE 0 0 0 d4 .0.. .... No Agreement;
	 CBIT 5 1 0 d4 ..1. .... Forwarding;
	 CLSE 0 0 0 d4 ..0. .... No Forwarding;
	 CBIT 4 1 0 d4 ...1 .... Learning;
	 CLSE 0 0 0 d4 ...0 .... No Learning;
	 CBIT 3 1 0 d4 .... 11.. Port Role;
	 CLSE 0 0 0 d4 .... 00.. No Port Role;
	 CBIT 1 1 0 d4 .... ..1. Proposal;
	 CLSE 0 0 0 d4 .... ..0. No Proposal;
	 CBIT 0 1 0 d4 .... ...1 Topology Change;
	 CLSE 0 0 0 d4 .... ...0 No Topology Change;
	 LABL 0 0 0 c8;
	HWRD 0 0 90 c2 Root Priority/ID:\;
	ETHR 0 0 90 40  /;
	HLNG 0 1 90 c2 Cost Of Path To Root:\;
	DGLB 0 1 4 14 (;
	LABL 0 0 0 4 ")";
	HWRD 0 0 90 c2 Bridge Priority/ID:\;
	ETHR 0 0 90 40  /;
	HBYT 0 0 90 c2 Port Priority/ID:\;
	HBYT 0 0 90 40  /;
	LABL 0 0 0 c2 Message Age:\;
	802.1 Time;
	LABL 0 0 0 c2 Maximum Age:\;
	802.1 Time;
	LABL 0 0 0 c2 Hello Time:\;
	802.1 Time;
	LABL 0 0 0 c2 Forward Delay:\;
	802.1 Time;
	GBYT 0 42;
	GWRD 1 43;
	DBYT 0 0 90 c2 Version 1 Length:;
	if (l[2] == 0)
	{
		if (l[2] == 0)
		{
			LABL 0 0 0 b7 Originating VLAN;
				DLNG 0 44 90 c2 Length:;
				if (l[4] == 2)
				{
					DWRD 0 41 90 c2 Originating VLAN:;
				}
				if (l[4] != 2)
				{
					HEX# 0 44 90 c2 Originating VLAN:;
				}
			LABL 0 0 0 c8;
		}
	}
	DWRD 0 41 90 c2 Version 3 Length:;
	LABL 0 0 0 b7 MST Configuration Identifier;
		DBYT 0 0 90 c2 MST Configuration ID Format Selector:;
		CHR# 20 0 90 c2 MST Configuration Name:;
		DWRD 0 0 90 c2 MST Configuration Revision:;
		HEX# 10 0 90 c2 MST Digest:;
	LABL 0 0 0 c8;
	DLNG  0 0 90 c2 CIST Int Root Path Cost:;
	DWRD  0 0 90 c2 CIST Bridge Priority/ID:\;
	ETHR  0 0 90 40  /;
	DBYT  0 0 90 c2 CIST Remaining Hops:;
	DWRD 0 43 90 c2 Version 4 Length:;
	//LABL 0 0 0 b7 MSTI Configuration Messages;
	l[1] = 34;
	LABL 0 0 0 b7  Auxiliary MCID Configuration Identifier;
		DBYT 0 0 90 c2  Configuration ID Format Selector:;
		CHR# 20 0 90 c2 Configuration Name:;
		DWRD 0 0 90 c2 Revision Level:;
		HEX# 10 0 90 c2 Configuration Digest:;
	LABL 0 0 0 c8;
	DLNG  0 0 90 c2 SPT Agreement Number:;
// 		BBYT 0 0 90 c2 MSTI Flags:;
//		CHR# 7 0 90 c2 MST Configuration Name:;
//		DWRD 0 0 90 c2 MST Configuration Revision:;
//		BBYT 0 0 90 c2 MSTI Bridge Priority:;
//		BBYT 0 0 90 c2 MSTI Port Priority:;
//		BBYT 0 0 90 c2 MSTI Remaining Hops:;
//		LABL 0 0 0 c8;		
	if (g[0xa] == 2)
	{
		if (l[3] == 0)
		{	
			TNXT -RSTP;
		}
	}
}

//si: the flags are diff for rstp... 
void 802.1 Config_RSTP()
{
	//GBYT 0 1;
	BBYT 0 1 90 c9 Flags:;
	 //DECR 1;
	 //DBIT 1 1 5 5; 
	  CBIT 7 1 0 d4 1... .... Topology Change Ack;
	  CLSE 0 0 0 d4 0... .... No Topology Change Ack;
	 //DBIT 1 1 5 5; 
	  CBIT 6 1 0 d4 .1.. .... In Sync;
	  CLSE 0 0 0 d4 .0.. .... Not In Sync;
	 //DBIT 1 1 5 5; 
	  CBIT 5 1 0 d4 ..1. .... Forwarding;
	  CLSE 0 0 0 d4 ..0. .... No Forwarding;
	 //DBIT 1 1 5 5; 
	  CBIT 4 1 0 d4 ...1 .... Learning;
	  CLSE 0 0 0 d4 ...0 .... No Learning;
	 //DBIT 2 1 5 5;
	 l[1] = g[1];
	 l[1] &= 0xC;
	 SHFR ( 2, l[1] );
	  CEQU 0 41 0 d4 .... 00.. Unknown;
	  CEQU 1 41 0 d4 .... 01.. Alternate Port (or Backup);
	  CEQU 2 41 0 d4 .... 10.. Root Port;
	  CEQU 3 41 0 d4 .... 11.. Designated Port;
	 //DBIT 1 1 5 5; 
	  CBIT 1 1 0 d4 .... ..1. Topology Change Notification;
	  CLSE 0 0 0 d4 .... ..0. No Topology Change Notification;
	 //DBIT 1 1 5 5; 
	  CBIT 0 1 0 d4 .... ...1 Topology Change;
	  CLSE 0 0 0 d4 .... ...0 No Topology Change;
	 LABL 0 0 0 c8;
	DWRD 0 0 90 c2 Root Priority/ID:\;
	ETHR 0 0 90 40  / ;
	HLNG 0 1 90 c2 Cost Of Path To Root:\;
	DGLB 0 1 4 14 (;
	LABL 0 0 0 4 ")";
	DWRD 0 0 90 c2 Bridge Priority/ID:\;
	ETHR 0 0 90 40  / ;
	HBYT 0 0 90 c2 Port Priority/ID:\;
	HBYT 0 0 90 40  / ;
	LABL 0 0 0 c2 Message Age:\;
	802.1 Time;
	LABL 0 0 0 c2 Maximum Age:\;
	802.1 Time;
	LABL 0 0 0 c2 Hello Time:\;
	802.1 Time;
	LABL 0 0 0 c2 Forward Delay:\;
	802.1 Time;
	GBYT 0 42;
	GWRD 1 43;
	DBYT 0 0 90 c2 Version 1 Length:;
	if (l[2] == 0)
	{
		if (l[2] == 0)
		{
			LABL 0 0 0 b7 Originating VLAN;
				DLNG 0 44 90 c2 Length:;
				if (l[4] == 2)
				{
					DWRD 0 41 90 c2 Orginating VLAN:;
				}
				if (l[4] != 2)
				{
					HEX# 0 44 90 c2 Orginating VLAN:;
				}
			LABL 0 0 0 c8;
		}
	}
	DWRD 0 41 90 c2 Version 3 Length:;
	LABL 0 0 0 b7 MST Configuration Identifier;
		DBYT 0 0 90 c2 MST Configuration ID Format Selector:;
		CHR# 20 0 90 c2 MST Configuration Name:;
		DWRD 0 0 90 c2 MST Configuration Revision:;
		HEX# 10 0 90 c2 MST Digest:;
	LABL 0 0 0 c8;
	DLNG  0 0 90 c2 CIST Int Root Path Cost:;
	DWRD  0 0 90 c2 CIST Bridge Priority/ID:\;
	ETHR  0 0 90 40  /;
	DBYT  0 0 90 c2 CIST Remaining Hops:;
	DWRD 0 43 90 c2 Version 4 Length:;
	//LABL 0 0 0 b7 MSTI Configuration Messages;
	l[1] = 34;
	LABL 0 0 0 b7  Auxiliary MCID Configuration Identifier;
		DBYT 0 0 90 c2  Configuration ID Format Selector:;
		CHR# 20 0 90 c2 Configuration Name:;
		DWRD 0 0 90 c2 Revision Level:;
		HEX# 10 0 90 c2 Configuration Digest:;
	LABL 0 0 0 c8;
	DLNG  0 0 90 c2 SPT Agreement Number:;
/* 		BBYT 0 0 90 c2 MSTI Flags:;
		CHR# 7 0 90 c2 MST Configuration Name:;
		DWRD 0 0 90 c2 MST Configuration Revision:;
		BBYT 0 0 90 c2 MSTI Bridge Priority:;
		BBYT 0 0 90 c2 MSTI Port Priority:;
		BBYT 0 0 90 c2 MSTI Remaining Hops:; */
		LABL 0 0 0 c8;		
	if (g[0xa] == 2)
	{
		if (l[3] == 0)
		{	
			TNXT -RSTP;
		}
	}
}

void 802.1 Time()
{
	GBYT 0 2;
	DWRD 0 1 90 2;
	LABL -/256 seconds ;
	ANDG ff 1;
	CEQU 0 1 0 4 "(exactly ";
	SKIP 9;
	CLTE c0 1 0 4 "(less than ";
	SKIP 6;
	CGTE 40 1 0 4 "(more than ";
	SKIP 5;
	CNEQ 0 1 0 14 "(approx. ";
	DGLB 0 2 4 4;
	LABL 0 0 0 4 ".5 seconds)";
	TRTS;
	ADDG 1 2;
	DGLB 0 2 4 4;
	LABL 0 0 0 4 " seconds)";
}

void RSTP()
{
	if (g[0xb] == 3)
	{
		DBYT  0 0 90 c2 Version 1 Length:;
		TNXT -MSTP;			// si: you expect g[0xb] from 802.1 - protocol version id
	}
	LABL( 0, 0, 0, 0xb1, "Rapid Spanning Tree Protocol\RSTP:" );
	DBYT( 0, 0, 0x90, 0xc2, "Version 1 Length:\V1 Len:" );
	TRTS;
}

void MSTP;
	LABL  0 0 00 b1 Multiple Spanning Tree;
	DWRD  0 0 90 c2 MST Length:;
	DBYT  0 0 90 c2 MST ID Format Selector:;
	CHR# 20 0 90 c2 MST Name:;
	DWRD  0 0 90 c2 MST Revision:;
	HEX# 10 0 90 c2 MST Digest:;
	DLNG  0 0 90 c2 CIST Int Root Path Cost:;
	DWRD  0 0 90 c2 CIST Bridge Priority/ID:\;
	ETHR  0 0 90 40  /;
	DBYT  0 0 90 c2 CIST Remaining Hops:;
	TRTS;

// -------------------------------------------------------------------
// -------------------------------------------------------------------

void 802_2()
{
//   IPX brain damage.... not really 802.2, just illegal 802.3 
//   [wm] This is actually referred to as Ethernet_802.3 by Novell  
//   (aka 802.3 RAW) Here, the IPX checksum field is used to indicate     
//   Netware is the upper layer.  Therefore IPX checksums cannot be used over 
//   any Ethernet_802.3                                        
//   move ahead to check netware 
	INCR 2;
//   see if DSAP & SSAP are both 0xff 
	GWRD 0 1 0 40;
	TEQU ffff 1 0 0 Ethernet_802.3 IPX;
//   not netware, move back 
	DECR 2 0 0 40;

	// BD: This deals with 802.1Q Vlan special case
	SEQU 1 31;
	SKIP 80000001;
		DECR 2;

	g[1] = pw[0];
	
	if (g[1] != 0)						//SI: TT4151: decode packets with a zero length field
	{
		PRV6 0 2 90 c2 LLC Length:;		//SI: if length != 0, reset g16
		if (g[2] < g[16])
		{
			g[16] = g[2];
		}
	}
	
	if (g[1] == 0)						//SI: tt6487: just set the T?F check to be true so the next instruction will skip
	{
		PRV6 0 1 90 c2 LLC Length:;		//SI: if length == zero, then don't reset g16
		LABL 0 0  0 14 Bad Length Field;	
	} 
	
	//g[16] += 2;
	//ADDG 2 10;
	
	802_2::Common();
}


void TR::802_2()
{
//   token ring 802.2... just a little different 
	TEQU 0 3 0 14 MAC Control;
	802_2::Common();
}

void 802_2::Common()
{
	TGTE 0 10 0 0 RETURN;
	l[1] = pw[0];
	if (l[1] == 0x8100)
	{
		802_2::TaggedPacket;
	}
	//si: this is for the 3com AP padding byte thing (TT12569)
	if (l[1] != 0x8100) 
	{
		if (l[1] != 0xAAAA)
		{
			l[1] = pw[1];
			if (l[1] == 0xAAAA)
			{
				INCR 1;
			}
		}
	}
	LABL 0 0 0 b1 802.2 Logical Link Control (LLC) Header\802.2:;
	TNEQ 0 d 0 0 802_2::Data;
	PRTO 2 1 90 c2 Dest. SAP:\D:;
	SKIP 2;
	MOVE 1 84;
	LSAP::Names;
	PRTO 2 2 90 c2 Source SAP:\S:;
	SKIP 3;
	MOVE 2 84;
	ANDG fe 4;
	LSAP::Names;
	LLC::Cmd/Rsp;
	TEQU 0 10 0 0 LLC::Null;
//   unsigned < 0 
	TLTE 7d20 10 0 0 LLC::Null;
	802_2::Data();
}

void 802_2::TaggedPacket;
	LABL 0 0 00 b1 802.2 Tagged Packet Format;
	HWRD 0 0 90 c2 Tag:;
	HWRD 0 0 90 c2 QoS:;
	TRTS;


void 802_2::Data()
{
	TEQU 4 2 0 0 SNA::802_2;
	TEQU 4 1 0 0 SNA::802_2;

	SEQU 6 1;
	TEQU 6 102 0 0 IP;
	SEQU 42 1;
	TEQU 42 102 0 0 802.1;
	SEQU 80 1;
	TEQU 80 102 0 0 XNS;
	SEQU 98 1;
	TEQU 98 102 0 0 ARP;
	SEQU aa 1;
	TEQU aa 102 0 0 SNAP;
	SEQU bc 1;
	TEQU bc 102 0 0 VINES::802_2;
	SEQU e0 1;
	TEQU e0 102 0 0 IPX Top;
	TEQU f0 1 0 0 NetBEUI;
	TEQU f0 2 0 0 NetBEUI;
	SEQU f4 1;
	TEQU f4 102 0 0 Indiv LAN Manage;
	SEQU fe 1;
	TEQU fe 102 0 0 OSI;
	
	DUMP 0 10 90 c2 Packet Data:;
}

void SNAP;
// BD: seperated Vendor ID and Protocol Type
	l[3] = pw[1];						//rp: store last 2 octets of Vendor ID in l[3]
	HEX# 3 0 90 c2 Vendor ID:\;
	 DECR 3;
	 GBYT 0 1;
	 INCR 3;
	 if (g[1] != 0) 					//si: this prints out the vendor id
	 {
	   DECR 2;
	   g[2] = pw[0];
	   INCR 2;
	   g[1] *= 65536;					//si: move the 3rd byte to the proper position
	   g[1] += g[2];
	   CST# 0 1 0 14 802_11::OUI_Strings;
	 }
	 if (g[1] == 0) 
	 {
	   DECR 2;
	   MOVE 2 1;
	   GWRD 0 1;
	   INCR 2;
	   ADDG 1 1;						//si: zero based list
	   print_vendor_id_comment;
	 }
	HWRD 0 2 90 c2 Protocol Type:\;
	if (l[3] == 0x4096)					//rp: check for Cisco Vendor ID - for WLCCP
	{
		if (g[2] == 0)
		{
			WLCCP();
		}
	}
//	CST#( 0, g[2], 0, 0x14, SNAP::Names);
//  MOVE 2 81;  * EProto Names uses g1
//	EProto::Names;
//  TSB#( 0, g[2], 0, 0, SNAP::Types);
	SNAP::Names;
	TEQU 88b4 2 0 0 WAI_Protocol;
	SKIP 19;
	TEQU 2001 2 0 0 CGMP;
	SKIP 17;
	TEQU 809b 2 0 0 Long DDP;
	SKIP 15;
	TEQU 6001 2 0 0 DECnet MOP Dump/Load;
	SKIP 13;
	TEQU 6002 2 0 0 DECnet MOP Remote Console;
	SKIP 11;
	TEQU 6003 2 0 0 DECnet Phase IV;
	SKIP f;
	TEQU 6004 2 0 0 DECnet LAT;
	SKIP d;
	TEQU 6005 2 0 0 DECnet Diagnostic Protocol;
	SKIP b;
	TEQU 6007 2 0 0 DECnet Phase IV;
	SKIP 9;
	TEQU 80c4 2 0 0 VINES Internet;
	SKIP 7;
	TEQU 80c5 2 0 0 VINES Echo;
	SKIP 5;
	
	MOVE 2 81;  // Ether Branching 3 us g1
	Ether::Branching_3;
	TGTE 0 10 0 0 RETURN;

//   +++ Added from Clint
	TEQU 2000 2 0 10 Cisco Discovery Protocol;
	TEQU 80c5 2 0 0 VINES Echo;
	
	// BD: Deals with cases that over step bound of packet
	BREM 0 10;
	SUBG 4 10;

	GBYT( 0, l[4] );
	GBYT( 1, l[5] );
	if (l[4] == 0x02)
	{
		if (l[5] == 0x0c)
		{
			DBYT 0 1 90 c2 Payload Type:;
			DBYT 0 1 90 c2 Category code:;
			TST# 0 1 00 00 802_11::Mgmt_Action::CategoryCode::Func;
			TRTS;
		}
	}

	DUMP 0 10 90 c2 Packet Data:\;


void LSAP::Names;
	SLTE 7 4;
	SKIP 2;
//   display indexed string 	
	CST# ffffffff 4 0 14 LSAPsLT6;
	TRTS;
	CST# 0 4 0 14 LSAP::Names_Str;
	TRTS;
	
str# LSAP::Names_Str;
	0x0e | Proway Network Management & Initialization;
	0x18 | Texas Instruments;
	0x42 | 802.1 Bridge Spanning Tree;
	0x4e | EIA RS-511 Manufacturing Message Service;
	0x7e | ISO 8208 - X.25 over 802.2 Type 2 LLC;
	0x80 | XNS;
	0x86 | Nestar;
	0x98 | IP ARP;
	0xaa | SNAP;
	0xbc | Banyan VINES;
	0xe0 | Novell Netware;
	0xf0 | NetBEUI/NetBIOS;
	0xf4 | LAN Management (individual);
	0xf5 | LAN Management (Group);
	0xf8 | Remote Load Program (RPL);
	0xfa | Ungermann-Bass;
	0xfe | ISO Network Layer Protocol;
	0xff | Gloabl LSAP;

void SNAP::Names;
	// BD: sperated the Protocol Type and Vendor ID
//
//0x2001 | Cisco Group Management Protocol;
//0x6001 | DECnet MOP Dump/Load;
//0x6002 | DECnet MOP Remote Console;
//0x6003 | DECnet Phase IV;
//0x6004 | DECnet LAT;
//0x6005 | DECnet Diagnostic Protocol;
//0x6007 | DECnet LAVC;
//0x80c4 | VINES Internet;
//0x80c5 | VINES Echo;
//0x809b | AppleTalk;
//
	CEQU 2001 2 0 14 Cisco Group Management Protocol;
	SKIP 16;
	CEQU 809b 2 0 14 AppleTalk;
	SKIP 14;
	CEQU 6001 2 0 14 DECnet MOP Dump/Load;
	SKIP 12;
	CEQU 6002 2 0 14 DECnet MOP Remote Console;
	SKIP 10;
	CEQU 6003 2 0 14 DECnet Phase IV;
	SKIP e;
	CEQU 6004 2 0 14 DECnet LAT;
	SKIP c;
	CEQU 6005 2 0 14 DECnet Diagnostic Protocol;
	SKIP a;
	CEQU 6007 2 0 14 DECnet LAVC;
	SKIP 8;
	CEQU 80c4 2 0 14 VINES Internet;
	SKIP 6;
	CEQU 80c5 2 0 14 VINES Echo;
	SKIP 4;
	
	MOVE 2 81;  // EProto Names uses g1
	EProto::Names;

//   +++ Added from Clint
	CEQU 2000 2 0 14 Cisco Discovery Protocol;
	CEQU 80c5 2 0 14 VINES Echo;
	TRTS;
	
str# SNAP::Types;
	0x2001 | CGMP;
	0x6001 | DECnet MOP Dump/Load;
	0x6002 | DECnet MOP Remote Console;
	0x6003 | DECnet Phase IV;
	0x6004 | DECnet LAT;
	0x6005 | DECnet Diagnostic Protocol;
	0x6007 | DECnet Phase IV;
	0x80c4 | VINES Internet;
	0x80c5 | VINES Echo;
	0x809b | Long DDP;

void LLC::Cmd/Rsp;
//   is lsb of SSAP set? 
	SBIT 0 2;
	SKIP 3;
	HBYT 0 4 90 c2 Command:\C:;
//   remember for later 
	MOVE 0 3;
//   skip response part 
	SKIP 80000002;
	HBYT 0 4 90 c2 Response:;
//   remember for later 
	MOVE 1 3;
//   br if not info xfer format 
	TBIT 0 4 0 0 LLC::Non-Info;
	HBYT 80000000 5;
	LABL 0 0 0 14 Numbered Information;
	LLC::Mod 128 Poll or Final;
	DIVG 2 4;
	DIVG 2 5;
	DGLB 0 4 90 c2 Trans Send Seq Num:;
	DGLB 0 5 90 c2 Trans Recv Seq Num:;
	TRTS;
	
void LLC::Non-Info;
//   br if no supervisory format 
	TBIT 1 4 0 0 LLC::Unnum Format;
	HBYT 80000000 5;
	TEQU 1 4 0 0 LLC::Recv Rdy;
	TEQU 5 4 0 0 LLC::Recv Not Rdy;
	TEQU 9 4 0 0 LLC::Reject;
	TRTS;
	
void LLC::Mod 128 Poll or Final;
//   sent by SSAP? 
	SEQU 0 3;
//   skip if so 
	SKIP 3;
	CBIT 0 5 0 14 (Final);
	CLSE 0 0 0 14 (No Final);
	TRTS;
	CBIT 0 5 0 14 (Poll);
	CLSE 0 0 0 14 (No Poll);
	TRTS;
	
void LLC::Recv Rdy;
	LABL 0 0 0 14 Receiver Ready;
	LLC::Mod 128 Poll or Final;
	DIVG 2 5;
	DGLB 0 5 24 d4 Transmitter Recv Sequence Number;
	TRTS;
	
void LLC::Recv Not Rdy;
	LABL 0 0 0 14 Receiver Not Ready;
	LLC::Mod 128 Poll or Final;
	DIVG 2 5;
	DGLB 0 5 24 d4 Transmitter Recv Sequence Number;
	TRTS;
	
void LLC::Reject;
	LABL 0 0 0 14 Reject;
	LLC::Mod 128 Poll or Final;
	DIVG 2 5;
	DGLB 0 5 24 d4 Transmitter Recv Sequence Number;
	TRTS;
	
void LLC::Unnum Format;
	MOVE 4 85;
	ANDG ef 5;
	CEQU f 5 0 14 Disconnect Mode;
	TTST -LLC::Discon Mode;
	CEQU 43 5 0 14 Disconnect;
	TTST -LLC::Discon;
	CEQU 63 5 0 14 Unnumbered Acknowledge;
	TTST -LLC::Unnum Ack;
	CEQU 6f 5 0 14 Set Asynchronous Balance Mode Extended;
	TTST -LLC::SABME;
	CEQU 87 5 0 14 Frame Reject;
	TTST -LLC::Frm Rej;
	CEQU af 5 0 14 Exchange ID;
	TTST -LLC::Exch ID;
	CEQU e3 5 0 14 Test;
	TTST -LLC::Test;
	LABL 0 0 0 14 Unnumbered Information;
	TRTS;
	
void LLC::Discon Mode;
	LLC::Poll or Final;
	TRTS;
void LLC::Discon;
//sent by SSAP? 
	SEQU 0 3;
	SKIP 3;
	CBIT 4 4 0 14 Set;
//sent by DSAP? 
	SEQU 1 3;
	SKIP 1;
	CBIT 4 4 0 14 Request;
	LLC::Poll or Final;
	TRTS;
void LLC::Unnum Ack;
	LLC::Poll or Final;
	TRTS;
void LLC::SABME;
	LLC::Poll or Final;
	TRTS;
void LLC::Frm Rej;
	LABL 0 0 0 b1 Frame Rejection Information;
	HBYT 0 0 f0 c2 Rejected LPDU Contrl Fld, Byt 0:;
	HBYT 0 0 f0 c2 Rejected LPDU Contrl Fld, Byt 1:;
	GBYT 0 3 0 32;
	DIVG 2 3;
	HGLB 0 3 f0 c2 Send State Var For This Lnk At Reject Lnk Stn:;
	INCR 1;
	GBYT 0 3;
	LABL 0 0 0 2 Rejecting LPDU Command or Response?:;
	CBIT 0 3 0 14 Response, C/R Bit Set;
	CLSE 0 0 0 14 Command, C/R Bit NOT Set;
	DIVG 2 3;
	HGLB 0 3 f0 c2 Recv State Var For This Lnk At Reject Lnk Stn:;
	INCR 1;
	HBYT 0 3 f0 c2 Reasons For Frame Reject Condition:;
	CBIT 4 3 0 f4 Send Sequence Number Invalid;
	CBIT 3 3 0 f4 Receive Sequence Number Doesn't Refer To Valid I-Format LPDU;
	CBIT 2 3 0 f4 Length Of The Information Field Exceeded The Available Buffer Capacity;
	CBIT 1 3 0 f4 Info Field Received But Not Expected OR, FRMR Response Info Field Not Valid;
	CBIT 0 3 0 f4 Invalid Or Unsupported LPDU;
	TRTS;
void LLC::Exch ID;
	LLC::Poll or Final;
	TEQU 0 10 0 0 LLC::Null;
	LABL 0 0 0 b1 XID - Exchange Identification;
	BBIT 4 4 a0 c2 Format:;
//   display indexed string 
	CST# ffffffff 4 0 14 LLC::XID Fmt Types;
//   display indexed string 
	CLSE 0 0 0 14 External Standards Organizations;
	BBIT 4 5 a0 c2 Sending Node Type:;
	CST# ffffffff 5 0 14 LLC::XID Send Node Types;
	CLSE 0 0 0 14 Undefined;
	TEQU 0 4 0 0 LLC::XID Fmt;
	TEQU 1 4 0 0 LLC::XID Fmt 1;
	TEQU 3 4 0 0 LLC::XID Fmt 3;
	DUMP 0 10 a0 c2 Remaining SNA Data:;
void LLC::Test;
	LLC::Poll or Final;
void LLC::Poll or Final;
//   sent by SSAP? 
	SEQU 0 3;
//   skip if so 
	SKIP 3;
	CBIT 4 4 0 14 (Final);
	CLSE 0 0 0 14 (No Final);
	TRTS;
	CBIT 4 4 0 14 (Poll);
	CLSE 0 0 0 14 (No Poll);
	TRTS;
void LLC::XID Fmt;
	HBYT 0 6 a0 c2 Reserved:;
	BBIT c 0 a0 c2 Block Number:;
	BBIT 14 0 a0 c2 ID Number:;
	
void LLC::XID Fmt 1;
	LLC::XID Var Fmt Strt;
	HBYT 0 9 b0 c2 Link Statn & Conect Prot Flags:;
	CBIT 5 9 0 f4 Sender Is A Primary Link Station (Nonnegotiable);
	CLSE 0 0 0 f4 Sender Is A Secondary Link Station (Nonnegotiable);
	ANDG f 9;
	CST# ffffffff 9 0 f4 LLC::Link-Stn Tran-Rec Cap Types;
	HBYT 0 9 b0 c2 Charactr Of Node Of XID Sender:;
	LABL 0 0 0 d2 Segment assembly capability of the path control element of the node:;
	DIVG 10 9;
	ANDG 3 9;
	CST# ffffffff 9 0 f4 LLC::Seg Assem Cap Of Pth Cntrl Elmnt Of Nd;
	GWRD 0 9 0 30;
	INCR 2;
	MOVE 9 8a;
	LABL 0 0 0 c2 Maximum I-Field Length that the XID sender can receive:;
	LABL 0 0 0 d2 Format Flag:;
	ANDG 8000 a;
	CEQU 8000 a 0 14 1  Undefined format;
	CLSE 0 0 0 14 0  Bits 1-15 contain the max I-field length (only value defined);
	LABL 0 0 0 d2 Maximum I-Field Length:;
	ANDG 7fff 9;
	DGLB 0 9 b0 4;
	HBYT 0 9 b0 c2 SDLC Command/Response Profile:;
	ANDG f 9;
	CEQU 0 9 0 14 SNA link profile (only value defined);
	CLSE 0 0 0 14 Undefined Profile;
	HBYT 0 9 b0 c2 SDLC Init Mode Options:;
	CBIT 5 9 0 14 SIM and RIM supported;
	CLSE 0 0 0 14 SIM and RIM NOT supported;
	HWRD 0 9 b0 c2 Reserved:;
	GBYT 0 9 0 30;
	INCR 1;
	LABL 0 0 0 c2 Max # I-Frms Received Bef Ack:;
	ANDG 7f 9;
	DGLB 0 9 b0 4;
	HBYT 0 9 b0 c2 Reserved:;
	DUMP 0 10 a0 c2 Remaining XID Info field data:;
	
void LLC::XID Fmt 3;
	LLC::XID Var Fmt Strt;
	HWRD 0 7 a0 c2 Node Characteristics:;
	LLC::Node Char Bitmap;
	HBYT 0 7 a0 c2 BIND Pacing Support:;
	LLC::Bind Pacing Bitmap;
	HLNG 0 0 a0 c2 Reserved:;
	HBYT 0 7 a0 c2 Parallel TG Support:;
	CBIT 7 7 0 14 Supported;
	CLSE 0 0 0 14 Not Supported;
	DBYT 0 0 a0 c2 Transmission Group:;
	HBYT 0 7 a0 c2 DLC Type:;
	CST# 0 7 0 14 LLC::DLC Types;
	DBYT 0 8 a0 c2 DLC Info Length:;
	TEQU 1 7 0 0 LLC::SDLC DLC Info;
	TEQU 2 7 0 0 LLC::370 Channel DLC Info;
	
void LLC::XID Var Fmt Strt;
	DBYT 0 6 a0 c2 Variable I-Field Length:;
	HBYT 0 0 a0 c2 Block Number:;
	GBYT 0 7 0 2;
	DIVG 10 7;
	ANDG f 7;
	CST# ffffffff 7 0 0 Hex Digits;
	GBYT 0 7 0 42;
	ANDG f 7;
	LABL 0 0 0 c2 ID Number:;
	LABL 0 0 0 20             0x;
	CST# ffffffff 7 0 0 Hex Digits;
	INCR 1;
	HWRD 80000000;
	HWRD 0 6 a0 c2 Reserved:;
	TRTS;
	
void LLC::Node Char Bitmap;
	CBIT f 7 0 f4 INIT-SELF may NOT be sent to XID sender;
	CLSE 0 0 0 f4 INIT-SELF may be sent to XID sender;
	CBIT e 7 0 f4 BIND may NOT be sent to XID sender;
	CLSE 0 0 0 f4 BIND may be sent to XID sender;
	CBIT d 7 0 f4 Can NOT generate BIND PIU Segments;
	CLSE 0 0 0 f4 Can generate BIND PIU Segments;
	CBIT c 7 0 f4 Can NOT receive BIND PIU Segments;
	CLSE 0 0 0 f4 Can receive BIND PIU Segments;
	CBIT 7 7 0 f4 ACTPU for SSCP-PU session NOT requested;
	CLSE 0 0 0 f4 ACTPU for SSCP-PU session requested;
	CBIT 6 7 0 f4 Sender is a network node;
	CLSE 0 0 0 f4 Sender is NOT a network node;
	CBIT 5 7 0 f4 CP services requested or provided;
	CLSE 0 0 0 f4 CP services NOT requested NOR provided;
	CBIT 4 7 0 f4 CP-CP sessions supported on this TG;
	CLSE 0 0 0 f4 CP-CP sessions NOT supported on this TG;
	MOVE 7 88;
	DIVG 4 8;
	ANDG 3 8;
	CST# ffffffff 8 0 f4 LLC::XID Exch States;
	CBIT 1 7 0 f4 Secondary station-initiated nonactivation exchange supported;
	CLSE 0 0 0 f4 Secondary station-initiated nonactivation exchange NOT supported;
	CBIT 0 7 0 f4 CP name change of nonactivation XID3 supported;
	CLSE 0 0 0 f4 CP name change of nonactivation XID3 NOT supported;
	TRTS;
void LLC::Bind Pacing Bitmap;
	CBIT 7 7 0 f4 Adaptive BIND pacing as BIND sender supported;
	CLSE 0 0 0 f4 Adaptive BIND pacing as BIND sender NOT supported;
	CBIT 6 7 0 f4 Adaptive BIND pacing as BIND receiver supported;
	CLSE 0 0 0 f4 Adaptive BIND pacing as BIND receiver NOT supported;
	CBIT 5 7 0 f4 Topology update states TG from receiver to sender is quiesced;
	CLSE 0 0 0 f4 Topology update states TG from receiver to sender is operative;
	CBIT 4 7 0 f4 Supports receipt of ACTPU PU Capabilities ctl vector;
	CLSE 0 0 0 f4 Does not support receipt of ACTPU PU Capabilities ctl vector;
	CBIT 3 7 0 f4 APPN border node function supported;
	CLSE 0 0 0 f4 APPN border node function NOT supported;
	MOVE 7 88;
	ANDG 3 8;
	CST# ffffffff 8 0 f4 LLC::XID Adpt Pacing Supt;
	TRTS;
void LLC::SDLC DLC Info;
	HBYT 0 7 a0 c2 Link Stn & Connect Flags:;
	CBIT 6 7 0 f4 Sender can be ABM combined station;
	CLSE 0 0 0 f4 Sender can NOT be ABM combined station;
	MOVE 7 89;
	DIVG 10 9;
	ANDG 3 9;
	CST# ffffffff 9 0 f4 LLC::XID Link Stn Roles;
	MOVE 7 89;
	ANDG 3 9;
	CST# ffffffff 9 0 f4 LLC::XID Link Stn xmit recv;
	HBYT 0 7 a0 c2 ABM Nonactivation Flag:;
	CBIT 7 7 0 14 Sender is initiator;
	CLSE 0 0 0 14 Sender is NOT initiator;
	DWRD 0 0 a0 c2 Max Receive BTU length:;
	HBYT 0 7 a0 c2 SDLC Cmd/Resp Profile:;
	ANDG f 7;
	CEQU 0 7 0 14 SNA Link;
	HBYT 0 7 a0 c2 SDLC Init Mode Options:;
	CBIT 5 7 0 14 SIM and RIM supported;
	CLSE 0 0 0 14 SIM and RIM NOT supported;
	HWRD 0 0 a0 c2 Reserved:;
	DBYT 0 7 a0 c2 Max Outstanding I-frames:;
	HBYT 0 0 a0 c2 Reserved:;
	TNXT -SNA Control Vectors;
void LLC::370 Channel DLC Info;
	HWRD 0 7 a0 c2 Indicators:;
	CBIT f 7 0 f4 Change CDLC parameters to values in this XID;
	CLSE 0 0 0 f4 Do NOT change CDLC parameters;
	CBIT e 7 0 f4 Attention timeout supported;
	CLSE 0 0 0 f4 Attention timeout NOT supported;
	CBIT c 7 0 f4 Changing CDLC params by means of nonactivation XID exchange supported;
	CLSE 0 0 0 f4 Changing CDLC params by means of nonactivation XID exchange NOT supported;
	HWRD 0 7 a0 c2 Max Receive PIU Length: ;
	HBYT 0 7 a0 c2 Buffer Pre-Fetch Suggest.: ;
	HWRD 0 7 a0 c2 Number of Read Commands: ;
	HWRD 0 7 a0 c2 Buffer Size: ;
	HWRD 0 7 a0 c2 Blocking Delay: ;
	HWRD 0 7 a0 c2 Attention Timeout: ;
	HWRD 0 7 a0 c2 Prev. # of Read Commands: ;
	HWRD 0 7 a0 c2 Prev. Primary Buff. Size: ;
	HBYT 0 7 a0 c2 Time Units: ;
	CST# ffffffff 7 0 74 LLC::XID Time Units;
	TNXT -SNA Control Vectors;
void LLC::Null;

void MAC Control;
	LABL 0 0 0 b1 MAC Control Frame;
	DWRD 0 10 90 c2 Length:;
	LABL 0 0 0 b1 Major Vector ID;
	BBIT 4 3 90 c2 Destination Class:;
//   display indexed string 
	CST# ffffffff 3 0 14 MV Class Types;
	BBIT 4 3 90 c2 Source Class:;
	CST# ffffffff 3 0 14 MV Class Types;
	MV Command;
	CST# ffffffff 3 0 14 MV Command Types;
	MOVE 0 5;
	TLTE 1 10 0 0 MV Subvector;

void MV Command;
	HBYT 0 3 90 c2 Command:\C:;
	TEQU ff 3 0 0 MV Long Command;
	ADDG ffffffff 10 0 82;
	TRTS;
void MV Long Command;
	HWRD 0 3 20;
	ADDG fffffffd 10 0 82;
	TRTS;
void MV Subvector;
	LABL 0 0 0 b1 Subvector #;
	ADDG 1 5 0 2;
	DGLB 0 5 1 30;
	Subvector Length;
	MOVE 3 84;
	MULG ffffffff 4;
	Subvector Type;
	CST# ffffffff 2 0 14 MV Subvector Types;
	Subvector Value;
	TLTE 1 10 0 0 MV Subvector;
void Subvector Length;
	DBYT 0 3 90 c2 Length:;
	TEQU ff 3 0 0 Subvector Long Length;
	TRTS;
void Subvector Long Length;
	DWRD 0 3 20;
	TRTS;
void Subvector Type;
	DBYT 0 2 90 c2 Type:;
	TEQU ff 2 0 0 Subvector Long Type;
	ADDG fffffffe 3 0 2;
	TRTS;
void Subvector Long Type;
	DWRD 0 2 20;
	ADDG fffffffc 3 0 2;
	TRTS;
void Subvector Value;
	TST# ffffffff 2 0 0 MV Subvector Types;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Beacon Type;
	DWRD 0 2 90 c2 Value:;
	CST# ffffffff 2 0 14 MV Beacon Types;
	TRTS;
void Upstream Neighbor Address;
	ETHR 0 3 90 c2 Value:;
	TRTS;
void Local Ring Number;
	DWRD 0 2 90 c2 Value:;
	TRTS;
void Assign Physical Drop Number;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Soft Error Report Timer Value;
	DWRD 0 2 90 c2 Value:;
	LABL 0 0 20 34 times 10 milliseconds;
	TRTS;
void Enabled Function Classes;
	BBIT 10 0 90 c2 Value:;
	TRTS;
void Allowed Access Priority;
	GWRD 0 2;
	ANDG 3 2;
	DGLB 0 2 90 c2 Value:;
	INCR 2;
	TRTS;
void Correlator;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Address of Last Ring Poll;
	ETHR 0 3 90 c2 Value:;
	TRTS;
void Physical Drop Number;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Response Code;
	HWRD 0 2 90 c2 Value:;
	TEQU 1 2 0 0 MV Ack Response;
	ADDG ffff8000 2;
	CST# 0 2 0 14 MV Response Codes;
	TRTS;
void MV Ack Response;
	LABL 0 3 0 14 Acknowledged;
	TRTS;
void Reserved;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Product ID;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Adapter Software Level;
	HEX# 5 0 90 c2 Feature Code:;
	HEX# 5 0 90 c2 EC Level:;
	TRTS;
void Wrap Data;
	DUMP 0 3 90 c2 Value:;
	TRTS;
void Frame Forward;
	DUMP 0 3 90 c2 Value:;
	TRTS;
void Adapter Status Vector;
	HBYT 0 2 90 c2 SIF Task Status 1:;
	CBIT 7 2 0 14 SIF Initialized ;
	CBIT 6 2 0 14 SSB Busy ;
	CBIT 5 2 0 14 SSB Queued ;
	CBIT 4 2 0 14 Adapter Open ;
	CBIT 2 2 0 14 Receive Command ;
	CBIT 1 2 0 14 Transmit Command ;
	HBYT 0 2 90 c2 SIF Task Status 2:;
	CBIT 7 2 0 14 SSB Wait SCB Clear ;
	CBIT 6 2 0 14 SSB Wait Ring Status ;
	CBIT 5 2 0 14 SSB Wait Cmd Completion ;
	CBIT 4 2 0 14 SSB Wait Receive ;
	CBIT 3 2 0 14 SSB Wait Transmit ;
	HBYT 0 2 90 c2 SIF Transmit Status 1:;
	CBIT 7 2 0 14 Subtask Not Ready ;
	CBIT 6 2 0 14 Wait Xmit Complete ;
	CBIT 5 2 0 14 Wait Validation ;
	CBIT 3 2 0 14 Xmit Halt Enabled ;
	CBIT 2 2 0 14 Expecting SOF List ;
	CBIT 1 2 0 14 List Error ;
	HBYT 0 2 90 c2 SIF Transmit Status 2:;
	CBIT 7 2 0 14 CSTAT Valid Bit ;
	CBIT 5 2 0 14 CSTAT SOF Bit ;
	CBIT 4 2 0 14 CSTAT EOF Bit ;
	HBYT 0 2 90 c2 SIF Receive Status 1:;
	CBIT 7 2 0 14 Subtask Not Ready ;
	CBIT 6 2 0 14 Waiting For Continue ;
	CBIT 5 2 0 14 Waiting For Validation ;
	HBYT 0 2 90 c2 SIF Receive Status 2:;
	CBIT 7 2 0 14 Expecting SOF List ;
	CBIT 6 2 0 14 RI-Pad Escape ;
	TRTS;
void Transmit Status Code;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Group Address;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Functional Address;
	HEX# 0 3 90 c2 Value:;
	TRTS;
void Isolating Errors;
	DBYT 0 0 90 c2 Line Error:;
	DBYT 0 0 90 c2 Internal Error:;
	DBYT 0 0 90 c2 Burst Error:;
	DBYT 0 0 90 c2 A/C (ARI/FCI) Error:;
	DBYT 0 0 90 c2 Reserved:;
	DBYT 0 0 90 c2 Reserved:;
	TRTS;
void Nonisolating Errors;
	DBYT 0 0 90 c2 Lost Frame:;
	DBYT 0 0 90 c2 Receive Congestion:;
	DBYT 0 0 90 c2 Frame Copied Error:;
	DBYT 0 0 90 c2 Frequency Error:;
	DBYT 0 0 90 c2 Token Error:;
	DBYT 0 0 90 c2 Reserved:;
	TRTS;
void Error Code;
	HWRD 0 2 90 c2 Value:;
	CST# 0 2 0 14 MV Error Types;
	TRTS;

void TR Routing Info()
{
	LABL 0 0 0 b1 Source Routing Information;
	BBIT 3 7 90 c2 Broadcast Bits:;
	CST# ffffffff 7 0 14 Brd Bit Types;
	BBIT 5 8 90 c2 Length:;
	DGLB 0 8 4 14 (;
	LABL 0 0 0 4 ")";
	BBIT 1 7 90 c2 Direction:;
	BBIT 3 7 90 c2 Longest Frame:;
	CST# ffffffff 7 0 14 Long Frame Types;
	BBIT 4 7 90 c2 Reserved:;
	ADDG fffffffe 8 0 82;
	MOVE 1 9 0 82;
	TLTE 1 8 0 14 TR Segment Number;
	TR::802_2();
}


void TR Segment Number()
{
	DGLB 0 9 2 c2 Segment #;
	HWRD 0 7 90 2 :;
	ADDG fffffffe 8 0 82;
	ADDG 1 9 0 82;
	TLTE 1 8 0 14 TR Segment Number;
	TR::802_2();
}

// BL: Shameless copy of 802.1Q (because that's what 802.1ad is).
void 802_1ad()
{
	LABL 0 0 0 b1 802.1ad Provider Bridge\802.1ad:;
	GBYT 0 c;
	BBIT 3 0 90 c2 Priority:\Priority:;
	BBIT 1 c 90 c2 DEI:;
	DBIT c 0 90 c2 ID:;

	//test protocol type for LLC
	MOVE 1 31;  // BD: have to special case for 802.2 because it eats to many bytes
	GWRD 0 1;
	INCR 2;
	TGTE 5dc 1 0 0 802_2;
	
	//si: ok, i dunno what bd did up there... but here's my hack fix for the missing protocol type
	DECR 2;
	HWRD 0 1 90 c2 Protocol Type:\Protocol:;
	EProto::Names;
	Ether::Branching_3;
	TRTS;
}


void 802_1q()
{
	LABL 0 0 0 b1 802.1Q Virtual Bridged LAN\802.1Q VLAN:;
	GBYT 0 c;
	BBIT 3 0 90 c2 User Priority:\Priority:;
	BBIT 1 c 90 c2 CFI:;
	CBIT 1 c 0 14 (E-RIF present);
	CLSE 0 0 0 14 (E-RIF not present);
	DBIT c 0 90 c2 VLAN ID:;

	//test protocol type for LLC
	MOVE 1 31;  //BD: have to special case for 802.2 because it eats to many bytes
	GWRD 0 1;
	INCR 2;
	TGTE 5dc 1 0 0 802_2;
	
	//si: ok, i dunno what bd did up there... but here's my hack fix for the missing protocol type
	DECR 2;
	HWRD 0 1 90 c2 Protocol Type:\Protocol:;
	EProto::Names;
	Ether::Branching_3;
	TRTS;
}

void 802_11::Generic()
{
	LABL  0  0  0 b1 Packet Info\Info:;
	PRV7  0  0 90 c3 Packet Number:;
	PRV2  0  1 90 c3 Flags:\F:;
	CBIT  1  1  0 14 CRC Error ;
	CBIT  2  1  0 14 Frame Error ;
	CBIT  4  1  0 14 Oversize ;
	CBIT  5  1  0 14 Runt ;
	CBIT  6  1  0 14 Trigger ;
	CBIT  7  1  0 14 802.3;
	PRV3  0  1 90 c3 Status:\Stat:;
	CBIT  1  1  0 14 Truncated ;
	CBIT  5  1  0 14 Sliced ;
	CBIT  2  1  0 14 Encrypted ;
	CBIT  3  1  0 14 Decryption Error ;
	CBIT  6  1  0 14 Short Preamble;
//   g16 is used by most downstream decoders for length
	PRV4  0 10 90 c3 Packet Length:\Len:;
	PRV5  0  1 90 c3 Slice Length:;
	PRV1  0  0 90 c3 Timestamp:\Time:;
//   802.11 Data Rates
	WRTE  0  1 90 c3 Data Rate:\Rate:;
	WRTE  1  1 a4 04;
//   802.11 Channel
	WCHN  0  1 90 c3 Channel:\Chan:;
	WFRQ  0  1 24 14;
	CST#  0  1 00 04 802_11::G_Channel;
	LABL  0  0 0  04 MHz;
	802.11::BandToString;
//	802.11N packets have extra flags
	if (g[2] == 1)
	{
		802.11::FlagsN;
	}
//   802.11 Signal level (%)
	WSGP  0  0 90 c3 Signal Level:;
	LABL  0  0  0  0 %;

	//   802.11 Signal dBm (3 extra with 802.11N)
	if (g[2] == 1)
	{
		LABL 0 0 0 b7 Signal dBm;
		WSGD  0  0 90 c3 Signal dBm0:\0=;
		WSD1  0  0 90 c3 Signal dBm1:\1=;
		WSD2  0  0 90 c3 Signal dBm2:\2=;
		WSD3  0  0 90 c3 Signal dBm3:\3=;
		LABL 0 0 0 b8;
	}

	if (g[2] != 1)
	{
		WSGD  0  0 90 c3 Signal dBm:;
	}

//802.11 Noise level (%)
	WNSP  0  0 90 c3 Noise Level:;
	LABL  0  0  0  0 %;

//802.11 Noise dBm (3 extra with 802.11N)
	if (g[2] == 1)
	{
		LABL 0 0 0 b7 Noise dBm;
		WNSD  0  0 90 c3 Noise dBm0:\0=;
		WND1  0  0 90 c3 Noise dBm1:\1=;
		WND2  0  0 90 c3 Noise dBm2:\2=;
		WND3  0  0 90 c3 Noise dBm3:\3=;
		LABL 0 0 0 b8;
	}

	if (g[2] != 1)
	{
		WNSD  0  0 90 c3 Noise dBm:;
	}

// Dump remaining packet data
	DUMP  0  0 90 b1 Raw Packet Data;
}

void 802.11::FlagsN()
{
	WFLN  0  1 5 0;	// load to register 1
//	Display 802.11N flags
	BGLB 0 1 90 ba 802.11 Flags:;

	// if the 80 or 160 MHz flag is set then set l[2] to 1
	l[1] = g[1];	
    l[1] &= 0x0600;
	l[2] = 0;	
	if (l[1] != 0)
	{
		l[2] = 1;
	}

	CBIT 12 1 0 d4 .1.. .... .... .... .... STBC;
//	TT17944
     CBIT F 1 0 d4 .... 1... .... .... .... Cisco AC3;
	 CBIT E 1 0 d4 .... .1.. .... .... .... Cisco AC2;
	 CBIT D 1 0 d4 .... ..1. .... .... .... Mode 2x3;
	 CBIT C 1 0 d4 .... ...1 .... .... .... Mode 2x2;
	 CBIT B 1 0 d4 .... .... 1... .... .... NSS is high byte in data rate;	 
	 CBIT A 1 0 d4 .... .... .1.. .... .... 160MHz;
	 CBIT 9 1 0 d4 .... .... ..1. .... .... 80MHz;
	 CBIT 8 1 0 d4 .... .... ...1 .... .... MCS Index Used;
	 CBIT 7 1 0 d4 .... .... .... 1... .... Greenfield;
	 CBIT 6 1 0 d4 .... .... .... .1.. .... VHT;
	 CBIT 5 1 0 d4 .... .... .... ..1. .... Aggregated;
	 CBIT 4 1 0 d4 .... .... .... ...1 .... Long GI;
	 CBIT 3 1 0 d4 .... .... .... .... 1... Short GI;

	 // Don't show the 40MHz flag if the 80 or 160 MHz flag is set
	 if (l[2] != 1)
	 {
		CBIT 2 1 0 d4 .... .... .... .... .1.. 40MHz;
	 }

	 CBIT 1 1 0 d4 .... .... .... .... ..1. 20MHz Upper;
	 CBIT 0 1 0 d4 .... .... .... .... ...1 20MHz Lower;
	LABL 0 0 0 b8;
	
	//store the AMPDU flag in g[2] before returning
	g[2] = g[1];
	g[2] &= 0x20;
	SHFR 5 2;
	
	TRTS;
}

// if it is ac, set g[2] to 1
void 802.11::BandToString()
{
	WBND  0  1 5  0;
//	there are 4 ranges of numbers, 1-9, 100+, 200+, 300+

// check for ac
	if (g[1] == 201)
	{
		g[2] = 1;
	}
	if (g[1] == 202)
	{
		g[2] = 1;
	}
	if (g[1] == 203)
	{
		g[2] = 1;
	}
	if (g[1] == 204)
	{
		g[2] = 1;
	}
	if (g[1] >= 400)
	{
		if (g[1] < 403)
		{
			g[2] = 1;
		}
	}

	SLTE  9  1;	// skip if 9 <= band
	SKIP  5;
	CST#  ffffffff 1 0 14 802.11 Bands;
	if (g[1] == 6)
	{
		g[2] = 1;		// 802.11n flag check
	}
	TRTS;
	SLTE  c7 1;	// skip if 199 (c7) <= band
	SKIP  3;
	SUBG  64 1;
	CST#  ffffffff 1 0 14 802.11a Bands;
	TRTS;
//	SLTE  12b 1;	// skip if 299 <= band
//	SKIP  3;
	if (g[1] <= 299)
	{
		// Original:	 SUBG  c8 1;
		// SamChen:  802.11 ac mapping
		WFLN( 0, l[1], 5, 0 );  * store into local	
		// BGLB 0 1 90 ba ### SamChen: 222 flags -- ;

		// CBIT A 1 0 d4 .... .... .1.. .... .... 160MHz;
		// CBIT 9 1 0 d4 .... .... ..1. .... .... 80MHz;
		// CBIT 8 1 0 d4 .... .... ...1 .... .... MCS Index Used;
		// CBIT 2 1 0 d4 .... .... .... .... .1.. 40MHz;

		g[1] = 0;
		l[2] = l[1];
		l[2] &= 0x00000004;
		if (l[2] != 0)
		{
			// 40MHz
			g[1] = 1;
		}

		l[2] = l[1];
		l[2] &= 0x00000200;
		if (l[2] != 0)
		{
			// 80MHz
			g[1] = 2;
		}

		l[2] = l[1];
		l[2] &= 0x00000400;
		if (l[2] != 0)
		{
			// 160MHz
			g[1] = 3;
		}

		// DGLB 0 1 90 c2 G1=;  
		// SamChen: End Added
		CST#  ffffffff 1 0 14 802.11u Bands;
		TRTS;
	}

//	SUBG  c8 1;
//	CST#  ffffffff 1 0 14 802.11u Bands;
//	TRTS;
	if (g[1] >= 400)
	{
		if (g[1] < 403)
		{
			WFLN( 0, l[1], 5, 0 );  * store into local
			// CBIT A 1 0 d4 .... .... .1.. .... .... 160MHz;
			// CBIT 9 1 0 d4 .... .... ..1. .... .... 80MHz;
			// CBIT 8 1 0 d4 .... .... ...1 .... .... MCS Index Used;
			// CBIT 2 1 0 d4 .... .... .... .... .1.. 40MHz;

			g[1] = 2;

			l[2] = l[1];
			l[2] &= 0x00000003;
			if (l[2] != 0)
			{
				// 20MHz
				g[1] = 0;
			}

			l[2] = l[1];
			l[2] &= 0x00000004;
			if (l[2] != 0)
			{
				// 40MHz
				g[1] = 1;
			}

			l[2] = l[1];
			l[2] &= 0x00000200;
			if (l[2] != 0)
			{
				// 80MHz
				g[1] = 2;
			}

			l[2] = l[1];
			l[2] &= 0x00000400;
			if (l[2] != 0)
			{
				// 160MHz
				g[1] = 3;
			}

			CST#  ffffffff 1 0 14 802.11u Bands;
			TRTS;
		}
	}
	SLTE  18f 1;	// skip if 399 <= band
	SUBG  12c 1;
	CST#  ffffffff 1 0 14 802.11n Bands;
	g[2] = 1;		// 802.11n flag check
	TRTS;
	// unknown range...
	TRTS;
}
	
void 802_11::Send_Main()
{
	PRV4 0 1 90 43 Packet Length:;
	802_11::Main2();
}

str# 802_11::G_Channel;
	4942 | .5 ;
	4947 | .5 ;
	4952 | .5 ;
	4957 | .5 ;
	4962 | .5 ;
	4967 | .5 ;
	4972 | .5 ;
	4977 | .5 ;
	4982 | .5 ;
	4987 | .5 ;



// ///////////////////////////////////////////////////////////////////////////////////////////
// A ieee 802.11 handbook-a designer's companion, ieee press, 1999
// B 802_11b.pdf
// C 802_11-1997.pdf
// ///////////////////////////////////////////////////////////////////////////////////////////
// shared globals can always be over written from void to Dcod
// parameter globals are set in one void and used in the called Dcod
// reserve globals are set in a void and expected to be unchanged until that void exits
// share g1..g5 parameters g6..g10 reserve g10...g31
// ///////////////////////////////////////////////////////////////////////////////////////////

void 802_11::Main()
{
	TRAK  1 10;
	LABL  0  0  0 b1 "Packet Info";
	PRV7  0  0 90 c3 "Packet Number:";
	PRV2  0  1 90 c3 "Flags:";
	CBIT  1  1  0 14 "CRC Error ";
	CBIT  2  1  0 14 "Frame Error ";
	CBIT  4  1  0 14 "Oversize ";
	CBIT  5  1  0 14 "Runt ";
	CBIT  6  1  0 14 "Trigger ";
	CBIT  7  1  0 14 "802.3";
	PRV3  0  1 90 c3 "Status:";
	CBIT  1  1  0 14 "Truncated ";
	CBIT  5  1  0 14 "Sliced ";
	CBIT  2  1  0 14 "Encrypted ";
	CBIT  3  1  0 14 "Decryption Error ";
	CBIT  6  1  0 14 "Short Preamble";
	
		//   g16 is used by most downstream decoders for length
	PRV4  0 10 90 c3 Packet Length:;
		//   g15 is used by most downstream decoders for slice length
	PRV5  0  F 90 c3 Slice Length:;
	
	if ( g[15] != 0 ) 
	{
		// if packet length > slice length
		if (g[16] > g[15])
		{
			g[16] = g[15];
		}
	}
	
	// else
	
	if (g[15] == 0) 
	{
		g[16] -= 4;  // subtract fcs
	}


	PRV1  0  0 90 c3 Timestamp:;
		//   802.11 Data Rates

	g[1] = 0x0fffffff;		//Init global register 1 to some invalid MCS value

	WMCS  0  1 90 c3 MCS Index:;

	if (g[1] != 0x0fffffff)	//If global register 1 has a valid MCS index
	{
		WSSN  0  1 90 c3 Spatial Streams:;
		WRTE  0  1 95 c3 Data Rate:;
		WRTE  1  1 94 04;
	}
	if (g[1] == 0x0fffffff)	//If global register 1 does not have a valid MCS index
	{
		WRTE  0  1 90 c3 Data Rate:;
		WRTE  1  1 a4 04;
	}

// SamChen Debug
//	 WFLN  0  1 5 0;	
//	 BGLB 0 1 90 ba ### SamChen: Look ahead to examine flags -- ;
//	 CBIT 12 1 0 d4 .1.. .... .... .... .... STBC;
//	 CBIT B 1 0 d4 .... .... 1... .... .... NSS is high byte in data rate;	 
//	 CBIT A 1 0 d4 .... .... .1.. .... .... 160MHz;
//	 CBIT 9 1 0 d4 .... .... ..1. .... .... 80MHz;
//	 CBIT 8 1 0 d4 .... .... ...1 .... .... MCS Index Used;
//	 CBIT 2 1 0 d4 .... .... .... .... .1.. 40MHz;
//	 CBIT 1 1 0 d4 .... .... .... .... ..1. 20MHz Upper;
//	 CBIT 0 1 0 d4 .... .... .... .... ...1 20MHz Lower;
//	 LABL 0 0 0 b8;
// SamChen End Debug

		//    802.11 Channel
	WCHN  0  1 90 c3 Channel:\Chan:;
	WFRQ  0  1 24 14;
	CST#  0  1 00 04 802_11::G_Channel;
	LABL  0  0 0  04 MHz;

	802.11::BandToString;
//	802.11N packets have extra flags
	if (g[2] == 1)
	{
		//FlagsN will store the AMPDU flag in g[2]
		l[1] = g[2];	//save g[2] contents to l[1]
		802.11::FlagsN;
		l[2] = g[2];	//save AMPDU flag to l[2]
		g[2] = l[1];	//restore contents to g[2]
	}
		//   802.11 Signal level (%)
	WSGP  0  0 90 c3 Signal Level:;
	LABL  0  0  0  0 %;

	//   802.11 Signal dBm (3 extra with 802.11N)
	if (g[2] == 1)
	{
		LABL 0 0 0 b7 Signal dBm;
		WSGD  0  0 90 c3 Signal dBm0:\0=;
		WSD1  0  0 90 c3 Signal dBm1:\1=;
		WSD2  0  0 90 c3 Signal dBm2:\2=;
		WSD3  0  0 90 c3 Signal dBm3:\3=;
		LABL 0 0 0 b8;
	}

	if (g[2] != 1)
	{
		WSGD  0  0 90 c3 Signal dBm:;
	}

		//   802.11 Noise level (%)
	WNSP  0  0 90 c3 Noise Level:;
	LABL  0  0  0  0 %;

	//   802.11 Noise dBm (3 extra with 802.11N)
	if (g[2] == 1)
	{
		LABL 0 0 0 b7 Noise dBm;
		WNSD  0  0 90 c3 Noise dBm0:\0=;
		WND1  0  0 90 c3 Noise dBm1:\1=;
		WND2  0  0 90 c3 Noise dBm2:\2=;
		WND3  0  0 90 c3 Noise dBm3:\3=;
		LABL 0 0 0 b8;
	}

	if (g[2] != 1)
	{
		WNSD  0  0 90 c3 Noise dBm:;
	}

	//Oct 23 2009
	//I havent tested the A_MPDU code because I don't have any traces with A-MPDU packets.
	//comment out this line to test the A-MPDU stuff
	l[2] = 0;	//comment this out to test A-MPDU decoding
	
	if( l[2] == 0 )
	{
		802_11::Main2();
	}
		
	if( l[2] == 1 )
	{
		802_11N::A_MPDU();
	}
}

void 802_11::Main2()
{
//   802.11 MAC Header
	LABL 0 0 0 b1 802.11 MAC Header;
	GBIT 4 e;		//rp: store subtype in global e
//	Store combined Type and Subtype in g6
	GBIT 6 6;
	ANDG 3 6;
	MULG 10 6;
	GBIT 4 2;
	ADDG 2 86;
//	Display Version
	DBIT 20000002 0 90 c2 Version:;
//	Display Type and put in g10
	BBIT 20000002 a 90 c2 Type:;
	CST# ffffffff a 0 14 802_11::Type;
//	Display Subtype and put in g11
	BBIT 20000004 0 90 c2 Subtype:;
//	Interpret the Subtype
	CST# ffffffff 6 0 14 802_11::Subtype;
//	Store Frame Control flags in g7
//	Display Frame Control flags
	BBYT 0 7 90 b9 Frame Control Flags:;
	 CBIT 7 7 0 d4 1... .... Frames Must Be Strictly Ordered;
	 CLSE 0 0 0 d4 0... .... Non-strict order;
	 CBIT 6 7 0 d4 .1.. .... Protected Frame;
	 CLSE 0 0 0 d4 .0.. .... Non-Protected Frame;
	 CBIT 5 7 0 d4 ..1. .... More Data;
	 CLSE 0 0 0 d4 ..0. .... No More Data;
	 CBIT 4 7 0 d4 ...1 .... Power Management - power save mode;
	 CLSE 0 0 0 d4 ...0 .... Power Management - active mode;
	 CBIT 3 7 0 d4 .... 1... This is a Re-Transmission;
	 CLSE 0 0 0 d4 .... 0... This is not a Re-Transmission;
	 CBIT 2 7 0 d4 .... .1.. More Fragments to Follow;
	 CLSE 0 0 0 d4 .... .0.. Last or Unfragmented Frame;
	 CBIT 1 7 0 d4 .... ..1. Exit from the Distribution System;
	 CLSE 0 0 0 d4 .... ..0. Not an Exit from the Distribution System;
	 CBIT 0 7 0 d4 .... ...1 To the Distribution System;
	 CLSE 0 0 0 d4 .... ...0 Not to the Distribution System;
	LABL 0 0 0 b8;
*   Note: don't adjust g16 since the packet length
*     doesn't include the private header bytes
*	g6 = Combined Type and Subtype
*	g7 = Frame Control flags
	TEQU 2 a 0 0 802_11::Data;
	TEQU 1 a 0 0 802_11::Control;
	TEQU 0 a 0 0 802_11::Mgmt;
	TLSE 0 0 0 0 802_11::Unknown;
}
	
//------------------------------------------
void 802_11::Unknown()
{
	GWRD( 0, l[1] );
	if (l[1] != 0xffff)
	{
		DWRD( 0, 0, 0x90, 0xc2, "Unkown Content:");
		ETHR( 0, 0, 0x90, 0xc2, "BSSID:");
		ETHR( 0, 0, 0x90, 0xc2, "Source:");
		ETHR( 0, 0, 0x90, 0xc2, "Destination:");
		HEX#( 0, g[16], 0x90, 0xc2, "Unknown Content:" );
	}
	if (l[1] == 0xffff)
	{
		//DWRD( 0, 0, 0x90, 0xc2, "Filler:");
		ETHR( 0, 0, 0x90, 0xc2, "BSSID:");
		ETHR( 0, 0, 0x90, 0xc2, "Source:");
		ETHR( 0, 0, 0x90, 0xc2, "Destination:");
		HEX#( 0, g[16], 0x90, 0xc2, "Unknown Content:" );
	}
	
}	
void 802_11::Dump()
{
	LABL 0 0 0 c8;
	DUMP( 1, 0, 0x90, 0xb6, "Extra bytes (Padding):\Extra:" );
	LABL 0 0 0 c8;
	FCS();
}
	
//------------------------------------------
	
void 802_11::Control()
{
	g[60] = g[6];
	TEQU 18 6 0 0 802_11::Control::BlockAckReq;
	TEQU 19 6 0 0 802_11::Control::BlockAck;
	TEQU 1a 6 0 0 802_11::Control PS;
	TEQU 1b 6 0 0 802_11::Control RTS;
	TEQU 1c 6 0 0 802_11::Control CTS;
	TEQU 1d 6 0 0 802_11::Control ACK;
	TEQU 1e 6 0 0 802_11::Control CF-END;
	TEQU 1f 6 0 0 802_11::Control CF-END+CF-ACK;
	TEQU 17 6 0 0 802_11::Control Wrapper;
	TEQU 14 6 0 0 802_11::Control Beamforming-Report-Poll;
	TEQU 15 6 0 0 802_11::Control VHT-NDP-Announcement;
}

//------------------------------------------

void 802_11::Control::BlockAckReq()
{
	if (g[60] != 0x17)
	{
		DWRD 40000000 0 90 c2 Duration:;
		LABL 0 0 0 14 Microseconds;
		ETHR 0 0 90 c2 Receiver:;
	}
	ETHR 0 0 90 c2 Transmitter:;
	802_11::Control::Block::ControlField;
	802_11::Control::Block::Sequence;
	TRTS;
}	
//-------------------------

void 802_11::Control::BlockAck;	
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Receiver:;
	ETHR 0 0 90 c2 Transmitter:;
	802_11::Control::Block::ControlField;
	802_11::Control::Block::Sequence;
	//TODO: Fix this, Basic BlockAck also has a Bitmap. 802.11n Draft-4 7.2.1.8.2
	if (g[2] == 2)
	{
		GBYT 0 41 0 0;
		GBYT 1 42 0 0;
		GBYT 2 43 0 0;
		GBYT 3 44 0 0;
		GBYT 4 45 0 0;
		GBYT 5 46 0 0;
		GBYT 6 47 0 0;
		GBYT 7 48 0 0;
		HEX# 40000008 0 90 c9 BlockAck Bitmap:;
		LABL 0 0 90 c2 Byte 0:;
		HGLB 0 41 90 42;
		LABL 0 0 90 c2 Byte 1:;
		HGLB 0 42 90 42;
		LABL 0 0 90 c2 Byte 2:;
		HGLB 0 43 90 42;
		LABL 0 0 90 c2 Byte 3:;
		HGLB 0 44 90 42;
		LABL 0 0 90 c2 Byte 4:;
		HGLB 0 45 90 42;
		LABL 0 0 90 c2 Byte 5:;
		HGLB 0 46 90 42;
		LABL 0 0 90 c2 Byte 6:;
		HGLB 0 47 90 42;
		LABL 0 0 90 c2 Byte 7:;
		HGLB 0 48 90 42;
		LABL 0 0 0 c8;
		TRTS;
	}
	DUMP 0 10 90 c2 BlockAck Bitmap:;
	TRTS;

//-------------------------

void 802_11::Control::Block::ControlField;
	BWRD 40000000 1 90 c9 Control Field:;
	l[1] = g[1];
	ANDG f000 41;
	SHFR c 41;
	CST# 0 41 00 d4 802_11::Control::Block::ControlFieldList;
	CLSE 0 0 00 d4 0000.... ........ TID: 0;
	LABL 0 0 00 d4 ....xxxx xxxxx... Reserved;
	g[2] = g[1];
	ANDG 6 2;
	SHFR 1 2;
	CEQU 3 2 00 d4 ........ .....11. Multi-TID BlockAck;
	CEQU 2 2 00 d4 ........ .....10. Compressed BlockAck (8 bytes);
	CEQU 1 2 00 d4 ........ .....01. Reserved;
	CEQU 0 2 00 d4 ........ .....00. BlockAck;
	
	CBIT 0 1 00 d4 ........ .......1 ACK policy: No Acknowledgement;
	CLSE 0 0 00 d4 ........ .......0 ACK policy: Normal Acknowledgement;
	LABL 0 0 00 c8;
	TRTS;

str# 802_11::Control::Block::ControlFieldList;
	0001.... ........ TID: 1;
	0010.... ........ TID: 2;
	0011.... ........ TID: 3;
	0100.... ........ TID: 4;
	0101.... ........ TID: 5;
	0110.... ........ TID: 6;
	0111.... ........ TID: 7;
	1000.... ........ TID: 8;
	1001.... ........ TID: 9;
	1010.... ........ TID: 10;
	1011.... ........ TID: 11;
	1100.... ........ TID: 12;
	1101.... ........ TID: 13;
	1110.... ........ TID: 14;
	1111.... ........ TID: 15;

void 802_11::Control::Block::Sequence;
	BWRD 40000000 1 90 c9 BA Starting Sequence Control:;
	l[2] = g[1];
	ANDG fff0 42;
	SHFR 4 42;
	DGLB 0 42 00 d4 -------- ----.... Starting Seq Number: ;
	ANDG f 1;
	CST# 0 01 00 d4 802_11::Control::Block::FragmentNum;
	CLSE 0 00 00 d4 ........ ....0000 Fragment Number: 0;
	LABL 0 00 00 c8;
	TRTS;

str# 802_11::Control::Block::FragmentNum;
	........ ....0001 Fragment Number: 1;
	........ ....0010 Fragment Number: 2;
	........ ....0011 Fragment Number: 3;
	........ ....0100 Fragment Number: 4;
	........ ....0101 Fragment Number: 5;
	........ ....0110 Fragment Number: 6;
	........ ....0111 Fragment Number: 7;
	........ ....1000 Fragment Number: 8;
	........ ....1001 Fragment Number: 9;
	........ ....1010 Fragment Number: 10;
	........ ....1011 Fragment Number: 11;
	........ ....1100 Fragment Number: 12;
	........ ....1101 Fragment Number: 13;
	........ ....1110 Fragment Number: 14;
	........ ....1111 Fragment Number: 15;

//------------------------------------------

void 802_11::Control PS;
*   duration is unique for 802.11 control ps
	// Association ID is mask 0x3FFF ) and int he range from 1 to 2007 TT23683
	INCR 80000002;
	DBIT 4000000E 1 90 c2 Association ID:;	
	ETHR 0 0 90 c2 BSSID:;
	ETHR 0 0 90 c2 Transmitter:;

//-------------------------
void 802_11::Control RTS;
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Receiver:;
	ETHR 0 0 90 c2 Transmitter:;

//-------------------------
void 802_11::Control CTS;
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Receiver:;

//-------------------------
void 802_11::Control ACK;
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Receiver:;

//-------------------------
void 802_11::Control CF-END;
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Receiver:;
	ETHR 0 0 90 c2 BSSID:;

//-------------------------
void 802_11::Control CF-END+CF-ACK;
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Receiver:;
	ETHR 0 0 90 c2 BSSID:;

//-------------------------
void 802_11::Control Wrapper()
{
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Address:;
	DWRD 40000000 41 90 c2 Carried Frame Control:;
		l[1] &= 0x0f;
		CST# 0 41 0 14 802_11::Controlwrapper_Frame;
		CLSE 0 0 0 14 Unknown;
	//DLNG 40000000 0 90 c2 HT Control:;
	802_11N::HTControlField;
	LABL 0 00 00 c8;
	LABL 0 0 0 b1 Carried Frame:;
	l[1] = g[16];
	DUMP( 0, l[1], 0x90, 0xc2, "Control Frame Data behind Address 1:" );
}

str# 802_11::Controlwrapper_Frame;
0	|	Reserved;
1	|	Reserved;
2	|	Reserved;
3	|	Reserved;
4	|	Beamforming Report Poll;				*IEEE P802.11ac D3.0 June 2012
5	|	VHT NDP Announcement;					*IEEE P802.11ac D3.0 June 2012
6	|	Reserved;
7	|	Control Wrapper;
8	|	Block Acknowledgement Request (BlockAckReq);
9	|	Block Acknowledgement (BlockAck);
10	|	Power Save (PS)-Poll;
11	|	Request To Send (RTS);
12	|	Clear To Send (CTS);
13	|	Acknowledgment (ACK);
14	|	Contention Free (CF)-End;
15	|	CF-End + CF-Ack;
//-------------------------
void 802_11::Control VHT-NDP-Announcement()
{
	l[1] = g[16];
	if (l[1] > 1)
	{
		DWRD 40000000 0 90 c2 Duration:;
		LABL 0 0 0 14 Microseconds;
		l[1] -= 2;
	}
	if (l[1] > 5)
	{
		ETHR 0 0 90 c2 Receiver:;
		l[1] -= 6;
	}
	if (l[1] > 5)
	{
		ETHR 0 0 90 c2 Transmitter:;
		l[1] -= 6;
	}
	/*if (l[1] > 0)
	{
		BBIT 2 0 90 c2 Reserved:;
		BBIT 6 1 90 c2 Sequence Number:;
		l[1] -= 1;
	}*/	
	if (l[1] >= 1)
	{
		HBYT 0 45 90 c9 Sounding Dialog Token:;
			l[6] =  l[5];
			l[6] &= 0xfc;
			SHFR( 2, l[6] );
			DGLB 0 46 90 c2 Sounding Dialog Token Number:;
			l[6] =  l[5];
			l[6] &= 0x03;
			DGLB 0 46 90 c2 Reserved:;
		LABL 0 0 0 c8;
		l[1] -= 1;
	}
	while ( l[1] >= 2 )
	{
		LABL 0 0 90 c7 STA Info:;
		GBIT 4, 44;
		l[4] &= 0x01;
		if( l[4] == 0 )
		{
			DBIT 3 43 90 c2 Reserved:;
			l[3] += 1;
		}
		if( l[4] == 1 )
		{
			DBIT 3 43 90 c2 Nc Index:;
			l[3] += 1;
			DGLB 0 43 04 14 (;
			LABL( 0, 0, 0, 0x04, ")" );			
		}
		BBIT 1 42 90 c2 Feedback Type:;
		CEQU 0 42 0 14 SU;
		CEQU 1 42 0 14 MU;
		HBIT 4000000c 44 90 c2 AID12:;
		LABL 0 0 0 c8;
		l[1] -= 2;
	}
	TRTS;
}

//-------------------------
void 802_11::Control Beamforming-Report-Poll()
{
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Receiver:;
	ETHR 0 0 90 c2 Transmitter:;
	BBYT 0 0 90 c2 Feedback Segment Retransmission Bitmap;
	TRTS;
}

//-------------------------
void 802_11::Data;
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
*   Save the Frame Control flags in g8
	MOVE 7 88;
*   Mask to get combined "To DS" and "From DS"
	ANDG 3 7;
	g[c] = g[7];
	TEQU 0 7 0 0 802_11::Data IBSS;
	TEQU 1 7 0 0 802_11::Data To the AP;
	TEQU 2 7 0 0 802_11::Data From the AP;
	TEQU 3 7 0 0 802_11::Data Wireless DS;

void 802_11::Data Payload()
{
	//g[13] should contain the fragment number of this data (from 802_11::Sequence Control)
	l[13] = g[13];
	
	//get the order bit
	l[1] = g[8];
	l[1] &= 0x80;
	
	//see if this is a qos data frame
	l[2] = g[6];
	l[2] &= 0x38;	//get the frame type and the first bit of the subtype
	
	l[4] = 0;	//l[4] will hold the A-MSDU bit if there is a control field
	if( l[2] == 0x28 )
	{
		//this is a data type with the QoS bit set
		
		//the control field is going to store the A-MSDU bit in g[20] so save the current value
		//so we can restore it later
		l[3] = g[20];
		
		//this is a QoS data field
		802_11:WME_QoS::Control_Field;
		
		l[4] = g[20];	//get the A-MSDU bit
		g[20] = l[3];	//restore whatever was in g[20]
		
		if( l[1] > 0 )
		{
		//the ht control field is only present if the order bit is set to 1
			802_11N::HTControlField;
		}
		
		if( g[6] == 0x28 )
		{
			802_11::AtherosDriver;
		}
	}
	
	// Test the WEP Frame Control flag
	ANDG 40 8;
	TEQU 40 8 0 0 802_11::WEP Data;
	
	if( l[13] > 0 )
	{
		//this is a fragment, just dump it
		LABL 0 0 0 b1 Application Layer\App Layer:;
		DUMP 0 10 90 c2 Continued Data:;
		TRTS;
	}
	
	//does this packet have A-MSDUs?
	if(l[4] == 1)
	{
		802_11::A-MSDU_Loop();
		TRTS;
	}
	
	// Get the first 2 bytes of packet data
	GWRD 0 7 0 40;

	// Handle NetWare Raw
	INCR 2;
	TEQU ffff 7 0 0 Ethernet_802.3 IPX;
	DECR 2;

	// Decode as standard 802.2
	802_2::Common();
}

void 802_11::A-MSDU_Loop()
{
	BREM 0 41 5 5;
	//BREM( 0, g[63], 0x90, 0xc2, Remainung packets:);
	//I am not sure if this is correct
	//the spec isn't clear on how to tell when you have run out of A-MSDUs
	while( l[1] > 0 )
	{
		802_11::A-MSDU();
		BREM 0 41 5 5;
	}
}

void 802_11::A-MSDU()
{
	LABL 0 0 0 b1 Aggregate MSDU (A-MSDU);
	ETHR 0 0 90 c2 Destination:;
	ETHR 0 0 90 c2 Source:;
	DWRD 0 41 90 c2 MSDU Length:;
	g[60] = 23; //set id for 802_11::A-MSDU;TT:22902 
	//clear g[13] before calling
	l[2] = g[13];
	g[13] = 0;
	g[16] = l[1];
	802_2::Common();
	
	//restore g[13]
	g[13] = l[2];
	
	//some of the decoders called by 802_2::Common mess up g[16], set it to the remaining bytes
	BREM 0 10 5 5;
	
	l[1] += 14;	//add in the da, sa and length bytes
	l[1] %= 4;	//figure out the number of padding bytes
	
	if( l[1] > 0 )
	{
		INCR 0 41;
	}
}

void 802_11::WEP Data()
{	
	* si: cisco's tkip stuff
	INCR 3;
	GBYT 0 8;
	DECR 3;
	TBIT 5 8 0 0 802_11::TKIP_CCMP Data;
	
	LABL 0 0 0 b1 WEP Data;
		//   Display the first 3 bytes of the WEP IV
	HEX# 3 0 90 c2 WEP IV:;
		//   Display the WEP Key Index
		//   The Key Index is only 2 bits
	GBIT 2 8;
	DBIT 2 0 90 c2 WEP Key Index:;
		//	Eat the rest of this byte
	INCR 1;
		//   Calculate the WEP payload length
	MOVE 10 88;
	SUBG 4 8;
		//   Display the WEP payload
	DUMP 0 8 90 c2 WEP Data:;
		//   Display the WEP ICV
	HEX# 4 0 90 c2 WEP ICV:;
}

void 802_11::TKIP_CCMP Data()
{
	LABL 0 0 0 b1 802.11 Encrypted Data;
	//DGLB( 0, s[11], 0x90, 0xc2, "s11:" );
	//HEX# 3 0 90 c2 IV:;
	HBYT 0 8 90 c2 TCS/PN 1:;		//TT32759: renamed, outside storage needed to differnece because of flowindicated Method 
	HBYT 0 0 90 c2 TCS/PN 2:;		//TT32759: renamed
	HBYT 0 0 90 c2 RSVD:;
	
	BBYT 0 8 90 c9 Key Index:;
	l[1] = g[8];
	l[2] = g[8];
	
	MOVE 8 87;
	DIVG 40 8;
	ANDG 3 8;
	ADDG 1 8;

	//get the key index bits
	l[1] &= 0xc0;
	
	CEQU 0 41 0 d4	00.. .... Key Index 0;
	CEQU 40 41 0 d4 01.. .... Key Index 1;
	CEQU 80 41 0 d4 10.. .... Key Index 2;
	CEQU c0 41 0 d4 11.. .... Key Index 3;
	
	l[2] &= 0x20
	CEQU 0 42 0 d4	..0. .... No Extended IV;
	CEQU 20 42 0 d4 ..1. .... Has Extended IV;

	LABL 0 0 0 d4	.... xxxx Reserved;
	LABL 0 0 0 c8;
	
	if( l[2] > 0 )
	{
		HEX# 4 0 90 c2 Extended IV:;
	}
	
	MOVE 10 88;
	*INCR 0 8;
	
	SBIT 0 7;
	SKIP 80000004;
	 802_2::Common();
	 MOVE 0 1;
	 SEQU 0 1;
	 SKIP 1;
	DUMP 0 8 90 c2 Encrypted Data:;
}

//--------------------------------------------------

void 802_11::Data IBSS()
{
	ETHR 0 0 90 c2 Destination:;
	ETHR 0 0 90 c2 Source:;
	ETHR 0 0 90 c2 BSSID:;
	802_11::Sequence Control;
	TGTE 0 10 0 0 RETURN;
	TNXT -802_11::Data Payload;
}

//--------------------------------------------------

void 802_11::Data From the AP()
{
	ETHR 0 0 90 c2 Destination:;
	ETHR 0 0 90 c2 BSSID:;
	ETHR 0 0 90 c2 Source:;
	802_11::Sequence Control;
	TGTE 0 10 0 0 RETURN;
//	DGLB 0 a 90 c2 g[10]:;
//	if (g[10] == 2)
//	{
//		INCR 1;
//	}
	802_11::Data Payload;
}

//si: smarter 3com byte alignment bs
//		if it doesn't see the AAAA, it will NOT incr
void 802_11::AtherosDriver;
	g[1] = pw[0];
	if (g[1] != 0xaaaa)
	{
		g[1] = pw[2];
		if (g[1] == 0xaaaa)
		{
			HWRD 0 0 90 c2 Driver Byte Alignment:;
		}
	}
	TRTS;

//--------------------------------------------------

void 802_11::Data To the AP()
{
	ETHR 0 0 90 c2 BSSID:;
	ETHR 0 0 90 c2 Source:;
	ETHR 0 0 90 c2 Destination:;
	802_11::Sequence Control;
	TGTE 0 10 0 0 RETURN;
	802_11::Data Payload;
}

//--------------------------------------------------

void 802_11::Data Wireless DS()
{
	ETHR 0 0 90 c2 Receiver:;
	ETHR 0 0 90 c2 Transmitter:;
	ETHR 0 0 90 c2 Destination:;
	802_11::Sequence Control;
	TGTE 0 10 0 0 RETURN;
	ETHR 0 0 90 c2 Source:;
	802_11::Data Payload;
}

//--------------------------------------------------

void 802_11::Sequence Control()
{
	DBIT 4000000C 0 90 c2 Seq Number:;
	DECR 1;
*	Note: DECR and INCR reset the bit index
	DBIT 20000004 d 90 c2 Frag Number:;
	INCR 2;
/*
	* if frag!=0 then back up for remaining data
	if (g[0xd] != 0)
	{
		INCR 1;
		DECR 1;
		LABL 0 0 0 b1 Application Layer\App Layer:;
		DUMP 0 10 90 c2 Continued Data:;
	}
*/
}
	
//--------------------------------------------------

// The A-MSDU bit will be set in g[20] before leaving this function
void 802_11:WME_QoS::Control_Field;
	BWRD 40000000 41 90 c9 QoS Control Field:;
	l[5] = l[1];				// A-MSDU bit
	ANDG 80 45;
	SHFR 7 45;
	l[4] = l[1];				// Store first 8 bits
	ANDG FF00 44;
	SHFR 8 44;
	 if (g[0xe] == 8)			// Qos Data
	 {
		if(g[0xc] == 1)
		{
			l[3] = l[1];
			ANDG 10 43;
			SHFR 4 43;
			if(l[3] == 0)
			{
				DGLB 0 44 04 d4 -------- ........ TXOP Duration Requested: ;
			}
			if(l[3] == 1)
			{
				DGLB 0 44 04 d4 -------- ........ Queue Size: ;
			}
		}
		if(g[0xc] != 1)
		{
			DGLB 0 44 04 d4 -------- ........ AP PS Buffer State: ;
		}
		CBIT 7 41 00 d4 ........ 1....... A-MSDU: Present;
		CLSE 0 00 00 d4 ........ 0....... A-MSDU: Not Present;
	 }
	 if (g[0xe] == 9)			// QoS Data+CF-Ack
	 {
		if(g[0xc] == 1)
		{
			l[3] = l[1];
			ANDG 10 43;
			SHFR 4 43;
			if(l[3] == 0)
			{
				DGLB 0 44 04 d4 -------- ........ TXOP Duration Requested: ;
			}
			if(l[3] == 1)
			{
				DGLB 0 44 04 d4 -------- ........ Queue Size: ;
			}
		}
		if(g[0xc] != 1)
		{
			DGLB 0 44 04 d4 -------- ........ AP PS Buffer State: ;
		}
		CBIT 7 41 00 d4 ........ 1....... A-MSDU: Present;
		CLSE 0 00 00 d4 ........ 0....... A-MSDU: Not Present;
	 }
	 if (g[0xe] == 10)			// QoS Data+CF-Poll
	 {
		DGLB 0 44 04 d4 -------- ........ TXOP Limit: ;
		CBIT 7 41 00 d4 ........ 1....... A-MSDU: Present;
		CLSE 0 00 00 d4 ........ 0....... A-MSDU: Not Present;
	 }
	 if (g[0xe] == 11)			// QoS Data+CF-Ack+CF-Poll
	 {
		DGLB 0 44 04 d4 -------- ........ TXOP Limit: ;
		CBIT 7 41 00 d4 ........ 1....... A-MSDU: Present;
		CLSE 0 00 00 d4 ........ 0....... A-MSDU: Not Present;
	 }
	 if (g[0xe] == 12)			// QoS Null frames
	 {
		if(g[0xc] == 1)
		{
			l[3] = l[1];
			ANDG 10 43;
			SHFR 4 43;
			if(l[3] == 0)
			{
				DGLB 0 44 04 d4 -------- ........ TXOP Duration Requested: ;
			}
			if(l[3] == 1)
			{
				DGLB 0 44 04 d4 -------- ........ Queue Size: ;
			}
		}
		if(g[0xc] != 1)
		{
			DGLB 0 44 04 d4 -------- ........ AP PS Buffer State: ;
		}
		LABL 0 00 00 d4 ........ x....... Reserved; 
	 }
	 if (g[0xe] == 14)			// QoS CF-Poll
	 {
		DGLB 0 44 04 d4 -------- ........ TXOP Limit: ;
		LABL 0 00 00 d4 ........ x....... Reserved; 
	 }
	 if (g[0xe] == 15)			// QoS CF-Ack+CFPoll
	 {
		DGLB 0 44 04 d4 -------- ........ TXOP Limit: ;
		LABL 0 00 00 d4 ........ x....... Reserved; 
	 }
	 l[2] = l[1];
	 ANDG 60 42;
	 SHFR 5 42;
	 CST# 0 42 00 d4 802_11:WME_QoS::Control_Field::Ack_Policy;
	 CLSE 0 00 00 d4 ........ .00..... Ack: Normal Acknowledge;
	 CBIT 4 41 00 d4 ........ ...1.... EOSP: End of Triggered Service Period;
	 CLSE 0 00 00 d4 ........ ...0.... EOSP: Not End of Triggered Service Period;
	 l[2] = l[1];
	 ANDG f 42;
	 
	 CST# 0 42 00 d4 802_11:WME_QoS::Control_Field::UP;
	 CLSE 0 42 00 d4 ........ ....0000 UP: 0 - Best Effort;
	LABL 0 0 0 c8;
	
	//store the A-MSDU bit in g[20]
	g[20] = l[5];

str# 802_11:WME_QoS::Control_Field::Ack_Policy;
	........ .01..... Ack: No Acknowledgement;
	........ .10..... Ack: No Explicit Acknowledgement;				//No Explicit Acknowledgement;
	........ .11..... Ack: Block Acknowledgement;					//Block Acknowledgement;

str# 802_11:WME_QoS::Control_Field::UP;
	........ ....0001 UP: 1 - Background;
	........ ....0010 UP: 2 - Background;
	........ ....0011 UP: 3 - Best Effort;
	........ ....0100 UP: 4 - Video;
	........ ....0101 UP: 5 - Video;
	........ ....0110 UP: 6 - Voice;
	........ ....0111 UP: 7 - Voice;
	........ ....1000 Traffic Stream ID;
	........ ....1001 Traffic Stream ID;
	........ ....1010 Traffic Stream ID;
	........ ....1011 Traffic Stream ID;
	........ ....1100 Traffic Stream ID;
	........ ....1101 Traffic Stream ID;
	........ ....1110 Traffic Stream ID;
	........ ....1111 Traffic Stream ID;

//--------------------------------------------------

void 802_11::Mgmt()
{
	DWRD 40000000 0 90 c2 Duration:;
	LABL 0 0 0 14 Microseconds;
	ETHR 0 0 90 c2 Destination:;
	ETHR 0 0 90 c2 Source:;
	ETHR 0 0 90 c2 BSSID:;
	802_11::Sequence Control;
	TGTE 0 10 0 0 RETURN;
	
	//get the order bit
	l[1] = g[7];
	l[1] &= 0x80;
	
	//see if this is a management frame
	l[2] = g[6];
	l[2] &= 0x38;	//get the frame type and the first bit of the subtype
	
	if( l[2] < 0x10 )
	{
		//this is a management field
		if( l[1] > 0 )
		{
			//the ht control field is only present if the order bit is set to 1
			802_11N::HTControlField;
		}
	}
	
	MOVE 7 88;
	ANDG 40 8;
	TEQU 40 8 0 0 802_11::WEP Data;
	TSB# 0 6 -802_11::Mgmt_Str;
}

str# 802_11::Mgmt_Str;
	0x0 | 802_11::Mgmt Association Request;
	0x1 | 802_11::Mgmt Association Response;
	0x2 | 802_11::Mgmt Reassociation Request;
	0x3 | 802_11::Mgmt Reassociation Response;
	0x4 | 802_11::Mgmt Probe Request;
	0x5 | 802_11::Mgmt Probe Response;
	0x8 | 802_11::Mgmt Beacon;
	0x9 | 802_11::Mgmt ATIM;
	0xa | 802_11::Mgmt Disassociation;
	0xb | 802_11::Mgmt Authentication;
	0xc | 802_11::Mgmt Deauthentication;
	0xd | 802_11::Mgmt_Action;
	0xe | 802_11::Mgmt_Action_No_Ack;
	
	
//-----------------------------------
	
void 802_11::Mgmt Association Request()
{
	LABL 0 0 0 b1 802.11 Management - Association Request\Assoc Req:;
	802_11::Capability Information;
	DWRD 40000000 0 90 c2 Listen Interval:;
	802_11::Information_Element_Loop();
}
	
//-----------------------------------
	
	
void 802_11::Mgmt Association Response()
{
	LABL 0 0 0 b1 802.11 Management - Association Response\Assoc Rsp:;
	802_11::Capability Information;
	DWRD 40000000 1 90 c2 Status Code:;
	CST#		0 1 0 14 802_11::Status Code;

	
	// Association ID is mask 0x3FFF ) and in the range from 1 to 2007 TT23683
	INCR 80000002;
	DBIT 4000000E 1 90 c2 Association ID:;	
	
	802_11::Information_Element_Loop();
}

	
//-----------------------------------
	
void 802_11::Mgmt Reassociation Request()
{
	LABL 0 0 0 b1 802.11 Management - Reassociation Request\Reassoc Req:;
	802_11::Capability Information;
	DWRD 40000000 0 90 c2 Listen Interval:;
	ETHR 0 0 90 c2 Current AP Address:;
	802_11::Information_Element_Loop();
}

//-----------------------------------

void 802_11::Mgmt Reassociation Response()
{
	LABL 0 0 0 b1 802.11 Management - Reassociation Response\Reassoc Rsp:;
	802_11::Capability Information;
	DWRD 40000000 1 90 c2 Status Code:;
	CST#		0 1 0 14 802_11::Status Code;
	

	// Association ID is mask 0x3FFF ) and in the range from 1 to 2007 TT23683
	INCR 80000002;
	DBIT 4000000E 1 90 c2 Association ID:;	
	
	802_11::Information_Element_Loop();
}
	
//-----------------------------------
	
void 802_11::Mgmt Probe Request()
{
	LABL 0 0 0 b1 802.11 Management - Probe Request\Probe Req:;
	802_11::Information_Element_Loop();
}

//-----------------------------------

void 802_11::Mgmt Probe Response()
{
	LABL 0 0 0 b1 802.11 Management - Probe Response\Probe Rsp:;
	D64B 40000000 0 90 c2 Probe Timestamp:;
	LABL 0 0 0 14 Microseconds;
	DWRD( 0x40000000, l[41], 0x90, 0xc2, "Beacon Interval:" );
	g[21] = l[41];  // set global so we can get to it later
	LABL 0 0 0 14 Time Units (;	
	l[41] *= 1024;
	if (l[41] <= 1000000)
	{
		l[42] = l[41];		
		l[41] /= 1000;
		DGLB( 0, l[41], 0x04, 0, );
		LABL( 0, 0, 0, 0x04, " Milliseconds, and " );
		l[41] *= 1000;
		l[42] -= l[41];
		DGLB( 0, l[42], 0x04, 0 );
		LABL( 0, 0, 0, 0x04, " Microseconds)" );
	}
	if (l[41] >= 1000000)
	{
		LABL( 0, 0, 0, 0x04, "~" );
		l[41] /= 1000000;
		DGLB( 0x40000000, l[41], 0x04, 0, );
		LABL( 0, 0, 0, 0x04, " Seconds)" );
		LABL 0 0 0 14;
	}
	802_11::Capability Information;
	802_11::Information_Element_Loop();
}

//-----------------------------------
			
void 802_11::Mgmt Beacon()
{
	LABL 0 0 0 b1 802.11 Management - Beacon\Beacon;
	D64B 40000000 0 90 c2 Beacon Timestamp:;
	LABL 0 0 0 14 Microseconds;
	DWRD( 0x40000000, l[41], 0x90, 0xc2, "Beacon Interval:" );
	g[21] = l[41];  // set global so we can get to it later
	LABL 0 0 0 14 Time Units (;	
	l[41] *= 1024;
	if (l[41] <= 1000000)
	{
		l[42] = l[41];		
		l[41] /= 1000;
		DGLB( 0, l[41], 0x04, 0, );
		LABL( 0, 0, 0, 0x04, " Milliseconds, and " );
		l[41] *= 1000;
		l[42] -= l[41];
		DGLB( 0, l[42], 0x04, 0 );
		LABL( 0, 0, 0, 0x04, " Microseconds)" );

	}
	if (l[41] >= 1000000)
	{
		LABL( 0, 0, 0, 0x04, "~" );
		l[41] /= 1000000;
		DGLB( 0x40000000, l[41], 0x04, 0, );
		LABL( 0, 0, 0, 0x04, " Seconds)" );
		LABL 0 0 0 14;
	}
	802_11::Capability Information();
	802_11::Information_Element_Loop();
}

//--------------------------------------------------

void 802_11::Mgmt ATIM()
{
	LABL 0 0 0 b1 802.11 Management - ATIM\ATIM;
	LABL 0 1 0 c2 Announcement Traffic Indication Message:;
}

//--------------------------------------------------

void 802_11::Mgmt Disassociation()
{
	LABL 0 0 0 b1 802.11 Management;
	DWRD 40000000 1 b0 c2 Disassociation Reason Code:;
	CST# 0 1 0 14 802_11::Reason Code;
}

//--------------------------------------------------
	
void 802_11::Mgmt Authentication()
{
	LABL 0 0 0 b1 802.11 Management - Authentication;
*	Auth Algorithm in g1
	DWRD 40000000 1 90 c2 Auth Algorithm:;
	CST# ffffffff 1 0 14 802_11::Authentication Algorithm;
*	Auth Seq Num in g2
	DWRD 40000000 2 90 c2 Auth Seq Num:;
*	Status Code in g3
	DWRD 40000000 3 90 c2 Status Code:;
	TEQU 0 1 0 0 802_11::Mgmt Auth - Open System;
	TEQU 1 1 0 0 802_11::Mgmt Auth - Shared Key;

	TNXT -802_11::Information_Element_Loop;
}

//--------------------------------------------------

void 802_11::Mgmt Auth - Open System;
//	Note: g2=Auth Seq Num, g3=Status Code
	SNEQ 1 2;
	SKIP 3;
//	SN=1
	LABL 0 0 0 14 Reserved;
	802_11::Information_Element;
	TNXT -RETURN;
	
	SNEQ 2 2;
	SKIP 1;
//	SN=2
	CST# 0 3 0 14 802_11::Status Code;
	TNXT -RETURN;
//	Unknown sequence number - don't do anything

//--------------------------------------------------

void 802_11::Mgmt Auth - Shared Key;
*	Note: g2=Auth Seq Num, g3=Status Code
	SNEQ 1 2;
	SKIP 2;
*	SN=1
	LABL 0 0 0 14 Reserved;
	TNXT -RETURN;
	SNEQ 2 2;
	SKIP 3;
*	SN=2
	CST# 0 3 0 14 802_11::Status Code;
*   Challenge text
	802_11::Information_Element;
	TNXT -RETURN;
	SNEQ 3 2;
	SKIP 3;
*	SN=3
	LABL 0 0 0 14 Reserved;
*   Challenge text
	802_11::Information_Element;
	TNXT -RETURN;
*	SN=4
	SNEQ 4 2;
	SKIP 1;
	CST# 0 3 0 14 802_11::Status Code;
	TNXT -RETURN;
*	Unknown sequence number - don't do anything

//--------------------------------------------------

void 802_11::Mgmt Deauthentication;
	LABL 0 0 0 b1 802.11 Management - Deauthentication;
	DWRD 40000000 1 b0 c2 Deauthentication Reason Code:;
	CST# 0 1 0 14 802_11::Reason Code;
*   SSID data type unrestricted
*   supported rates each byte is a rate

//--------------------------------------------------

void 802_11::Mgmt_Action;
	LABL 0 0 00 b1 802.11 Management - Action;
	DBYT 0 1 90 c2 Category Code:;
	l[1] = g[1];
	ANDG 80 41;
	if (l[1] > 0)
	{
		ANDG 7f 1;
	}
		CEQU  0 1 00 14 Spectrum Management;
		CEQU  1 1 00 14 QoS;
		CEQU  2 1 00 14 DLS;
		CEQU  3 1 00 14 Block Ack;
		CEQU  4 1 00 14 Public Action;
		CEQU  5 1 00 14 Radio Measurement;
		CEQU  6 1 00 14 Fast BSS Transition (FT);
		CEQU  7 1 00 14 High Throughput (MIMO);
		CEQU  8 1 00 14 SA Query;
		CEQU  9 1 00 14 Protected Dual of Public Action;
		CEQU a 1 00 14 WNM;
		CEQU b 1 00 14 Unprotected WNM;
		CEQU c 1 00 14 TDLS;
		CEQU d 1 00 14 Mesh;							//802.11s as part of 802.11-2012
		CEQU e 1 00 14 Multihop;						//802.11s as part of 802.11-2012
		CEQU f 1 00 14 Self-protected;					//802.11s as part of 802.11-2012
		CEQU 10 1 00 14 DMG;							//TT32354
		CEQU 11 1 00 14 Management Notification;		//TT32354
		CEQU 12 1 00 14 Fast Session Transfer;			//TT32354
		CEQU 13 1 00 14 Robust AV Streaming;			//TT32354
		CEQU 14 1 00 14 Unprotected DMG;				//TT32354
		CEQU 15 1 00 14 VHT;							//TT32354
		CEQU 1e 1 00 14 MESH PEERING MGT;				//802.11s draft 
		CEQU 1f 1 00 14 MESH LINK METRIC;				//802.11s draft
		CEQU 20 1 00 14 MESH PATH SELECTION;			//802.11s draft
		CEQU 21 1 00 14 MESH INTERWORKING;			 	//802.11s draft
		CEQU 22 1 00 14 MESH RESOURCE COORDINATION;		//802.11s draft
		CEQU 23 1 00 14 MESH PROXY FORWARDING;			//802.11s draft
		CEQU 11 1 00 14 WMM;
		CEQU 7E 1 00 14 Vendor-specific Protected;
		CEQU 7F 1 00 14 Vendor-specific;
		//CLSE 0 0 0 14 Undecoded;
	if (l[1] > 0)
	{
		LABL 0 0 00 04 " - Error";
	}
	TST# 0 1 00 00 802_11::Mgmt_Action::CategoryCode::Func;
	
void 802_11::Mgmt_Action_No_Ack;
	LABL 0 0 00 b1 802.11 Management - Action No Ack;
	DBYT 0 1 90 c2 Category Code:;
	l[1] = g[1];
	ANDG 80 41;
	if (l[1] > 0)
	{
		ANDG 7f 1;
	}
	
	CEQU  0 1 00 14 Spectrum Management;
	CEQU  1 1 00 14 QoS;
	CEQU  2 1 00 14 DLS;
	CEQU  3 1 00 14 Block Ack;
	CEQU  4 1 00 14 Public Action;
	CEQU  5 1 00 14 Radio Measurement;
	CEQU  6 1 00 14 Fast BSS Transition (FT);
	CEQU  7 1 00 14 High Throughput (MIMO);
	CEQU  8 1 00 14 SA Query;
	CEQU  9 1 00 14 Protected Dual of Public Action;
	CEQU a 1 00 14 WNM;
	CEQU b 1 00 14 Unprotected WNM;
	CEQU c 1 00 14 TDLS;
	CEQU d 1 00 14 Mesh;							//802.11s as part of 802.11-2012
	CEQU e 1 00 14 Multihop;						//802.11s as part of 802.11-2012
	CEQU f 1 00 14 Self-protected;					//802.11s as part of 802.11-2012
	CEQU 10 1 00 14 DMG;							//TT32354
	CEQU 11 1 00 14 Management Notification;		//TT32354
	CEQU 12 1 00 14 Fast Session Transfer;			//TT32354
	CEQU 13 1 00 14 Robust AV Streaming;			//TT32354
	CEQU 14 1 00 14 Unprotected DMG;				//TT32354
	CEQU 15 1 00 14 VHT;							//TT32354
	CEQU 1e 1 00 14 MESH PEERING MGT;				//802.11s draft 
	CEQU 1f 1 00 14 MESH LINK METRIC;				//802.11s draft
	CEQU 20 1 00 14 MESH PATH SELECTION;			//802.11s draft
	CEQU 21 1 00 14 MESH INTERWORKING;			 	//802.11s draft
	CEQU 22 1 00 14 MESH RESOURCE COORDINATION;		//802.11s draft
	CEQU 23 1 00 14 MESH PROXY FORWARDING;			//802.11s draft
	CEQU 11 1 00 14 WMM;
	CEQU 7E 1 00 14 Vendor-specific Protected;
	CEQU 7F 1 00 14 Vendor-specific;
	//CLSE 0 0 0 14 Undecoded;
	if (l[1] > 0)
	{
		LABL 0 0 00 04 " - Error";
	}
	TST# 0 1 00 00 802_11::Mgmt_Action::CategoryCode::Func;
	
str# 802_11::Mgmt_Action::CategoryCode::Func;
	 0 | 802_11::Mgmt_Action::Spectrum;
	 1 | 802_11::Mgmt_Action::QoS;
	 2 | 802_11::Mgmt_Action::DLS;
	 3 | 802_11::Mgmt_Action::BlockAck;
	 4 | 802_11::Mgmt_Action::Public;
	 5 | 802_11::Mgmt_Action::Radio_Measurement;
	 6 | 802_11::Mgmt_Action::Fast_BSS_Transition;
	 7 | 802_11::Mgmt_Action::MIMO;
	 8 | 802_11::Mgmt_Action::SA_Query;
	 9 | 802_11::Mgmt_Action::Protected_Dual_of_Public_Action;
	10 | 802_11::Mgmt_Action::WNM;					//TT23184: 802.11v
	11 | 802_11::Mgmt_Action::Unprotected WNM;		//TT23184: 802.11v
	12 | 802_11::Mgmt_Action::TDLS;					//TT25521: 802.11z
	13 | 802_11::Mgmt_Action::MESH;							//802.11s as part of 802.11-2012
	//14 | 802_11::Mgmt_Action::MULTIHOP;						//802.11s as part of 802.11-2012
	15 | 802_11::Mgmt_Action::SELF_PROTECTED;					//802.11s as part of 802.11-2012
	17 | 802_11::Mgmt_Action::WMM;
	21 | 802_11::Mgmt_Action::VHTActionframe;
	//30 | 802_11::Mgmt_Action:MESH_PEERING_MGT;									//802.11s draft http://www.doc88.com/p-697306972309.html
	31 | 802_11::Mgmt_Action:MESH_LINK_METRIC;										//802.11s draft
	32 | 802_11::Mgmt_Action::MESH_PATH_SELECTION;									//802.11s draft
	33 | 802_11::Mgmt_Action::MESH_INTERWORKING;									//802.11s draft
	34 | 802_11::Mgmt_Action::MESH_RESOURCE_COORDINATION;							//802.11s draft
	35 | 802_11::Mgmt_Action::MESH_PROXY_FORWARDING;								//802.11s draft
	126	|	802_11::Mgmt_Action::IE_Type_221;
	127	|	802_11::Mgmt_Action::IE_Type_221;
//--------------------------
//--------------------------
void 802_11::Mgmt_Action::MESH()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::MESH::ActionCode );
		CLSE 0 0 0 14 Reserved;
	802_11::Information_Element_Loop;
}

str# 802_11::Mgmt_Action::MESH::ActionCode;
0	|	Mesh Link Metric Report;
1	|	HWMP Mesh Path Selection;
2	|	Gate Announcement;
3	|	Congestion Control Notification;
4	|	MCCA Setup Request;
5	|	MCCA Setup Reply;
6	|	MCCAOP Advertisement Request;
7	|	MCCAOP Advertisements;
8	|	MCCAOP Teardown;
9	|	TBTT Adjustment Request;
10	|	TBTT Adjustment Response;
8	|	Mesh Channel Switch Announcement;
//--------------------------
void 802_11::Mgmt_Action::MESH_PROXY_FORWARDING()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::MESH_PROXY_FORWARDING::ActionCode );
		CLSE 0 0 0 14 Reserved;
	TNXT -802_11::Information_Element_Loop;
}
str# 802_11::Mgmt_Action::MESH_PROXY_FORWARDING::ActionCode;
0	|	Proxy Update;
1	|	Proxy Update Confirmation;
//--------------------------
void 802_11::Mgmt_Action::MULTIHOP()
{
	
}
//--------------------------
void  802_11::Mgmt_Action::MESH_RESOURCE_COORDINATION()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::MESH_RESOURCE_COORDINATION::ActionCode );
		CLSE 0 0 0 14 Reserved;	
	TNXT -802_11::Information_Element_Loop;
}

str# 802_11::Mgmt_Action::MESH_RESOURCE_COORDINATION::ActionCode;
0	|	Congestion Control Notification;
1	|	MCCA Setup Request;
2	|	MCCA Setup Reply;
3	|	MCCAOP Advertisement Request;
4	|	MCCAOP Advertisements;
5	|	MCCAOP Reservation Teardown;
6	|	TBTT Adjustment Request;
7	|	TBTT Adjustment Response;
8	|	Mesh Channel Switch Announcement;
//--------------------------
void 802_11::Mgmt_Action::MESH_INTERWORKING()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::MESH_INTERWORKING::ActionCode );
		CLSE 0 0 0 14 Reserved;
	if (l[1] == 0)
	{
		TNXT -802_11::Information_Element_Loop;
	}
}

str# 802_11::Mgmt_Action::MESH_INTERWORKING::ActionCode;
0	|	Portal Announcement;

//--------------------------
/*
void 802_11::Mgmt_Action::MESH_PATH_SELECTION()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::MESH_PATH_SELECTION::ActionCode );
		CLSE 0 0 0 14 Reserved;
	if (l[1] == 1)
	{
		TNXT -802_11::Information_Element_Loop;
	}
}
str# 802_11::Mgmt_Action::MESH_PATH_SELECTION::ActionCode;
0	|	HWMP Mesh Path Selection;
*/
//--------------------------
void 802_11::Mgmt_Action:MESH_LINK_METRIC()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::MESH_LINK_METRIC::ActionCode );
		CLSE 0 0 0 14 Reserved;
	if (l[1] == 1)
	{
		TNXT -802_11::Information_Element_Loop;
	}
}

str# 802_11::Mgmt_Action::MESH_LINK_METRIC::ActionCode;
0	|	Mesh Link Metric Request;
1	|	Mesh Link Metric Report;
//--------------------------
void 802_11::Mgmt_Action::SELF_PROTECTED()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::SELF_PROTECTED::ActionCode );
		CLSE 0 0 0 14 Reserved;
		if (l[1] == 1)
		{
			TNXT -802_11::Information_Element_Loop;
		}
		if (l[1] == 2)
		{
			802_11::Capability Information;
			802_11::AID;
			TNXT -802_11::Information_Element_Loop;
		}
		if (l[1] == 3)
		{
			TNXT -802_11::Information_Element_Loop;
		}
		if (l[1] == 4)
		{
			TNXT -802_11::Information_Element_Loop;
		}
		if (l[1] == 5)
		{
			TNXT -802_11::Information_Element_Loop;
		}
}

str# 802_11::Mgmt_Action::SELF_PROTECTED::ActionCode;
0	|	Reserved;
1	|	Mesh Peering Open;
2	|	Mesh Peering Confirm;
3	|	Mesh Peering Close;
4	|	Mesh Group Key Inform;
5	|	Mesh Group Key Acknowledge;

//--------------------------
void 802_11::Mgmt_Action::MESH_PATH_SELECTION()
{
	//DGLB 0 2 90 c2 g2:;
	while ( g[16] > 0)
	{
		ETHR( 0, l[1], 0x90, 0xc2, "Adress:" );
		ETHR( 0, l[1], 0x90, 0xc2, "Adress:" );
		DBYT( 0, l[1], 0x90, 0xc2, "Counter:" );
		
		HEX#( 0, g[16], 0x90, 0xc2, "Padding Bytes:");
		g[2] -= 13;
		g[2] -= g[16];
	}
}
//--------------------------
void 802_11::Mgmt_Action::TDLS()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::TDLS::ActionCode );
	CLSE 0 0 00 14 Reserved;
	if (l[1] == 0)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		LABL 0 0 0 b1 TDLS Setup Request:;
		802_11::Capability Information;

		GBYT( 0, l[3] );
		if (l[3] == 0x01)
		{
			802_11::TDLS_IE_Supported_Rates;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x7f)
		{
			DBYT( 0, 0, 0x90, 0xc2, "Extended Capability:" );
			DBYT( 0, l[4], 0x90, 0xc2, "Length:" );
			802_11::TDLS_Extended_Capabilities;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x2e)
		{
			802_11::TDLS_QoS_Traffic_Capability;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x2d)
		{
			DBYT( 0, 0, 0x90, 0xc2, "HT Capabilities:" );
			DBYT( 0, 0, 0x90, 0xc2, "Length:" );
			802_11::IE_HT_Capability;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x65)
		{
			802_11::TDLS_Link_Identifier;
		}
	}
	if (l[1] == 1)
	{
		DWRD 40000000 1 90 c2 Status Code:;
		CST#		0 1 0 14 802_11::Status Code;
		DBYT 0 42 90 c2 Dialog Token:;
		LABL 0 0 0 b1 TDLS Setup Response:;
		802_11::Capability Information;

		GBYT( 0, l[3] );
		if (l[3] == 0x01)
		{
			802_11::TDLS_IE_Supported_Rates;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x32)
		{
			802_11::TDLS_IE_Supported_Rates;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x7f)
		{
			DBYT( 0, 0, 0x90, 0xc2, "Extended Capability:" );
			DBYT( 0, l[4], 0x90, 0xc2, "Length:" );
			802_11::TDLS_Extended_Capabilities;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x2e)
		{
			802_11::TDLS_QoS_Traffic_Capability;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x2d)
		{
			DBYT( 0, 0, 0x90, 0xc2, "HT Capabilities:" );
			DBYT( 0, 0, 0x90, 0xc2, "Length:" );
			802_11::IE_HT_Capability;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x48)
		{
			802_11::TDLS_20_40_BSS_Coexistence;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x65)
		{
			802_11::TDLS_Link_Identifier;
		}
	}
	if (l[1] == 2)
	{
		DWRD 40000000 1 90 c2 Status Code:;
		CST#		0 1 0 14 802_11::Status Code;
		DBYT 0 42 90 c2 Dialog Token:;
		LABL 0 0 0 b1 TDLS Setup Confirm:;

		GBYT( 0, l[3] );
		if (l[3] == 0x3d)
		{
			DBYT( 0, 0, 0x90, 0xc2, "HT Information:" );
			DBYT( 0, 0, 0x90, 0xc2, "Length:" );
			802_11::IE_Additional_HT;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x65)
		{
			802_11::TDLS_Link_Identifier;
		}
	}
	if (l[1] == 3)
	{
		DWRD 40000000 1 90 c2 Reason Code:;
		CST#		0 1 0 14 802_11::Reason Code;
		802_11::Fast_BSS_transition;
		802_11::Link_Identifier;
	}
	if (l[1] == 4)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		802_11::Link_Identifier;
		802_11::PTI_Control;
		802_11::TPU_Buffer_Status;
	}
	if (l[1] == 5)
	{
		DBYT 0 42 90 c2 Target Channel:;
		DBYT 0 42 90 c2 Operating Class:;
		802_11N::IE_Secondary_Channel_Offset;
		802_11::Link_Identifier;
		802_11::Channel_Switch_Timing;
	}
	if (l[1] == 6)
	{
		DWRD 40000000 1 90 c2 Status Code:;
		CST#		0 1 0 14 802_11::Status Code;
		802_11::Link_Identifier;
		802_11::Channel_Switch_Timing;
	}
	if (l[1] == 7)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		802_11::Link_Identifier;
		802_11::Wakeup_Schedule;
	}
	if (l[1] == 8)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		DWRD 40000000 1 90 c2 Status Code:;
		CST#		0 1 0 14 802_11::Status Code;
		802_11::Link_Identifier;
		802_11::Wakeup_Schedule;
	}
	if (l[1] == 9)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		802_11::Link_Identifier;
	}
	if (l[1] == 10)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		802_11::TDLS_Link_Identifier;
	}
	802_11::Information_Element_Loop;
}

str# 802_11::Mgmt_Action::TDLS::ActionCode;
0	|  TDLS Setup Request;
1	|  TDLS Setup Response;
2	|  TDLS Setup Confirm;
3	|  TDLS Teardown;
4	|  TDLS Peer Traffic Indication;
5	|  TDLS Channel Switch Request;
6	|  TDLS Channel Switch Response;
7	|  TDLS Peer PSM Request;
8	|  TDLS Peer PSM Response;
9	|  TDLS Peer Traffic Response;
10	|  TDLS Discovery Request;

//--------------------------
void 802_11::Mgmt_Action::IE_Type_221()
{
	LABL 0 0 0 b7 Vendor Specific;
	l[1] = pl[0];
	ANDG ffffff00 41;
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Subtype:;
	DBYT 0 42 90 c2 P2P Action Subtype:;
		CST# 0 42 0 14 802_11::Mgmt_Action::IE_Type_221::P2P Action Subtype;
	DBYT 0 43 90 c2 P2P Action Dialog Token:;
	LABL 0 0 0 b8;
	802_11::Information_Element_Loop;
}

str# 802_11::Mgmt_Action::IE_Type_221::P2P Action Subtype;
 0	|	P2P_ACT_NOA, Notice of Absence;
 1	|	P2P_ACT_P2P_PRESENCE_REQ, P2P Presence Request;
 2	|	P2P_ACT_P2P_PRESENCE_RESP, P2P Presence Response;
 3	|	P2P_ACT_GO_DISC_REQ, GO Discoverability Request;

//--------------------------
void 802_11::Mgmt_Action::SA_Query()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CEQU( 0, l[1], 0, 0x14, "SA Query Request" );
		CEQU( 1, l[1], 0, 0x14, "SA Query Response" );
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "Transaction Identifier:" );
	802_11::Information_Element_Loop;
}
//--------------------------
void 802_11::Mgmt_Action::Fast_BSS_Transition()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::Fast_BSS_Transition::ActionCode );
		CLSE 0 0 00 14 Reserved;
	if (l[1] == 1)
	{
		ETHR( 0, l[2], 0x90, 0xc2, "STA Address:" );
		ETHR( 0, l[3], 0x90, 0xc2, "Target AP Address:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 2)
	{
		ETHR( 0, l[2], 0x90, 0xc2, "STA Address:" );
		ETHR( 0, l[3], 0x90, 0xc2, "Target AP Address:" );
		DBYT( 0, l[4], 0x90, 0xc2, "Status Code:" );
		CST#( 0, l[4], 0, 0x14, 802_11::Status Code );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 3)
	{
		ETHR( 0, l[2], 0x90, 0xc2, "STA Address:" );
		ETHR( 0, l[3], 0x90, 0xc2, "Target AP Address:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 4)
	{
		ETHR( 0, l[2], 0x90, 0xc2, "STA Address:" );
		ETHR( 0, l[3], 0x90, 0xc2, "Target AP Address:" );
		DBYT( 0, l[4], 0x90, 0xc2, "Status Code:" );
		CST#( 0, l[4], 0, 0x14, 802_11::Status Code );
		TNXT -802_11::Information_Element_Loop;
	}
}

str# 802_11::Mgmt_Action::Fast_BSS_Transition::ActionCode;
1	|	FT Request frames;
2	|	FT Response frames;
3	|	FT Confirm frames;
4	|	FT Ack frames;
//--------------------------
void 802_11::Mgmt_Action::Radio_Measurement()
{
	DBYT 0 41 90 c2 Action Code:;
		CST# 0 41 00 14 802_11::Mgmt_Action::Radio_Measurement::ActionCode;
		CLSE 0 0 00 14 Reserved;
	if (l[1] == 0)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		DWRD 0 43 90 c2 Number of Repetitions:;
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 1)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 2)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		DBYT 0 43 90 c2 Transmit Power Used:;
		DBYT 0 44 90 c2 Max Transmit Power:;
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 3)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		DLNG 0 43 90 c2 TPC Report element:;
		DBYT 0 44 90 c2 Recieve Antenna ID:;
		DBYT 0 45 90 c2 Transmit Antenna ID:;
		DBYT 0 46 90 c2 RCPI:;
		DBYT 0 47 90 c2 RSNI:;
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 4)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		802_11::Information_Element_Loop;
	}
	if (l[1] == 5)
	{
		DBYT 0 42 90 c2 Dialog Token:;
		TNXT -802_11::Information_Element_Loop;
	}
}

void 802_11::Mgmt_Action::Spectrum()
{
	DBYT 0 1 90 c2 Action Code:;
	CST# 0 1 00 14 802_11::Mgmt_Action::Spectrum::ActionCode;
	if (g[1] <= 3)
	{
		DBYT 0 0 90 c2 Dialog Token:;
	}
	TNXT -802_11::Information_Element_Loop;
}

str# 802_11::Mgmt_Action::Radio_Measurement::ActionCode;
0	|	Radio Measurement Request;
1	|	Radio Measurement Report;
2	|	Link Measurement Request;
3	|	Link Measurement Report;
4	|	Neighbor Report Request;
5	|	Neighbor Report Response;

str# 802_11::Mgmt_Action::Spectrum::ActionCode;
0 	| 	Measurement Request;
1 	| 	Measurement Report;
2 	|	TPC Request;
3 	| 	TPC Report;
4 	| 	Channel Switch Announcement;
5 	|	Extended Channel Switch Announcement;

//--------------------------

void 802_11::Mgmt_Action::QoS()
{
	DBYT 0 41 90 c2 Action Code:;
		CST# 0 41 00 00 802_11::Mgmt_Action::QoS::ActionCode;
		CLSE 0 0 00 00 Reserved;
	if (l[1] == 0)
	{
		// ADDTS Request
		DBYT 0 0 90 c2 Dialog Token:;
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 1)
	{
		// ADDTS Response
		DBYT 0 00 90 c2 Dialog Token:;
		DBYT 0 1 90 b9 Status Code:;
		CST# 0 1 00 14 802_11::Mgmt_Action::Action_Status_Code;
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 2)
	{
		// DELTS
		802_11::IE_Type_13::TS_Info;
		DWRD 40000000 1 90 c2 Reason Code:;
		CST#		0 1 00 14 802_11::Reason Code;
		TRTS;
	}
	if (l[1] == 3)
	{
		// Schedule
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 4)
	{
		// QoS Map Set
		TNXT -802_11::Information_Element_Loop;
	}
	TNXT -802_11::Information_Element_Loop;	
}

str# 802_11::Mgmt_Action::QoS::ActionCode;
	0 | ADDTS Request;
	1 | ADDTS Response;
	2 | DELTS;
	3 | Schedule;
	4 |	QoS Map Configure;

//--------------------------

void 802_11::Mgmt_Action::DLS()
{
	DBYT 0 41 90 c2 Action Code:;
	CST# 0 41 00 14 802_11::Mgmt_Action::DLS::ActionCode;
	CLSE 0 00 00 14 Reserved;
	if (l[1] == 0)
	{
		// DLS Request
		ETHR 0 0 90 c2 Dest MAC Addr:;
		ETHR 0 0 90 c2 Src MAC Addr:;
		802_11::Capability Information();
		DWRD 40000000 0 90 c2 Timeout:;
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 1)
	{
		// DLS Response
		DWRD 40000000 1 90 c2 Status Code:;
		CST# 0 1 00 14 802_11::Status Code;
		ETHR 0 0 90 c2 Dest MAC Addr:;
		ETHR 0 0 90 c2 Src MAC Addr:;
		802_11::Capability Information();
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 2)
	{
		// DLS Teardown
		ETHR 0 0 90 c2 Dest MAC Addr:;
		ETHR 0 0 90 c2 Src MAC Addr:;
		DWRD 40000000 1 90 c2 Reason Code:;
		CST# 0 1 00 14 802_11::Reason Code;
		TRTS;
	}
	TRTS;
}

str# 802_11::Mgmt_Action::DLS::ActionCode;
	0 | DLS Request;
	1 | DLS Response;
	2 | DLS Teardown;

//--------------------------

void 802_11::Mgmt_Action::BlockAck()
{
	DBYT 0 41 90 c2 Action Code:;
	CST# 0 41 00 14 802_11::Mgmt_Action::BlockAck::ActionCode;
	CLSE 0 00 00 14 Reserved;
	if (l[1] == 0)
	{
		// ADDBA Request
		DBYT 0 00 90 c2 Dialog Token:;
		802_11::Mgmt_Action::BlockAck::BlockAckParamSet;
		DWRD 40000000 0 90 c2 BlockAck Timeout Value:;
		LABL 0 0 00 14 TUs;
		802_11::Control::Block::Sequence;

		GBYT( 0, l[8] );
		if (l[8] == 221)
		{
			802_11::Mgmt_Action::BlockAck::VendorTag;
		}

		TRTS;
	}
	if (l[1] == 1)
	{
		// ADDBA Response
		DBYT 0 00 90 c2 Dialog Token:;
		DWRD 40000000 1 90 c2 Status Code:;
		CST# 0 1 00 14 802_11::Status Code;
		802_11::Mgmt_Action::BlockAck::BlockAckParamSet;
		DWRD 40000000 0 90 c2 BlockAck Timeout Value:;
		LABL 0 0 00 14 TUs;
		TRTS;
	}
	if (l[1] == 2)
	{
		// DELBA
		BWRD 40000000 1 90 c9 DELBA Param Set:;
		l[1] = g[1];
		ANDG f000 41;
		SHFR c 41;
		CST# 0 41 00 d4 802_11::Mgmt_Action::BlockAck::DELBA_TID;
		CLSE 0 0 00 d4 0000.... ........ TID: 0;
		CBIT b 1 00 d4 ....1... ........ Initiator: Originator;
		CLSE 0 0 00 d4 ....0... ........ Initiator: Recipient;
		LABL 0 0 00 d4 .....xxx xxxxxxxx Reserved;
		LABL 0 0 00 c8;
		DWRD 40000000 1 90 c2 Reason Code:;
		CST# 0 1 00 14 802_11::Reason Code;
		TRTS;
	}
	TRTS;
}

str# 802_11::Mgmt_Action::BlockAck::ActionCode;
	0 |  ADDBA Request;
	1 |  ADDBA Response;
	2 |  DELBA;

void 802_11::Mgmt_Action::BlockAck::BlockAckParamSet()
{
	BWRD 40000000 1 90 c9 BlockAck Param Set:;
	l[2] = g[1];
	ANDG ffc0 42;
	SHFR 6 42;
	DECR 2;
	BBIT 5000000a 0 94 d4 ;
	/*l[3] = 10;
	l[4] = g[1];
	while (l[3] != 0)
	{
		SHFR( l[2], l[4] );
	}*/
	DGLB 0 42 a4 04 ...... Buffer Size: ;
	LABL( 0, 0, 0, 0x04, " (" );
	l[2] *= 2304;
	DGLB 0 42 a4 04  ;
	LABL( 0, 0, 0, 0x04, " Bytes) ");
	BBIT 6 0 5 5 Hiddenbitconsuming;
	l[1] = g[1];
	ANDG 3c 41;
	SHFR 2 41;
	CST# 0 41 00 d4 802_11::Mgmt_Action::BlockAck::BlockAckParamSet::TID;
	CLSE 0 0 00 d4 ........ ..0000.. TID: 0;
	CBIT 1 1 00 d4 ........ ......1. BlockAck Policy: Immediate Block Ack;
	CLSE 0 0 00 d4 ........ ......0. BlockAck Policy: Delayed Block Ack;
	CBIT 0 1 00 d4 ........ .......1 A-MSDU: Permitted;
	CLSE 0 0 00 d4 ........ .......0 A-MSDU: Not Permitted;
	LABL 0 0 00 c8;
	TRTS;
}

void 802_11::Mgmt_Action::BlockAck::VendorTag()
{
	LABL 0 0 0 b1 Vendor Specific;

	GLNG( 2, l[7] );
	ANDG ffffff00 47;

	DBYT( 0, l[1], 0x90, 0xc2, "Tag Number:");
	DBYT( 0, l[2], 0x90, 0xc2, "Tag Length:");

	802_11::Print_OUI();
	l[2] -= 3;

	if (l[7] == 0x00409600)
	{
		LABL 0 0 0 04 "  Cisco Aironet";
	}

	DBYT( 0, l[3], 0x90, 0xc2, "OUI Type:");
	l[2] -= 1;

	if (l[7] == 0x00409600)
	{
		LABL 0 0 0 04 "  Aironet";
	}

	if (l[2] > 0)
	{
		DUMP( 0, l[2], 0x90, 0xc2, "IE Data:");
	}

	LABL 0 0 00 c8;
	TRTS;
}

str# 802_11::Mgmt_Action::BlockAck::BlockAckParamSet::TID;
	........ ..0001.. TID: 1;
	........ ..0010.. TID: 2;
	........ ..0011.. TID: 3;
	........ ..0100.. TID: 4;
	........ ..0101.. TID: 5;
	........ ..0110.. TID: 6;
	........ ..0111.. TID: 7;
	........ ..1000.. TID: 8;
	........ ..1001.. TID: 9;
	........ ..1010.. TID: 10;
	........ ..1011.. TID: 11;
	........ ..1100.. TID: 12;
	........ ..1101.. TID: 13;
	........ ..1110.. TID: 14;
	........ ..1111.. TID: 15;

str# 802_11::Mgmt_Action::BlockAck::DELBA_TID;
	0001.... ........ TID: 1;
	0010.... ........ TID: 2;
	0011.... ........ TID: 3;
	0100.... ........ TID: 4;
	0101.... ........ TID: 5;
	0110.... ........ TID: 6;
	0111.... ........ TID: 7;
	1000.... ........ TID: 8;
	1001.... ........ TID: 9;
	1010.... ........ TID: 10;
	1011.... ........ TID: 11;
	1100.... ........ TID: 12;
	1101.... ........ TID: 13;
	1110.... ........ TID: 14;
	1111.... ........ TID: 15;
//--------------------------

void 802_11::Mgmt_Action::Protected_Dual_of_Public_Action()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		
	802_11::Information_Element_Loop;
}
//--------------------------

void 802_11::Mgmt_Action::Public()
{
	DBYT 0 1 90 c2 Action Code:;
		CST# 0 1 00 14 802_11::Mgmt_Action::Public_Action_Field_Str;
	CLSE 0 1 00 14 Reserved;
	TSB# 0 1 00 00 802_11::Mgmt_Action::Public_Action_Field;
}

str# 802_11::Mgmt_Action::Public_Action_Field_Str;
	0	|	20/40 BSS Coexistence Management;
	1	|	DSE enablement;
	2	|	DSE deenablement;
	3	|	DSE Registered Location Announcement;
	4	|	Extended Channel Switch Announcement;
	5	|	DSE measurement request;
	6	|	DSE measurement report;
	7	|	Measurement Pilot;
	8	|	DSE power constraint;
	9	|	Vendor Specific;
	10	|	GAS Initial Request;
	11	|	GAS Initial Response;
	12	|	GAS Comeback Request;
	13	|	GAS Comeback Response;
	14	|	TDLS Discovery Response;
	15	|	Location Track Notification;
	
str# 802_11::Mgmt_Action::Public_Action_Field;
	0 | 802_11::20_40_BSS_Coexistence_Management;
	7 | 802_11::Mgmt_Action::Measurement Pilot;
	9 | 802_11::Mgmt_Action::Public::VendorSpecific;
	10	|	802_11::Mgmt_Action::Public::GAS Initial Request;			*802.11u
	11	|	802_11::Mgmt_Action::Public::GAS Initial Response;			*802.11u
	12	|	802_11::Mgmt_Action::Public::GAS Comeback Request;			*802.11u
	13	|	802_11::Mgmt_Action::Public::GAS Comeback Response;			*802.11u
	14	|	802_11::Mgmt_Action::Public::TDLS Discovery Response;		*802.11z
	15	|	802_11::Mgmt_Action::Public::Location_Track_Notification;


void 802_11::Mgmt_Action::Public::TDLS Discovery Response()
{
	LABL( 0, 0, 0x90, 0xc9, "TDLS Discovery Response:" );
	
		DBYT 0 42 90 c2 Dialog Token:;
		802_11::Capability Information;

		GBYT( 0, l[3] );
		if (l[3] == 0x01)
		{
			802_11::TDLS_IE_Supported_Rates;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x32)
		{
			802_11::TDLS_IE_Supported_Rates;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x7f)
		{
			DBYT( 0, 0, 0x90, 0xc2, "Extended Capability:" );
			DBYT( 0, l[4], 0x90, 0xc2, "Length:" );
			802_11::TDLS_Extended_Capabilities;
		}

		GBYT( 0, l[3] );
		if (l[3] == 0x65)
		{
			802_11::TDLS_Link_Identifier;
		}
}

void 802_11::Mgmt_Action::Public::GAS Initial Request()
{
	LABL( 0, 0, 0x90, 0xc7, "GAS Initial Request:" );
	DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
	DBYT( 0, l[3], 0x90, 0xc2, "Advertisement Protocol Element ID:" );
	DBYT( 0, l[4], 0x90, 0xc2, "Advertisement Protocol Element Length:" );		g[2] = l[4];
	l[2] = 1;
	while (l[4] != 0)
	{
		
		DBIT( 1, l[3], 0x90, 0xc9, "Query Response Info:" );
			CBIT( 0, l[3], 0x90, 0xd4, ".... ...1 PAME-BI: the Query Response is independent of the BSSID" );
			CLSE( 0, l[3], 0x90, 0xd4, ".... ...0 PAME-BI: the Query Response may be dependent on the BSSID" );
		LABL 0 0 0 c8;
		DBIT( 7, l[3], 0x90, 0xc2, "Query Response Length Limit:" );
		DBYT( 0, l[6], 0x90, 0xc2, "Advertisement Protocol ID:" );
		g[2] -= 2;
		l[4] -= 2;
		LABL 0 0 0 c8;
	}
	if (g[16] >= 4)
	{
		LABL( 0, 0, 0x90, 0xc7, "Query Request:" );
		DWRD( 0x40000000, l[5], 0x90, 0xc2, "Query Response length:" );
		while(l[5] > 0)
		{
			GWRD( 0x40000000 , l[11] );
			CST#( 0, l[11], 0x90, 0xc7, 802_11::ANQP_information_ID );
			HWRD( 0x40000000, l[11], 0x90, 0xc2, "Info ID:" );
			CST#( 0, l[11], 0, 0x14, 802_11::ANQP_information_ID );
			DWRD( 0x40000000, l[12], 0x90, 0xc2, "Length:" );
			g[2] = l[12];
			l[5] -= 4; //g[2] -= 4;
			l[5] -= l[12];
			
			TSB#( 0, l[11], 0, 0, 802_11::ANQP_information_ID_Ldr );
			LABL 0 0 0 c8;
		}
		LABL 0 0 0 c8;	
	}
	LABL 0 0 0 c8;
}

void 802_11::Mgmt_Action::Public::GAS Initial Response()
{
	LABL( 0, 0, 0x90, 0xc7, "GAS Initial Response:" );
	DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
	DWRD( 0, l[2], 0x90, 0xc2, "Status Code:" );
	DWRD( 0x40000000, l[5], 0x90, 0xc2, "GAS Comeback Delay:" );
	DBYT( 0, l[3], 0x90, 0xc2, "Advertisement Protocol Element ID:" );
	DBYT( 0, l[4], 0x90, 0xc2, "Advertisement Protocol Element Length:" );		g[2] = l[4];
	while (l[4] != 0)
	{		
		DBIT( 1, l[3], 0x90, 0xc9, "Query Response Info:" );
			CBIT( 0, l[3], 0x90, 0xd4, ".... ...1 PAME-BI: the Query Response is independent of the BSSID" );
			CLSE( 0, l[3], 0x90, 0xd4, ".... ...0 PAME-BI: the Query Response may be dependent on the BSSID" );
		LABL 0 0 0 c8;
		DBIT( 7, l[3], 0x90, 0xc2, "Query Response Length Limit:" );
		DBYT( 0, l[6], 0x90, 0xc2, "Advertisement Protocol ID:" );
		g[2] -= 2;
		l[4] -= 2;
		LABL 0 0 0 c8;
	}
	if (g[16] >= 4)
	{
		LABL( 0, 0, 0x90, 0xc7, "Query Response:" );
		DWRD( 0x40000000, l[5], 0x90, 0xc2, "Query Response length:" );
		while(l[5] > 0)
		{
			GWRD( 0x40000000 , l[11] );
			CST#( 0, l[11], 0x90, 0xc9, 802_11::ANQP_information_ID );
			HWRD( 0x40000000, l[11], 0x90, 0xc2, "Info ID:" );
			CST#( 0, l[11], 0, 0x14, 802_11::ANQP_information_ID );
			DWRD( 0x40000000, l[12], 0x90, 0xc2, "Length:" );
			g[2] = l[12];
			l[5] -= l[12];
			l[5] -= 4;
			TSB#( 0, l[11], 0, 0, 802_11::ANQP_information_ID_Ldr );
			LABL 0 0 0 c8;
		}
		LABL 0 0 0 c8;	
	}
	LABL 0 0 0 c8;
}

void 802_11::Mgmt_Action::Public::GAS Comeback Request()
{
	LABL( 0, 0, 0x90, 0xc7, "GAS Comeback Request:" );
	DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
	LABL 0 0 0 c8;
}

void 802_11::Mgmt_Action::Public::GAS Comeback Response()
{
	LABL( 0, 0, 0x90, 0xc7, "GAS Comeback Response:" );
	DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
	802_11::NOIE::GAS Query Response Fragment ID;
	DECR 1;
	DWRD( 0x40000000, l[5], 0x90, 0xc2, "GAS Comeback Delay:" );
	DBYT( 0, l[3], 0x90, 0xc2, "Advertisement Protocol Element ID:" );
	DBYT( 0, l[4], 0x90, 0xc2, "Advertisement Protocol Element Length:" );		g[2] = l[4];
	802_11::IE_Type_108;
	DWRD( 0x40000000, l[5], 0x90, 0xc2, "Query Response length:" );
	if (l[5] != 0)
	{
		CHR#( 0, l[5], 0x90, 0xc2, "Query Response:" );
	}
	LABL 0 0 0 c8;
}

void 802_11::NOIE::GAS Query Response Fragment ID()
{
	BBIT( 1, l[2], 0x90, 0xc2, "More GAS Fragments:" );
	BBIT( 7, l[2], 0x90, 0xc2, "GAS Query Response Fragment ID:" ); 
}


void 802_11::Mgmt_Action::Public::Location_Track_Notification()
{
	LABL 0 0 90 c9 Location Track Notification;
	while (g[16] >= 2)
		{
			DBYT( 0, l[2], 0x90, 0xc7, "Subelement ID:" );	g[2] -= 1;
				CST#( 0, l[2], 0, 0x07, 802_11::Mgmt_Action::Public::Location_Track_Notification::Subelements );
				CLSE( 0, 0, 0, 0x07, "Reserved" );
			DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
				TSB#( 0, l[2], 0, 0x14, 802_11::Mgmt_Action::Public::Location_Track_Notification::Subelements::Call );
				TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
			LABL 0 0 0 c8;
		}
	802_11::Information_Element_Loop;
	LABL 0 0 0 c8;
}
*same to str# 802_11::Location_Parameters::Subelements
str# 802_11::Mgmt_Action::Public::Location_Track_Notification::Subelements;			
1	|	Location Indication Parameters;
2	|	Location Indication Channels;
3	|	Location Status;
4	|	Radio Information;
5	|	Motion;
6	|	Location Indication Broadcast Data Rate;
7	|	Time Of Departure;
8	|	Location Indication Options;
221	|	Vendor Specific;
*same to  str# 802_11::Location_Parameters::Subelements::Call
str# 802_11::Mgmt_Action::Public::Location_Track_Notification::Subelements::Call; 		
1	|	802_11::Location_Parameters::Location_Indication_Parameters;
2	|	802_11::Location_Parameters::Location_Indication_Channels;
3	|	802_11::Location_Parameters::Location_Status;
4	|	802_11::Location_Parameters::Radio_Information;
5	|	802_11::Location_Parameters::Motion;
6	|	802_11::Location_Parameters::Location_Indication_Broadcast_Data_Rate;
7	|	802_11::Location_Parameters::Time_Of_Departure;
8	|	802_11::Location_Parameters::Location_Indication_Options;
221	|	802_11::IE_Type_221;

void 802_11::20_40_BSS_Coexistence_Management()
{
	LABL 0 0 90 c9 20/40 BSS Coexistence Management;
	802_11::Information_Element_Loop;
	LABL 0 0 0 c8;
}

void 802_11::Mgmt_Action::Public::VendorSpecific()
{
	l[1] = pl[0];
	ANDG ffffff00 41;
	TSB# 0 41 0 0 802_11::VendorSpecificActionFuncs; 
}

void 802_11::Mgmt_Action::Measurement Pilot()
{
	BBYT 0 1 90 c9 Condensed Capability Information:;
	DECR 1;
	BBIT( 6, 0, 0x90, 0xc2, "Reserved" );
	BBIT( 1, 0, 0x90, 0xc2, "Short Slot Time" );
	BBIT( 1, 0, 0x90, 0xc2, "Spectrum Management" );
	LABL( 0, 0, 0, 0xb8 );
	HWRD( 0, 0, 0x90, 0xc2, "Condensed Country String:" );
	DBYT( 0, 0, 0x90, 0xc2, "Regulatory Class:" );
	DBYT( 0, 0, 0x90, 0xc2, "Channel:" );
	802_11::Mgmt_Action::Measurement Pilot Interval;
	802_11::Information_Element_Loop();
}

void 802_11::Mgmt_Action::Measurement Pilot Interval()
{
	DBYT( 0, 0, 0x90, 0xc2, "Measurement Pilot Interval:" );
	TRTS;
}

void 802_11::Mgmt_Action::MIMO()
{
	DBYT 0 1 90 c2 HT Action Field:;
	 CST# 0 1 00 14 802_11::Mgmt_Action::HT_Action_Field_Str;
		CLSE 0 0 00 14 Reserved;
	 TSB# 0 1 00 00 802_11::Mgmt_Action::HT_Action_Field;
}

str# 802_11::Mgmt_Action::HT_Action_Field_Str;
	0	| Notify Channel Width;
	1	| SM Power Save;
	2	| PSMP Action Frame;
	3	| Set PCO Phase;
	4	| MIMO CSI Matrices;
	5	| MIMO Non-compressed Beamforming;
	6	| MIMO Compressed Beamforming;
	7	| Antenna Selection Indices Feedback;	

str# 802_11::Mgmt_Action::HT_Action_Field;
	0	| 802_11::Mgmt_Action::Channel_Width;
	1	| 802_11::Mgmt_Action::SM_Power_Save;
	2	| 802_11::Mgmt_Action::PSMP_Action;
	3	| 802_11::Mgmt_Action::PCO_Phase;
	4	| 802_11::Mgmt_Action::MIMO_Control_Field;
	5	| 802_11::Mgmt_Action::MIMO_Control_Field;
	6	| 802_11::Mgmt_Action::MIMO_Control_Field;
	7	| 802_11::Mgmt_Action::Antenna_Selection;
	8	| 802_11::Mgmt_Action::HT_Information_Exchange;
	21	| 802_11::Mgmt_Action::VHTActionframe;

void 802_11::Mgmt_Action::Channel_Width()
{
	HBYT 0 1 90 c2 Channel Width:;
	 CEQU 0 1 00 14 20MHz Primary Channel;
	 CEQU 1 1 00 14 Any Channel Width Enabled;
}

void 802_11::Mgmt_Action::SM_Power_Save()
{
	HBYT 0 1 90 c9 SM Power Save Control:;
	LABL 0 0 00 d4 xxxx xx.. Reserved;
	CBIT 1 1 00 d4 .... ..1. SM Mode: Dynamic;
	CLSE 0 0 00 d4 .... ..0. SM Mode: Static;
	CBIT 0 1 00 d4 .... ...1 SM Power Save: Enable;
	CLSE 0 0 00 d4 .... ...0 SM Power Save: Disable;
	LABL 0 0 00 c8;
}

void 802_11::Mgmt_Action::PSMP_Action()
{
	HWRD 40000000 1 90 c9 SM PSMP Parameter Set:;
	l[1] = g[1];
	ANDG FFC0 41;
	SHFR 6 41;
	DGLB 0 41 00 d4 ---- ---- --.. .... PSMP Sequence Duration: ;
	CBIT 5 01 00 d4 .... .... ..1. .... More PSMP: Another PSMP Sequence;
	CLSE 0 00 00 d4 .... .... ..0. .... More PSMP: No PSMP Sequence;
	l[1] = g[1];
	ANDG 1F 41;
	DGLB 0 41 00 d4 .... .... ...- ---- Number of STA Info fields: ;
	LABL 0 0 00 c8;
}

void 802_11::Mgmt_Action::PCO_Phase()
{
	HBYT 0 1 90 c2 PCO Phase Control:;
	 CEQU 0 1 00 14 20MHz Phase;
	 CEQU 1 1 00 14 40MHz Phase;
}

void 802_11::Mgmt_Action::MIMO_Control_Field()
{
	HWRD 40000000 1 90 c9 MIMO Control Field:;
	LABL 0 00 00 d4 xx.. .... .... .... Reserved;
	l[1] = g[1];
	ANDG 3800 41;
	SHFR b 41;
	 CEQU 7 41 00 d4 ..11 1... .... .... Remaining Matrix Segment: 7;
	 CEQU 6 41 00 d4 ..11 0... .... .... Remaining Matrix Segment: 6;
	 CEQU 5 41 00 d4 ..10 1... .... .... Remaining Matrix Segment: 5;
	 CEQU 4 41 00 d4 ..10 0... .... .... Remaining Matrix Segment: 4;
	 CEQU 3 41 00 d4 ..01 1... .... .... Remaining Matrix Segment: 3;
	 CEQU 2 41 00 d4 ..01 0... .... .... Remaining Matrix Segment: 2;
	 CEQU 1 41 00 d4 ..00 1... .... .... Remaining Matrix Segment: 1;
	 CEQU 0 41 00 d4 ..00 0... .... .... Remaining Matrix Segment: 0;
	l[1] = g[1];
	ANDG 600 41;
	SHFR 9 41; 
	 CEQU 3 41 00 d4 .... .11. .... .... Codebook Information: 4 bits for psi, 6 bits for phi;
	 CEQU 2 41 00 d4 .... .10. .... .... Codebook Information: 3 bits for psi, 5 bits for phi;
	 CEQU 1 41 00 d4 .... .01. .... .... Codebook Information: 2 bits for psi, 4 bits for phi;
	 CEQU 0 41 00 d4 .... .00. .... .... Codebook Information: 1 bit for psi, 3 bits for phi;
	l[1] = g[1];
	ANDG 180 41;
	SHFR 7 41;
	 CEQU 3 41 00 d4 .... ...1 1... .... Coefficient Size: Nb=8;
	 CEQU 2 41 00 d4 .... ...1 0... .... Coefficient Size: Nb=6;
	 CEQU 1 41 00 d4 .... ...0 1... .... Coefficient Size: Nb=5;
	 CEQU 0 41 00 d4 .... ...0 0... .... Coefficient Size: Nb=4;
	l[1] = g[1];
	ANDG 60 41;
	SHFR 5 41; 
	 CEQU 3 41 00 d4 .... .... .xx. .... Grouping (Ng): Reserved;
	 CEQU 2 41 00 d4 .... .... .10. .... Grouping (Ng): 4;
	 CEQU 1 41 00 d4 .... .... .01. .... Grouping (Ng): 2;
	 CEQU 0 41 00 d4 .... .... .00. .... Grouping (Ng): 1 (No grouping);
	 
	 CBIT 4 01 00 d4 .... .... ...1 .... Channel Width: 40MHz;
	 CLSE 0 01 00 d4 .... .... ...0 .... Channel Width: 20MHz;
	l[1] = g[1];
	ANDG C 41;
	SHFR 2 41; 
	 CEQU 3 41 00 d4 .... .... .... 11.. Nr Index: 4 Rows in Matrix;
	 CEQU 2 41 00 d4 .... .... .... 10.. Nr Index: 3 Rows in Matrix;
	 CEQU 1 41 00 d4 .... .... .... 01.. Nr Index: 2 Rows in Matrix;
	 CEQU 0 41 00 d4 .... .... .... 00.. Nr Index: 1 Row in Matrix;
	l[1] = g[1];
	ANDG 3 41;
	 CEQU 3 41 00 d4 .... .... .... ..11 Nc Index: 4 Columns in Matrix;
	 CEQU 2 41 00 d4 .... .... .... ..10 Nc Index: 3 Columns in Matrix;
	 CEQU 1 41 00 d4 .... .... .... ..01 Nc Index: 2 Columns in Matrix;
	 CEQU 0 41 00 d4 .... .... .... ..00 Nc Index: 1 Column in Matrix;
	LABL 0 0 00 c8;
	HLNG 40000000 1 90 c2 Sounding Timestamp:;
}

void 802_11::Mgmt_Action::Antenna_Selection()
{
	BBYT 0 1 90 c9 Antenna Selection Indices:;
	 CBIT 7 1 00 d4 1... .... Antenna 8 is Selected;
	 CLSE 0 0 00 d4 0... .... Antenna 8 is Not Selected;
	 CBIT 6 1 00 d4 .1.. .... Antenna 7 is Selected;
	 CLSE 0 0 00 d4 .0.. .... Antenna 7 is Not Selected;
	 CBIT 5 1 00 d4 ..1. .... Antenna 6 is Selected;
	 CLSE 0 0 00 d4 ..0. .... Antenna 6 is Not Selected;
	 CBIT 4 1 00 d4 ...1 .... Antenna 5 is Selected;
	 CLSE 0 0 00 d4 ...0 .... Antenna 5 is Not Selected;
	 CBIT 3 1 00 d4 .... 1... Antenna 4 is Selected;
	 CLSE 0 0 00 d4 .... 0... Antenna 4 is Not Selected;
	 CBIT 2 1 00 d4 .... .1.. Antenna 3 is Selected;
	 CLSE 0 0 00 d4 .... .0.. Antenna 3 is Not Selected;
	 CBIT 1 1 00 d4 .... ..1. Antenna 2 is Selected;
	 CLSE 0 0 00 d4 .... ..0. Antenna 2 is Not Selected;
	 CBIT 0 1 00 d4 .... ...1 Antenna 1 is Selected;
	 CLSE 0 0 00 d4 .... ...0 Antenna 1 is Not Selected;
}

void 802_11::Mgmt_Action::HT_Information_Exchange()
{
	HBYT 0 1 90 c9 HT Information Exchange:;
	LABL 0 0 00 d4 xxxx x... Reserved;
	CBIT 1 1 00 d4 .... .1.. STA Channel Width: Shall Transmit 40MHz Mask PPDU;
	CLSE 0 0 00 d4 .... .0.. STA Channel Width: Shall Not Transmit 40MHz Mask PPDU;
	CBIT 1 1 00 d4 .... ..1. 40MHz Intolerant: Is Intolerant of 40MHz Operation;
	CLSE 0 0 00 d4 .... ..0. 40MHz Intolerant: Is Not Intolerant of 40MHz Operation;
	CBIT 0 1 00 d4 .... ...1 Information Request: Transmit STA as the Recipient;
	CLSE 0 0 00 d4 .... ...0 Information Request: May Transmit STA as the Recipient (but should not);
	LABL 0 0 00 c8;
}
//--------------------------
void 802_11::Mgmt_Action::VHTActionframe()
{
	DBYT( 0, l[1], 0x90, 0xc2, "VHT Action frame format:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::VHTActionframeVHTActionframeformat );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	TSB#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::VHTActionframeVHTActionframeformat::Ldr );
	
}

str# 802_11::Mgmt_Action::VHTActionframeVHTActionframeformat;
0	|	VHT Compressed Beamforming;
1	| 	Group ID Management;
2	|	Operating Mode Notification;

str# 802_11::Mgmt_Action::VHTActionframeVHTActionframeformat::Ldr;
0	|	802_11::Mgmt_Action::VHTActionframeVHTCompressedBeamforming;
1	| 	802_11::Mgmt_Action::VHTActionframeGroupIDManagement;
2	|	802_11::Mgmt_Action::VHTActionframeOperatingModeNotification;

void 802_11::Mgmt_Action::VHTActionframeVHTCompressedBeamforming()
{
	LABL 0 0 0 b7 VHT MIMO Control;
		HLNG( 0x40000000, g[1], 0x5, 0x5, "VHT  MIMO:" );
		ANDG 00ffffff 1;
		DECR 1;
		HGLB( 0, g[1], 0x90, 0xc9, "VHT MIMO:" );
			l[1] = g[1];
			ANDG FC0000 41;
			SHFR 12 41;
			//BGLB( 0, l[1], 0x90, 0xc2, "Sounding Dialog Number:" );
			HGLB( 0, l[1], 0x90, 0xc2, "Sounding Dialog #:" );
			LABL 0 0 0 d4 .... ..xx .... .... .... .... Reserved;
			l[10] = l[1]; 
			l[1] = g[1];
			ANDG 008000 41;
			SHFR f 41;			
				CEQU 1 41 00 d4 .... .... 1... .... .... .... First Feedback Segments: true;
				CEQU 0 41 00 d4 .... .... 0... .... .... .... First Feedback Segments: false;
			l[11] = l[1];
			l[1] = g[1];
			ANDG 007000 41;
			SHFR c 41;	
				CEQU 7 41 00 d4 .... .... .111 .... .... .... Remaining Feedback Segments: 7;
				CEQU 6 41 00 d4 .... .... .110 .... .... .... Remaining Feedback Segments: 6;
				CEQU 5 41 00 d4 .... .... .101 .... .... .... Remaining Feedback Segments: 5;
				CEQU 4 41 00 d4 .... .... .100 .... .... .... Remaining Feedback Segments: 4;
				CEQU 3 41 00 d4 .... .... .011 .... .... .... Remaining Feedback Segments: 3;
				CEQU 2 41 00 d4 .... .... .010 .... .... .... Remaining Feedback Segments: 2;
				CEQU 1 41 00 d4 .... .... .001 .... .... .... Remaining Feedback Segment: 1;
				CEQU 0 41 00 d4 .... .... .000 .... .... .... Remaining Feedback Segment: 0;
			l[12] = l[1];
			l[1] = g[1];
			ANDG 000800 41;
			SHFR b 41;
				CEQU 1 41 00 d4 .... .... .... 1... .... .... Feedback Type: MU;
				CEQU 0 41 00 d4 .... .... .... 0... .... .... Feedback Type: SU;	
			l[13] = l[1];
			l[1] = g[1];
			ANDG 000400 41;
			SHFR a 41;
			if (l[13] == 1)
			{
				CEQU 1 41 00 d4 .... .... .... .1.. .... .... Codebook Information: 7 bits for mu, 9 bits for tau;
				CEQU 0 41 00 d4 .... .... .... .0.. .... .... Codebook Information: 5 bits for mu, 7 bits for tau;	
			}
			if (l[13] == 0)
			{
				CEQU 1 41 00 d4 .... .... .... .1.. .... .... Codebook Information: 4 bits for mu, 6 bits for tau;
				CEQU 0 41 00 d4 .... .... .... .0.. .... .... Codebook Information: 2 bits for mu, 4 bits for tau;	
			}
			l[14] = l[1];
			l[1] = g[1];
			ANDG 60 41;
			SHFR 5 41; 
				CEQU 3 41 00 d4 .... .... .... ..xx .... .... Grouping (Ng): Reserved;
				CEQU 2 41 00 d4 .... .... .... ..10 .... .... Grouping (Ng): 4;
				CEQU 1 41 00 d4 .... .... .... ..01 .... .... Grouping (Ng): 2;
				CEQU 0 41 00 d4 .... .... .... ..00 .... .... Grouping (Ng): 1 (No grouping);
			l[15] = l[1];
			l[1] = g[1];
			ANDG C0 41;
			SHFR 6 41; 
				CEQU 3 41 00 d4 .... .... .... .... 11.. .... Channel Width: 160 MHz/80+80 MHz;
				CEQU 2 41 00 d4 .... .... .... .... 10.. .... Channel Width: 80 MHz;
				CEQU 1 41 00 d4 .... .... .... .... 01.. .... Channel Width: 40 MHz;
				CEQU 0 41 00 d4 .... .... .... .... 00.. .... Channel Width: 20 MHz;
			l[16] = l[1];
			l[1] = g[1];
			ANDG 38 41;
			SHFR 3 41; 
				CEQU 7 41 00 d4 .... .... .... .... ..11 1... Nr Index: 8 Rows;
				CEQU 6 41 00 d4 .... .... .... .... ..11 0... Nr Index: 7 Rows;
				CEQU 5 41 00 d4 .... .... .... .... ..10 1... Nr Index: 6 Rows;
				CEQU 4 41 00 d4 .... .... .... .... ..10 0... Nr Index: 5 Rows;
				CEQU 3 41 00 d4 .... .... .... .... ..01 1... Nr Index: 4 Rows;
				CEQU 2 41 00 d4 .... .... .... .... ..01 0... Nr Index: 3 Rows;
				CEQU 1 41 00 d4 .... .... .... .... ..00 1... Nr Index: 2 Rows;
				CEQU 0 41 00 d4 .... .... .... .... ..00 0... Nr Index: 1 Row;
			l[17] = l[1];
			l[1] = g[1];
			ANDG 7 41;
				CEQU 7 41 00 d4 .... .... .... .... .... .111 Nc Index: 8 Columns;
				CEQU 6 41 00 d4 .... .... .... .... .... .110 Nc Index: 7 Columns;
				CEQU 5 41 00 d4 .... .... .... .... .... .101 Nc Index: 6 Columns;
				CEQU 4 41 00 d4 .... .... .... .... .... .100 Nc Index: 5 Columns;
				CEQU 3 41 00 d4 .... .... .... .... .... .011 Nc Index: 4 Columns;
				CEQU 2 41 00 d4 .... .... .... .... .... .010 Nc Index: 3 Columns;
				CEQU 1 41 00 d4 .... .... .... .... .... .001 Nc Index: 2 Columns;
				CEQU 0 41 00 d4 .... .... .... .... .... .000 Nc Index: 1 Column;
			l[18] = l[1];
		LABL 0 0 00 c8;
		LABL 0 0 00 c8;
		if (l[11] == 0)
		{
			if (l[12] == 7)
			{
				LABL 0 0 0 b7 VHT Beamforming Report unknown;
					DUMP( 0 , g[16], 0x90, 0xc2,  "VHT Data:" );
				LABL 0 0 00 c8;
			}
		}
		//stupid Way to find the number of angles but there's no better
		
		if (l[17] == 0)			//Nr 
		{
			l[20] = 1;			
			if( l[18] == 0)		//Nc
			{
				l[21] = 1;	l[23] = 1;
			}
			if( l[18] == 1)		//Nc
			{
				l[21] = 2;	l[23] = 2;
			}
		}
		if (l[17] == 1)			//Nr 
		{
			l[20] = 2;			
			if( l[18] == 0)		//Nc
			{
				l[21] = 1;	l[23] = 2;
			}
			if( l[18] == 1)		//Nc
			{
				l[21] = 2;	l[23] = 2;
			}
		}
		if (l[17] == 2)			//Nr 
		{
			l[20] = 3;			
			if( l[18] == 0)		//Nc
			{
				l[21] = 1;	l[23] = 4;
			}
			if( l[18] == 1)		//Nc
			{
				l[21] = 2;	l[23] = 6;
			}
			if( l[18] == 2)		//Nc
			{
				l[21] = 3;	l[23] = 6;
			}
		}
		if (l[17] == 3)			//Nr 
		{
			l[20] = 4;			
			if( l[18] == 0)		//Nc
			{
				l[21] = 1;	l[23] = 6;
			}
			if( l[18] == 1)		//Nc
			{
				l[21] = 2;	l[23] = 10;
			}
			if( l[18] == 2)		//Nc
			{
				l[21] = 3;	l[23] = 12;
			}
			if( l[18] == 3)		//Nc
			{
				l[21] = 4;	l[23] = 12;
			}
		}
		if (l[17] == 4)			//Nr 
		{
			l[20] = 5;			
			if( l[18] == 0)		//Nc
			{
				l[21] = 1;	l[23] = 8;
			}
			if( l[18] == 1)		//Nc
			{
				l[21] = 2;	l[23] = 14;
			}
			if( l[18] == 2)		//Nc
			{
				l[21] = 3;	l[23] = 18;
			}
			if( l[18] == 3)		//Nc
			{
				l[21] = 4;	l[23] = 20;
			}
			if( l[18] == 4)		//Nc
			{
				l[21] = 5;	l[23] = 20;
			}
		}
		if (l[17] == 5)			//Nr 
		{
			l[20] = 6;			
			if( l[18] == 0)		//Nc
			{
				l[21] = 1;	l[23] = 10;
			}
			if( l[18] == 1)		//Nc
			{
				l[21] = 2;	l[23] = 18;
			}
			if( l[18] == 2)		//Nc
			{
				l[21] = 3;	l[23] = 24;
			}
			if( l[18] == 3)		//Nc
			{
				l[21] = 4;	l[23] = 28;
			}
			if( l[18] == 4)		//Nc
			{
				l[21] = 5;	l[23] = 30;
			}
			if( l[18] == 5)		//Nc
			{
				l[21] = 6;	l[23] = 30;
			}
		}
		if (l[17] == 6)			//Nr 
		{
			l[20] = 7;			
			if( l[18] == 0)		//Nc
			{
				l[21] = 1;	l[23] = 12;
			}
			if( l[18] == 1)		//Nc
			{
				l[21] = 2;	l[23] = 22;
			}
			if( l[18] == 2)		//Nc
			{
				l[21] = 3;	l[23] = 30;
			}
			if( l[18] == 3)		//Nc
			{
				l[21] = 4;	l[23] = 36;
			}
			if( l[18] == 4)		//Nc
			{
				l[21] = 5;	l[23] = 40;
			}
			if( l[18] == 5)		//Nc
			{
				l[21] = 6;	l[23] = 42;
			}
			if( l[18] == 6)		//Nc
			{
				l[21] = 7;	l[23] = 42;
			}
		}
		if (l[17] == 7)			//Nr 
		{
			l[20] = 8;			
			if( l[18] == 0)		//Nc
			{
				l[21] = 1;	l[23] = 14;
			}
			if( l[18] == 1)		//Nc
			{
				l[21] = 2;	l[23] = 26;
			}
			if( l[18] == 2)		//Nc
			{
				l[21] = 3;	l[23] = 36;
			}
			if( l[18] == 3)		//Nc
			{
				l[21] = 4;	l[23] = 44;
			}
			if( l[18] == 4)		//Nc
			{
				l[21] = 5;	l[23] = 50;
			}
			if( l[18] == 5)		//Nc
			{
				l[21] = 6;	l[23] = 54;
			}
			if( l[18] == 6)		//Nc
			{
				l[21] = 7;	l[23] = 56;
			}
			if( l[18] == 7)		//Nc
			{
				l[21] = 8;	l[23] = 56;
			}
		}
		if (l[13] == 0)			//get the bits in a local
		{
			if (l[14] == 0)
			{
				l[28] = 6;
			}
			if (l[14] == 1)
			{
				l[28] = 10;
			}
		}
		if (l[13] == 1)			//get the bits in a local
		{
			if (l[14] == 0)
			{
				l[28] = 12;
			}
			if (l[14] == 1)
			{
				l[28] = 16;
			}			
		}
		//build up Ns for the subcarriers
		if (l[16] == 0)		//20 MHz
		{
			if (l[15] == 0)
			{
				l[30] = 52;
			}
			if (l[15] == 1)
			{
				l[30] = 30;
			}
			if (l[15] == 2)
			{
				l[30] = 16;
			}
		}
		if (l[16] == 1)		//40 MHz
		{
			if (l[15] == 0)
			{
				l[30] = 108;
			}
			if (l[15] == 1)
			{
				l[30] = 58;
			}
			if (l[15] == 2)
			{
				l[30] = 30;
			}
		}
		if (l[16] == 2)		//80 MHz
		{
			if (l[15] == 0)
			{
				l[30] = 234;
			}
			if (l[15] == 1)
			{
				l[30] = 122;
			}
			if (l[15] == 2)
			{
				l[30] = 62;
			}
		}
		if (l[16] == 3)		//160 MHz
		{
			if (l[15] == 0)
			{
				l[30] = 468;
			}
			if (l[15] == 1)
			{
				l[30] = 244;
			}
			if (l[15] == 2)
			{
				l[30] = 124;
			}
		}
		//build up Ns' for MU Exclusive Beamforming 
		if (l[16] == 0)		//20 MHz
		{
			if (l[15] == 0)
			{
				l[35] = 30;
			}
			if (l[15] == 1)
			{
				l[35] = 16;
			}
			if (l[15] == 2)
			{
				l[35] = 10;
			}
		}
		if (l[16] == 1)		//40 MHz
		{
			if (l[15] == 0)
			{
				l[35] = 58;
			}
			if (l[15] == 1)
			{
				l[35] = 30;
			}
			if (l[15] == 2)
			{
				l[35] = 16;
			}
		}
		if (l[16] == 2)		//80 MHz
		{
			if (l[15] == 0)
			{
				l[35] = 122;
			}
			if (l[15] == 1)
			{
				l[35] = 62;
			}
			if (l[15] == 2)
			{
				l[35] = 32;
			}
		}
		if (l[16] == 3)		//160 MHz
		{
			if (l[15] == 0)
			{
				l[35] = 244;
			}
			if (l[15] == 1)
			{
				l[35] = 124;
			}
			if (l[15] == 2)
			{
				l[35] = 64;
			}
		}
		
		if (l[11] != 0)
		{
			if (l[12] != 7)
			{
				LABL 0 0 0 b7 VHT Compressed Beamforming Report;
					
					l[24] = 1;
					l[26] = l[23];
					LABL 0 0 0 b7 Average SNR of Space-Time;
						while (l[23] != 0)
						{
							LABL( 0, 0, 0x90, 0xc2, "Average SNR of Space-Time of Stream " );
							DGLB( 0, l[24], 0x02, 0x02, );
							LABL( 0, 0, 0, 0x02, ": ");
							HBYT( 0, l[25], 0x90, 0x02, );
							l[23] -= 1;
							l[24] += 1;
						}
					LABL 0 0 00 c8;
					l[24] = 1;
					DGLB( 0, l[28], 0x90, 0xc2, "Bits for Coding(Btau+Bmue):" );
					DGLB( 0, l[26], 0x90, 0xc2, "# of streams(Na):" );
					l[28] *= l[26];
					DGLB( 0, l[28], 0x90, 0xc2, "Value 1:" );
					l[28] /= 2;
					DGLB( 0, l[28], 0x90, 0xc2, "Value 2:" );
					DGLB( 0, l[28], 0x90, 0xc2, "Bit Size of the Feedbackmatrix subfields: " );
					//l[28] /= 8;
				
					LABL 0 0 0 b7 Compressed Beamforming Feedback Matrix;
						//DGLB( 0, l[58], 0x90, 0xc2, "Bit Size of the Feedbackmatrix subfields: " );
						DGLB( 0, l[30], 0x90, 0xc2, "Numbers of Subcarriers:" );
						l[28] *= l[30];
						l[58] = l[28];
						DGLB( 0, l[28], 0x90, 0xc2, "Bit Size of the Feedbackmatrix subfields::" );
						MODG( 8, l[28]);
						DGLB( 0, l[28], 0x90, 0xc2, "0s for padding:" );
						l[58] += l[28];
						
						DGLB( 0, l[58], 0x90, 0xc2, "Bit Size of the Feedbackmatrix subfields:" );
						l[58] /= 8;
						DGLB( 0, l[58], 0x90, 0xc2, "Byte Size of the Feedbackmatrix subfields:" );
						DGLB( 0, g[16], 0x90, 0xc2, "Left bytes in the packet:" );
						DUMP( 0, l[58], 0x90, 0xc2, "Feedbackmatrix subfields Dump:" );
						
						//l[30] -= 1;
						/*l[31] = 1;
						if ( l[28] == 1 )
						{	
							while (l[30] != 0)
							{
								LABL( 0, 0, 0x90, 0xc2, "Feedback Matrix " );								
								DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								HEX#( 1, 0, 0x90, 0x02, );
								l[30] -= 1; l[31] += 1;
							}
						}
						if ( l[28] == 2 )
						{	
							while (l[30] != 0)
							{
								LABL( 0, 0, 0x90, 0xc2, "Feedback Matrix " );								
								DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								HEX#( 2, 0, 0x90, 0x02, );
								l[30] -= 1; l[31] += 1;
							}
						}
						if ( l[28] == 30 )
						{	
							while (l[30] != 0)
							{
								LABL( 0, 0, 0x90, 0xc2, "Feedback Matrix " );								
								DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								DBIT( 30, 0, 0x90, 0x02, );
								//BBIT( 31, 0, 0x90, 0x02, );
								l[30] -= 1; l[31] += 1;
								
							}
						}
						if ( l[28] == 48 )
						{	
							while (l[30] != 0)
							{
								LABL( 0, 0, 0x90, 0xc2, "Feedback Matrix " );								
								DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								HEX#( 6, 0, 0x90, 0x02, );
								
								l[30] -= 1; l[31] += 1;
							}
						}
						if ( l[28] == 5 )
						{	
							while (l[30] != 0)
							{
								LABL( 0, 0, 0x90, 0xc2, "Feedback Matrix " );								
								DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								HEX#( 5, 0, 0x90, 0x02, );
								l[30] -= 1; l[31] += 1;
							}
						}
						if ( l[28] == 6 )
						{	
							while (l[30] != 0)
							{
								LABL( 0, 0, 0x90, 0xc2, "Feedback Matrix " );								
								DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								HEX#( 6, 0, 0x90, 0x02, );
								l[30] -= 1; l[31] += 1;
							}
						}
						if ( l[28] == 7 )
						{	
							while (l[30] != 0)
							{
								LABL( 0, 0, 0x90, 0xc2, "Feedback Matrix " );								
								DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								HEX#( 7, 0, 0x90, 0x02, );
								l[30] -= 1; l[31] += 1;
							}
						}
						if ( l[28] == 8 )
						{	
							while (l[30] != 0)
							{
								LABL( 0, 0, 0x90, 0xc2, "Feedback Matrix " );								
								DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								HEX#( 8, 0, 0x90, 0x02, );
								l[30] -= 1; l[31] += 1;
							}
						}
						/*while (l[26] != 0)
						{
							LABL( 0, 0, 0x90, 0xc2, "Compressed Beamforming Feedback Matrix V for subcarrier " );
							DGLB( 0, l[24], 0x02, 0x02, );
							LABL( 0, 0, 0, 0x02, ": ");
							HBYT( 0, l[25], 0x90, 0x02, );
							l[26] -= 1;
							l[24] += 1;
						}*/
					*/
					LABL 0 0 00 c8;
				LABL 0 0 00 c8;
				//could be length 0
				
					if (g[16]  > 4)
					{
					LABL 0 0 0 b7 MU Exclusive Beamforming Report;
					l[31] = 1;
					l[36] = l[35];
					l[37] = 1;
					l[38] = l[26];
					//DGLB( 0, l[28], 0x90, 0xc2, "Byte Size of the Feesbackmatrix subfields: " );
						DGLB( 0, l[35], 0x90, 0xc2, "Numbers of Reports:" );
						DGLB( 0, l[26], 0x90, 0xc2, "Numbers of Streams:" );
						l[36] *= l[26];
						DGLB( 0, l[36], 0x90, 0xc2, "Numbers of Bytes MU Exclusive should use:" );
						l[36] /= 2;
						DGLB( 0, l[36], 0x90, 0xc2, "Numbers of Bytes MU Exclusive coded in:" );
						DGLB( 0, g[16], 0x90, 0xc2, "Left bytes in the packet:" );
					l[31] = 1;
					l[36] = l[35];
					l[37] = 1;
					l[38] = l[26];	
					while (l[35] != 0)
						{
						l[26] = l[38];	
						l[37] = 1;
						while (l[26] != 0)
						{
							
							LABL( 0, 0, 0x90, 0xc9, "MU Exclusive Beamforming Report for Stream # " );								
								DGLB( 0, l[37], 0x02, 0x02, );
							
								LABL( 0, 0, 0x90, 0xc2, "Delta SNR (k,i)" );								
								//DGLB( 0, l[31], 0x02, 0x02, );
								LABL( 0, 0, 0, 0x02, ": ");
								DBIT( 4, 0, 0x90, 0x02, );
								//l[35] -= 1; l[31] += 1;
							
							l[26] -= 1;
							l[37] += 1;
							
							LABL 0 0 00 c8;
							DGLB( 0, g[16], 0x90, 0xc2, "Left bytes in the packet:" );
						}
						l[35] -= 1; 
						l[31] += 1;
						
					}
					DUMP( 0 , g[16], 0x90, 0xc2,  "VHT Data:" );
					LABL 0 0 00 c8;
					}
			}
		}
	LABL 0 0 00 c8;
}
void 802_11::Mgmt_Action::VHTActionframeGroupIDManagement()
{
	//3 Membership Status Array (see 8.4.1.51)
	//8 octet Membership Status Array
	l[1] = 0;
	l[2] = 1;
	LABL( 0, 0, 0, 0xb7, "Membership Status:" ); 
	while(l[1] < 64 )
	{
		LABL( 0, l[10], 0x90, 0xc2, "Membership Status In Group ID " );
		DGLB( 0, l[2], 0x02, 0x02  );
		LABL( 0, 0, 0x90, 0x02, ":" );
		BBIT( 0x40000001, l[3], 0x90, 0 );
		l[2] += 1; l[1] += 1;
	}
	LABL 0 0 00 c8;
	l[1] = 0;
	l[2] = 1;
	LABL( 0, 0, 0, 0xb7, "User Positions:" ); 
	while(l[1] < 64 )
	{
		LABL( 0, l[10], 0x90, 0xc2, "User Position In Group ID " );
		DGLB( 0, l[2], 0x02, 0x02  );
		LABL( 0, 0, 0x90, 0x02, ":" );
		BBIT( 0x40000002, l[3], 0x90, 0 );
		l[2] += 1; l[1] += 1;
		
	}
	LABL 0 0 00 c8;
}

void 802_11::Mgmt_Action::VHTActionframeOperatingModeNotification()
{
	//Operating Mode (see 8.4.1.50)
	BBYT( 0, l[1], 0x90, 0xc2, "Operating Mode:" );
	l[2] = l[1]; l[3] = l[1]; l[4] = l[1];
	l[2] &= 0x80;
	SHFR 6 42;
	l[3] &= 0x70;
	SHFR 4 43;
	l[4] &= 0x3;
	CEQU( 0, l[4], 0, 0xd4, ".... ..00 Channel Width: 20 MHz");
	CEQU( 1, l[4], 0, 0xd4, ".... ..01 Channel Width: 40 MHz");
	CEQU( 2, l[4], 0, 0xd4, ".... ..10 Channel Width: 80 MHz");
	CEQU( 3, l[4], 0, 0xd4, ".... ..11 Channel Width:: 160 MHz");
	LABL( 0, 0, 0, 0xd4, ".... xx.. Reserved");
	CEQU( 0, l[3], 0, 0xd4, ".000 .... Rx NSS: 1");
	CEQU( 1, l[3], 0, 0xd4, ".001 .... Rx NSS: 2");
	CEQU( 2, l[3], 0, 0xd4, ".010 .... Rx NSS: 3");
	CEQU( 3, l[3], 0, 0xd4, ".011 .... Rx NSS: 4");
	CEQU( 4, l[3], 0, 0xd4, ".100 .... Rx NSS: 5");
	CEQU( 5, l[3], 0, 0xd4, ".101 .... Rx NSS: 6");
	CEQU( 6, l[3], 0, 0xd4, ".110 .... Rx NSS: 7");
	CEQU( 7, l[3], 0, 0xd4, ".111 .... Rx NSS: 8");
	CEQU( 0, l[2], 0, 0xd4, "0... .... Rx NSS Type: Rx NSS carries the maximum number of spatial stream that the STA can receive");
	CEQU( 1, l[2], 0, 0xd4, "1... .... Rx NSS Type: Rx NSS carries the maximum number of spatial stream that the STA can receive as an SU PPDU");	
	g[2] -= 1;
}

void 802_11::Mgmt_Action::VHTActionframeVHT::VHTMIMOControl()
{

}
//--------------------------

void 802_11::Mgmt_Action::WMM;
	DBYT 0 01 90 c2 Action Code:;
	CST# 0 01 00 14 802_11::Mgmt_Action::WMM::ActionCode;
	CLSE 0 00 00 14 Reserved;
	DBYT 0 00 90 c2 Dialog Token:;
	DBYT 0 01 90 c2 Status Code:;
	CST# 0 01 00 14 802_11::Mgmt_Action::Action_Status_Code;
	CLSE 0 00 00 14 Reserved;
	TNXT -802_11::Information_Element_Loop;
	
str# 802_11::Mgmt_Action::WMM::ActionCode;
	0 |  ADDTS Request;
	1 |  ADDTS Response;
	2 |  DELTS;


//--------------------------

void 802_11::Mgmt_Action::WNM()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Code:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Mgmt_Action::WNM::ActionFieldValues );
		CLSE 0 0 00 14 Reserved;

	if (l[1] == 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 1)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 2)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 3)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 4) 			* Location Configuration Request frame
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		while (g[2] >= 2)
		{
			DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
				CST#( 0, l[2], 0, 0x14, 802_11::Mgmt_Action::Public::Location_Track_Notification::Subelements );
				CLSE( 0, 0, 0, 0x14, "Reserved" );
			DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
				TSB#( 0, l[2], 0, 0x14, 802_11::Mgmt_Action::Public::Location_Track_Notification::Subelements::Call );
				TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
		}
	}
	if (l[1] == 5)			* Location Configuration Response frame
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		while (g[2] >= 2)
		{
			DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
				CST#( 0, l[2], 0, 0x14, 802_11::Mgmt_Action::Public::Location_Track_Notification::Subelements );
				CLSE( 0, 0, 0, 0x14, "Reserved" );
			DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
				TSB#( 0, l[2], 0, 0x14, 802_11::Mgmt_Action::Public::Location_Track_Notification::Subelements::Call );
				TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
		}
	}
	if (l[1] == 6)			*BSS Transition Management Query
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		DBYT( 0, l[3], 0x90, 0xc2, "BSS Transition Query Reason:" );
			CST#( 0, l[3], 0, 0x14, 802_11::TransitonEventReport::TransitionandTransitionQueryreasons );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 7)			*BSS Transition Management Request
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		BBYT( 0, l[3], 0x90, 0xc9, "Request mode:" );
		DECR 1;	
		BBIT( 3, l[30], 0x90, 0xc2, "Reserved:" );
		BBIT( 1, l[31], 0x90, 0xc2, "ESS Disassociation Imminent:" );
		BBIT( 1, l[32], 0x90, 0xc2, "BSS Termination Included:" );
		BBIT( 1, l[33], 0x90, 0xc2, "Disassociation Imminent:" );
		BBIT( 1, l[34], 0x90, 0xc2, "Abridged:" );
		BBIT( 1, l[35], 0x90, 0xc2, "Preferred Candidate List Included:" );
		LABL( 0, 0, 0, 0xb8 );			
		DWRD( 0x40000000, l[4], 0x90, 0xc2, "Disassociation Timer:" );
		DBYT( 0, l[5], 0x90, 0xc2, "Validity Interval:" );
		
		if (l[32] == 1)
		{
			HEX#( 0, 12, 0x90, 0xc2, "BSS Termination Duration:" );
		}
		if (l[31] == 1)
		{
			DBYT( 0, l[37], 0x90, 0xc2, "URL Length:" );
			HEX#( 0, l[37], 0x90, 0xc2, "URL:" );
		}
		if (l[35] == 1)
		{
			while (g[16] >= 4)
			{
				GBYT( 0, l[1] );
				l[1] += 1;
				CST#( , l[1], 0x0, 0xb7, 802_11::Element_Id_Str );
					DBYT( 0, l[2], 0x90, 0xc2, "Element ID:" );
					DBYT( 0, l[4], 0x90, 0xc2, "Length:" );
					DUMP( 0, l[4], 0x90, 0xc2, "Elementdata:" );
				LABL( 0, 0, 0, 0xb8 );
			}	
		}
		//TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 8)			*BSS Transition Management Response
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		DBYT( 0, l[3], 0x90, 0xc2, "Status code:" );
			CEQU( 0, l[3], 0,0x14, "Accept" );
			CEQU( 1, l[3], 0,0x14, "Rejectâ€”Unspecified reject reason" );
			CEQU( 2, l[3], 0,0x14, "Rejectâ€”Insufficient Beacon or Probe Response frames receivedfrom all candidates" );
			CEQU( 3, l[3], 0,0x14, "Rejectâ€”Insufficient available capacity from all candidates" );
			CEQU( 4, l[3], 0,0x14, "Rejectâ€”BSS Termination undesired" );
			CEQU( 5, l[3], 0,0x14, "Rejectâ€”BSS Termination delay requested" );
			CEQU( 6, l[3], 0,0x14, "Rejectâ€”STA BSS Transition Candidate List provided" );
			CEQU( 7, l[3], 0,0x14, "Rejectâ€”No suitable BSS transition candidates" );
			CEQU( 8, l[3], 0,0x14, "Rejectâ€”Leaving ESS" );
		DBYT( 0, l[4], 0x90, 0xc2, "BSS Termination Delay:" );
		ETHR( 0, l[5], 0x90, 0xc2, "Target BSSID" );
		while (g[16] >= 4)
		{
			GBYT( 0, l[1] );
			l[1] += 1;
			CST#( , l[1], 0x0, 0xb7, 802_11::Element_Id_Str );
				DBYT( 0, l[2], 0x90, 0xc2, "Element ID:" );
				DBYT( 0, l[4], 0x90, 0xc2, "Length:" );
				DUMP( 0, l[4], 0x90, 0xc2, "Elementdata:" );
			LABL( 0, 0, 0, 0xb8 );
		}
	}
	if (l[1] == 9)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 10)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 11)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 12)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		BBYT( 0, l[5], 0x90, 0xc2, "Request Info:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 13)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 14)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 15)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Number of TFS IDs:" );
		while l[2] != 0
		{
			DBYT( 0, 0, 0x90, 0xc2, "ID:" );
			l[2] -= 1;
		}
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 16)							//WNM-Sleep Mode Request
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 17)						
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		DWRD( 0x40000000, l[3], 0x90, 0xc2, "Key Data Length:" );
		CHR#( 0, l[3], 0x90, 0xc2, "Key Data:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 18)									* TIM Broadcast Request
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 19)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 20)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		BBYT( 0, l[3], 0x90, 0xc2, "QoS Traffic Capability Flags:" );
			BST#( 0, l[3], 0x00, 0xd4, 802_11::Mgmt_Action::WNM::QoS Traffic Capability Flags );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 21)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 22)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 23)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 24)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 25)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Trigger:" );
		//TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 26)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		DBYT( 0, l[2], 0x90, 0xc2, "Type:" );
			CEQU( 0, l[2], 0, 0x14, "Firmware Update Notification" );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		TNXT -802_11::Information_Element_Loop;
	}
	if (l[1] == 27)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Dialog Token:" );
		DBYT( 0, l[2], 0x90, 0xc2, "Respmese Status:" );
			CEQU( 0, l[2], 0, 0x14, "Notification Acknowledge" );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		TNXT -802_11::Information_Element_Loop;
	}
}

str# 802_11::Mgmt_Action::WNM::QoS Traffic Capability Flags;
1	|	Reserved;
2	|	Reserved;
3	|	Reserved;
4	|	UP 4 Traffic;
5	|	UP 5 Traffic;
6	|	UP 6 Traffic;
7	|	Reserved;
str# 802_11::Mgmt_Action::WNM::ActionFieldValues;
0	| Event Request;
1	| Event Report;
2	| Diagnostic Request;
3	| Diagnostic Report;
4	| Location Configuration Request;
5	| Location Configuration Response;
6	| BSS Transition Management Query;
7	| BSS Transition Management Request;
8	| BSS Transition Management Response;
9	| FMS Request;
10	| FMS Response;
11	| Collocated Interference Request;
12	| Collocated Interference Report;
13	| TFS Request;
14	| TFS Response;
15	| TFS Notify;
16	| WNM-Sleep Mode Request;
17	| WNM-Sleep Mode Response;
18	| TIM Broadcast Request;
19	| TIM Broadcast Response;
20	| QoS Traffic Capability Update;
21	| Channel Usage Request;
22	| Channel Usage Response;
23	| DMS Request;
24	| DMS Response;
25	| Timing Measurement Request;
26	| WNM-Notification Request;
27	| WNM-Notification Response;
//28-255 Reserved;

str# 802_11::TransitonEventReport::TransitionandTransitionQueryreasons;
0	|	Unspecified;
1	|	Excessive frame loss rates and/or poor conditions;
2	|	Excessive delay for current traffic streams;
3	|	Insufficient QoS capacity for currenttraffic streams (TSPEC rejected);
4	|	First association to ESS (the association initiated by an Association Request message instead of a Reassociation Request message);
5	|	Load balancing;
6	|	Better AP found;
7	|	Deauthenticated or Disassociated from the previous AP;
8	|	AP failed IEEE 802.1X EAP Authentication;
9	|	AP failed 4-Way Handshake;
10	|	Received too many replay counter failures;
11	|	Received too many data MIC failures;
12	|	Exceeded maximum number of retransmissions;
13	|	Received too many broadcast disassociations;
14	|	Received too many broadcast deauthentications;
15	|	Previous transition failed;
16	|	Low RSSI;
17	|	Roam from a non-IEEE 802.11 system;
18	|	Transition due to received BSS Transition Request frame;
19	|	Preferred BSS Transition Candidate List Included;
20	|	Leaving ESS;
//----------------------------------------------------------
void 802_11::Mgmt_Action::Unprotected WNM()
{
	
}



//--------------------------
str# 802_11::Mgmt_Action::Action_Code;
	0 | Measurement Request;
	1 | Measurement Report;
	2 | TPC Request;
	3 | TPC Report;
	4 | Channel Switch Announcement;


str# 802_11::Mgmt_Action::Action_Status_Code;
	0 | Admission Accepted;
	1 | Invalid Parameters;
	2 | Reserved;
	3 | Refused;

//--------------------------------------------------
void 802_11::Print_Surplus_Bandwidth_Allowance()
{
	//this looks a little odd but ensures that the correct bytes are selected in the hex view
	DWRD 40000000 41 5 c2 Surplus Bandwidth Allowance: ;
	//the sba is a fixed point decimal with the decimal after the 3 bit
	FXPD d 41 90 0;
}

void 802_11::Capability Information;
	g[9] = pb[1];   // get the 2nd byte
	SHFR 3 9;		// shift right 3 bits
	g[9] &= 0x1;	// keep only the APSD bit
	BWRD 40000000 1 90 c9 Capability Info:;
	 CBIT f 1 0 d4 1....... ........ Immediate Block Ack Allowed;
	 CLSE 0 0 0 d4 0....... ........ Immediate Block Ack Not Allowed;
	 CBIT e 1 0 d4 .1...... ........ Delayed Block Ack Allowed;
	 CLSE 0 0 0 d4 .0...... ........ Delayed Block Ack Not Allowed;
	 CBIT d 1 0 d4 ..1..... ........ DSSS-OFDM is Allowed;
	 CLSE 0 0 0 d4 ..0..... ........ DSSS-OFDM is Not Allowed;
	 CBIT c 1 0 d4 ...1.... ........ Radio Measurement;
	 CLSE 0 0 0 d4 ...0.... ........ No Radio Measurement;
	 CBIT b 1 0 d4 ....1... ........ APSD is supported;			//Robust Security Network Enabled;
	 CLSE 0 0 0 d4 ....0... ........ APSD is not supported;		//Robust Security Network Disabled;
	 CBIT a 1 0 d4 .....1.. ........ G Mode Short Slot Time [9 microseconds];
	 CLSE 0 0 0 d4 .....0.. ........ G Mode Short Slot Time [20 microseconds];
	 CBIT 9 1 0 d4 ......1. ........ QoS is Supported;
	 CLSE 0 0 0 d4 ......0. ........ QoS is Not Supported;
	 CBIT 8 1 0 d4 .......1 ........ Spectrum Mgmt Enabled;
	 CLSE 0 0 0 d4 .......0 ........ Spectrum Mgmt Disabled;
	 CBIT 7 1 0 d4 ........ 1....... Channel Agility;
	 CLSE 0 0 0 d4 ........ 0....... Channel Agility Not Used;
	 CBIT 6 1 0 d4 ........ .1...... PBCC;
	 CLSE 0 0 0 d4 ........ .0...... PBCC Not Allowed;
	 CBIT 5 1 0 d4 ........ ..1..... Short Preamble;
	 CLSE 0 0 0 d4 ........ ..0..... Short Preamble Not Allowed;
	 CBIT 4 1 0 d4 ........ ...1.... Privacy Enabled;
	 CLSE 0 0 0 d4 ........ ...0.... Privacy Disabled;
	 CBIT 3 1 0 d4 ........ ....1... CF Poll Requested;
	 CLSE 0 0 0 d4 ........ ....0... CF Poll Not Requested;
	 CBIT 2 1 0 d4 ........ .....1.. CF Pollable;
	 CLSE 0 0 0 d4 ........ .....0.. CF Not Pollable;
	 CBIT 1 1 0 d4 ........ ......1. IBSS Type Network;
	 CLSE 0 0 0 d4 ........ ......0. Not an IBSS Type Network;
	 CBIT 0 1 0 d4 ........ .......1 ESS Type Network;
	 CLSE 0 0 0 d4 ........ .......0 Not an ESS Type Network;
	LABL 0 0 0 c8;
	TRTS;
	
//-----------------------------------

void 802_11::Information_Element()
{
	if (g[16] < 2) 
	{
		TRTS; 
	}
			
	l[1] = pb[0];
	l[1] += 1;		// list starts at 1

	if (l[1] == 222)
	{
		l[5] = pb[5];
		g[6] = pb[2];
		g[7] = g[6];
		g[6] = pb[3];
		SHFL 8 7;
		ADDG 6 87;
		g[6] = pb[4];
		SHFL 8 7 0 0;
		ADDG 6 87;
		if (g[7] == 0x0050f2)
		{
			if (l[5] == 2)
			{
				LABL 0 0 0 b7 WMM;
			}
			if (l[5] == 4)
			{
				LABL 0 0 0 b7 WPS;
			}			
			if (l[5] != 2)
			{
				if( l[5] != 4 )
				{
					LABL 0 0 0 b7 WPA;
				}
			}
		}
		if (g[7] == 0x506F9A)
		{
			if (l[5] >= 5)
			{
				LABL 0 0 0 b7 Wi-Fi Direct;
			}
		}
		if (g[7] != 0x0050f2)
		{
			if (g[7] != 0x506F9A)
			{
				LABL 0 0 0 b7 Vendor Specific;
			}
		}
	}
	if (l[1] != 222)
	{
		CST#( 0, l[1], 0x0, 0xb7, 802_11::Element_Id_Str );
	}
	
	DBYT( 0, l[3], 0x90, 0xc2, "Element ID:\ID:" );
	if (l[1] == 222)
	{
		l[5] = pb[4];
		if (g[7] == 0x0050f2)
		{
			if (l[5] == 2)
			{
				LABL 0 0 0 14 WMM;
			}
			if( l[5] == 4)
			{
				LABL 0 0 0 14 WPS;
			}
			if (l[5] != 2)
			{
				if( l[5] != 4 )
				{
					LABL 0 0 0 14 WPA;
				}
			}
		}
		if (g[7] != 0x0050f2)
		{
			LABL 0 0 0 14 Vendor Specific;
			l[6] = pl[1];
			ANDG ffffff00 46;
			if (l[6] == 0x00409600)
			{
				LABL 0 0 0 04 " - Cisco";
			}
			if (l[6] == 0x00101800)
			{
				LABL 0 0 0 04 " - Broadcom";
			}
			if (l[6] == 0x000C4300)
			{
				LABL 0 0 0 04 " - Ralink";
			}
			if (l[6] == 0x506f9a00)
			{
				LABL 0 0 0 04 " - Wi-Fi Alliance";
			}
			* SamChen
			if (l[6] == 0x000B8600)
			{
				LABL 0 0 0 04 " - Aruba";
				l[1] = 999;
			}
			if (l[6] == 0x00904C00)
			{
				LABL 0 0 0 04 " - Epigram";
			}
			if (l[6] == 0x00040E00)
			{
				LABL 0 0 0 04 " - AVM GmbH";
			}
			if (l[6] == 0x00037F00)
			{
				LABL 0 0 0 04 " - Atheros Communications, Inc.";
			}
		}
	}
	if (l[1] != 222)
	{
		CST#( 0, l[1], 0x0, 0x14, 802_11::Element_Id_Str );
	}
		
	//	Length is in global 2
	//some of the IE types use the length information in g[2]
	DBYT( 0, g[2], 0x90, 0xc2, "Length:\Len:" );
		
	//	Subtract 2 bytes (ID & Length) from bytes left

	if (g[2] != 0)
	{
		* SamChen
		if (l[1] == 999)
		{
			BREM 0 4a 5 5;
			802_11::IE_Aruba();
		}

		if (l[1] != 999)
		{
			* LABL( 0, 0, 0x90, 0xc2, "### Sam 1: " );
			* DGLB( 0, l[1], 0x02, 0 );
			* SamChen:  DMS Element ID
			if (l[1] == 100)
			{
				802_11::DMS_Request();
				LABL 0 0 0 b8;
				TRTS;
			}

			if (l[1] == 101)
			{
				802_11::DMS_Response();
				LABL 0 0 0 b8;
				TRTS;
			}

			BREM 0 4a 5 5;
			TSB#( 0, l[1], 0, 0, 802_11::Information_Element_Types );
			BREM 0 4b 5 5;
			if (l[10] == l[11])
			{
				802_11::IE_Generic();
			}			
		}
	}

	LABL 0 0 0 b8;
}

//-----------------------------------
			
void 802_11::Information_Element_Loop()
{
	while (g[16] >= 2)
	{
		802_11::Information_Element();
	}	
}

//-----------------------------------

str# 802_11::Information_Element_Types;
	802_11::IE_SSID;
	802_11::IE_Supported Rates;
	802_11::IE_FH Parameter Set;
	802_11::IE_DS Parameter Set;
	802_11::IE_CF Parameter Set;
	802_11::IE_TIM;
	802_11::IE_IBSS Parameter Set;
	802_11::IE_Country;
	802_11::IE_Generic;	*802_11::IE_FH Hopping Pattern Parameters;
	802_11::IE_Generic;	*802_11::IE_FH Hopping Pattern Table;
	802_11::IE_Generic;	*802_11::IE_Request; 10
	802_11::IE_Type_11;						
	802_11::IE_Type_12;
	802_11::IE_Type_13;		// traffic specifciation (TSPEC)
	802_11::IE_Type_14;		// traffic classification (tclas)
	802_11::IE_Type_15;		// schedule information
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *20
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *30
	802_11::IE_Generic;
	802_11::IE_Type_32;		// power constrain
	802_11::IE_Type_33;		// power capability
	802_11::IE_Type_34;		// tpc request
	802_11::IE_Type_35;		// tpc report
	802_11::IE_Type_36;		// supported channels
	802_11::IE_Type_37;		// channel switch announcement
	802_11::IE_Type_38;		// measurement request
	802_11::IE_Type_39;		// measurement report
	802_11::IE_Type_40; *40	// quiet
	802_11::IE_Type_41;		// IBSS DFS
	802_11::IE_ERP;
	802_11::IE_Type_43;		// TS Delay				
	802_11::IE_Type_44;		// TCLAS Processing
	802_11::IE_HT_Capability;		// 802.11n
	802_11::IE_Type_46;				// QoS Capability
	802_11::IE_Generic;
	802_11::IE_Type_48;				// RSN
	802_11::IE_Generic;
	802_11::IE_EXT_Supported_Rates; *50
	802_11::IE_AP_Channel_Report;
	802_11::IE_Type_52;
	802_11::IE_Type_53;
	802_11::IE_Type_54;		// 54: Mobility Domain
	802_11::Fast_BSS_transition;
	802_11::Timeout_Interval;
	802_11::RIC_Data;
	802_11::DSE_Registered_Location;
	802_11::Supported_Regulatory_Classes;
	802_11::IE_Extended_Channel_Switch_Announcement; *60
	802_11::IE_Additional_HT;
	802_11N::IE_Secondary_Channel_Offset;	// IE type 62
	802_11::BSS_Average_Access_Delay;
	802_11::Antenna;
	802_11::RSNI;
	802_11::Measurement_Pilot_Transmission;
	802_11::BSS_Available_Admission_Capacity;
	802_11::IE_WAPI;
	802_11::Wave_Service_Information;				//TT23761 802.11p
	802_11::RM_Enabled_Capabilities; *70
	802_11::Multiple_BSSID;
	802_11N::20_40_BSS_Coexistence;					//IE type 72
	802_11N::20_40_BSS_Intolerant_Channel_Report;	//IE type 73
	802_11N::Overlapping_BSS_Scan_Params;			//IE type 74
	802_11::RIC_Descriptor;
	802_11::Management_MIC;
	802_11::IE_Generic; *77
	802_11::Event_Request;
	802_11::Event_Report;
	802_11::Diagnostic_Request; *80
	802_11::Diagnostic_Report;
	802_11::Location_Parameters;
	802_11::Non-transmitted_BSSID_Capability;
	802_11::SSID_List;
	802_11::Multiple_BSSID-Index; *85
	802_11::FMS_Descriptor;
	802_11::FMS_Request;
	802_11::FMS_Response;
	802_11::QoS_Traffic_Capability;
	802_11::BSS_Max_Idle_Period; *90
	802_11::TFS_Request;
	802_11::TFS_Response;
	802_11::WNM-Sleep_Mode;
	802_11::TIM_Broadcast_Request;
	802_11::TIM_Broadcast_Response;
	802_11::Collocated_Interference_Report;
	802_11::Channel_Usage;
	802_11::Time_Zone;
	802_11::DMS_Request;
	802_11::DMS_Response; *100
	802_11::Link_Identifier;
	802_11::Wakeup_Schedule;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Type_107;			//IEEE 802.11u Interworking
	802_11::IE_Type_108;			//IEEE 802.11u Advertisement Protocol
	802_11::IE_Type_109;			//IEEE 802.11u Expedited Bandwidth Request
	802_11::IE_Type_110; *110 		//IEEE 802.11u QoS Map Set
	802_11::IE_Type_111;			//IEEE 802.11u Roaming Consortium
	802_11::IE_Type_112;			//IEEE 802.11u Emergency Alert Identifier
	802_11::Mesh_Configuration;
	802_11::Mesh_ID;
	802_11::Mesh_Peering_Management;
	802_11::Congestion_Notification;
	802_11::Mesh_Peering_Management;
	802_11::Mesh_Channel_Switch_Parameters;
	802_11::Mesh_Awake_Window;
	802_11::Beacon_Timing; *120
	802_11::MCCAOP_Setup_Request;
	802_11::MCCAOP_Setup_Reply;
	802_11::MCCAOP_Advertisement;
	802_11::MCCAOP_Teardown;
	802_11::GANN;
	802_11::RANN;
	802_11::Extended_Capabilities;	//IE type 127
	802_11::IE_Agere;  * 128
	802_11::IE_Generic;
	802_11::PREQ; *130
	802_11::PREP;
	802_11::PERR;
	802_11::IE_Cisco;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::Authenticated_Mesh_Peering_Exchange;
	802_11::IE_Generic; *140
	802_11::Destination URI;
	802_11::U-APSD_Coexistence;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Type_221; *150
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *160
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *170
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Symbol;
	802_11::MCCAOP_Advertisement_Overview;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *180
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;  *190
	802_11::VHT_Capabilities;  	//IEEE P802.11ac D3.0 June 2012
	802_11::VHT_Operations;		//IEEE P802.11ac D3.0 June 2012
	802_11::Extended_BSS_Load;			//IEEE P802.11ac D3.0 June 2012
	802_11::Wide_Bandwidth_Channel_Switch;		//IEEE P802.11ac D3.0 June 2012
	802_11::VHT_Transmit_Power_Envelope;		//IEEE P802.11ac D3.0 June 2012
	802_11::Channel_Switch_Wrapper;		//IEEE P802.11ac D3.0 June 2012
	802_11::AID;		//IEEE P802.11ac D3.0 June 2012
	802_11::Quiet_Channel;		//IEEE P802.11ac D3.0 June 2012
	802_11::Operation_Mode_Notification;		//IEEE P802.11ac D3.0 June 2012
	802_11::IE_Generic; *200
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *210
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *220
	802_11::IE_Type_221;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *230
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *240
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *250
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic;
	802_11::IE_Generic; *255


void 802_11::IE_Generic;
	if (g[2] > 0)
	{
		HEX# 0 2 90 c2 Value:;
	}
	TRTS;

//------------------------------------------------------

void 802_11::IE_SSID;						// type 1
	CHR# 0 2 90 c2 SSID:;
	TRTS;

//------------------------------------------------------

void 802_11::IE_Supported Rates;			// type 2
	MOVE 2 83;
	802_11::IE_Supported Rates Loop;
	TRTS;

void 802_11::IE_Supported Rates Loop;
	SEQU 0 3;
	SKIP 80000001;
	TRTS;
	GBIT 1 c;
	HBYT 1 b 5 c2 Supported Rate:\Rate:;	
	ANDG 7f b;
	MOVE b 81;				// si: for .5 values
	MODG 2 1;	
	DIVG 2 b;
	DGLB 0 b 90 0;
	if (g[1] == 1) {
	 LABL 0 0 90 0 ".5";
	}
	if (g[1] == 0) {
	 LABL 0 0 90 0 ".0";
	}
	LABL 0 0 0 14 Mbps;
	CEQU 0 c 0 14 (Not BSS Basic Rate);
	CEQU 1 c 0 14 (BSS Basic Rate);
*	Alternative method:
*	DBIT 1 b 0 d2 Basic Rate:;
*	CEQU 0 b 0 14 Not Basic Service Set Basic Rate;
*	CEQU 1 b 0 14 Basic Service Set Basic Rate;
*	DBIT 7 b 0 d2 Supported Rate:;
*	CEQU 2 b 0 14 1.0 Mbps;
*	CEQU 4 b 0 14 2.0 Mbps;
*	CEQU b b 0 14 5.5 Mbps;
*	CEQU 16 b 0 14 11.0 Mbps;
	SUBG 1 3;
	TNXT -802_11::IE_Supported Rates Loop;

void 802_11::TDLS_IE_Supported_Rates;
	GBYT( 0, l[9] );

	if (l[9] == 0x7f)
	{
		DBYT( 0, 0, 0x90, 0xc2, "Extended Capability:" );
	}

	if (l[9] != 0x7f)
	{
		DBYT( 0, 0, 0x90, 0xc2, "Supported Rate ID:" );
	}

	DBYT( 0, l[8], 0x90, 0xc2, "Length:" );

	while (l[8] != 0)
	{
		GBIT 1 c;
		HBYT 1 b 5 c2 Supported Rate:\Rate:;	
		ANDG 7f b;
		MOVE b 81;				// si: for .5 values
		MODG 2 1;	
		DIVG 2 b;
		DGLB 0 b 90 0;
		if (g[1] == 1) 
		{
			LABL 0 0 90 0 ".5";
		}
		if (g[1] == 0) 
		{
			LABL 0 0 90 0 ".0";
		}
		LABL 0 0 0 14 Mbps;
		CEQU 0 c 0 14 (Not BSS Basic Rate);
		CEQU 1 c 0 14 (BSS Basic Rate);

		l[8] -= 1;
	}

	TRTS;

//------------------------------------------------------

void 802_11::TDLS_QoS_Traffic_Capability;
	DBYT( 0, 0, 0x90, 0xc2, "QoS Capability:" );
	DBYT( 0, l[1], 0x90, 0xc2, "Length:" );

	while (l[1] != 0)
	{
		DBYT( 0, 0, 0x90, 0xc2, "QoS Info:" );
		l[1] -= 1;
	}

	TRTS;

//------------------------------------------------------

void 802_11::TDLS_20_40_BSS_Coexistence;
	DBYT( 0, 0, 0x90, 0xc2, "20/40 BSS Coexistence:" );
	DBYT( 0, l[1], 0x90, 0xc2, "Length:" );

	while (l[1] != 0)
	{
		DBYT( 0, 0, 0x90, 0xc2, "Data Tag:" );
		l[1] -= 1;
	}

	TRTS;

//------------------------------------------------------

void 802_11::IE_FH Parameter Set;			// type 3
	SEQU 5 2;
	SKIP 2;
	802_11::IE_Generic;
	TRTS;
	DWRD 40000000 0 90 c2 Dwell Time (TU):;
	DBYT 0 0 90 c2 Hop Set:;
	DBYT 0 0 90 c2 Hop Pattern:;
	DBYT 0 0 90 c2 Hop Index:;
	TRTS;

//------------------------------------------------------

void 802_11::IE_DS Parameter Set;			// type 4
	SEQU 1 2;
	SKIP 2;
	802_11::IE_Generic;
	TRTS;
	DBYT 0 0 90 c2 Channel:;
	TRTS;

//------------------------------------------------------

void 802_11::IE_CF Parameter Set;			// type 5
	SEQU 6 2;
	SKIP 2;
	802_11::IE_Generic;
	TRTS;
	DBYT 0 0 90 c2 CFP Count:;
	DBYT 0 0 90 c2 CFP Period:;
	DWRD 40000000 0 90 c2 CFP Max Dur:;
	DWRD 40000000 0 90 c2 CFP Dur Remaining:;
	TRTS;

//------------------------------------------------------

void 802_11::IE_TIM;						// type 6
	SLTE 4 2;
	SKIP 2;
	802_11::IE_Generic;
	TRTS;
	DBYT 0 0 90 c2 DTIM Count:;
	DBYT 0 0 90 c2 DTIM Period:;
	BBIT 8 41 90 c9 Bitmap Control:;
	l[2] = l[1];
	l[1] &= 0xFE;
	SHFR( 1, l[1]);
	l[2] &= 0x01;
	DGLB 0 41 04 14 BitOff: ;
	DGLB 0 42 04 14 TIM: ;
		CEQU 1 42 00 14 Group Frames Buffered;
		CLSE 0 0 00 14 No Group Frames Buffered;
	DGLB 0 41 90 c2 Bitmap Offset: ;	
	DGLB 0 42 90 c2 Traffic Indication:;
		CEQU 1 42 00 14 Group Frames Buffered at AP;
		CLSE 0 0 00 14 No Group Frames Buffered at AP;
	*calc N1
	l[1] *= 2;

	LABL 0 0 0 b8; //unindent
	
	*Calc A
	l[1] *= 8;
	//DGLB 0 41 90 c2 A:;
	MOVE 2 83;
	SUBG 3 3;
	l[6] = 0;
	l[7] = 1;
	//l[10] = l[5];
	
	//special case for when the map is of size 1 byte
	//since it could also mean an empty map
	if (g[3] == 1) //size of map in bytes
	{
		HBYT 0 46 20 c9 Partial Virtual Bitmap:;
		if (l[1] == 0) //offset
		{
			if (l[6] == 0)
			{
				LABL 0 0 0 14 No Traffic Buffered;
				LABL 0 0 0 b8;
				TRTS;
			}
		}
		DECR 1 0 0 0 ; 
		
	}
	
	if ((g[3] != 1)
	{
		HEX# 0 3 20 c9 Partial Virtual Bitmap:;
		DECR 0 3 0 0; 
	}
	
	
	
	
	g[3] *= 8;
	l[10] = l[1];
	while (g[3] != 0)
	{
		//the data presented is binary, so this
		//call has to be first, or the mask gets 
		//messed up
		BBIT 20000001 49 95 85 ;
		LABL 0 0 0 02 AID \A;
		DGLB 0 4a 2 02  ;
		LABL 0 0 0 42 :;
		//BBIT 1 49 90 42 ;
		l[10] += 1;
		if l[9] == 1
		{
			LABL 0 0 0 50 1;
			LABL 0 0 0 14 Traffic is buffered\;
		}
		if l[9] == 0
		{
			LABL 0 0 0 50 0;
			LABL 0 0 0 14 Traffic is not buffered\;
		}
		g[3] -= 1;
	}
	
	LABL 0 0 0 b8;
	TRTS;

//------------------------------------------------------

void 802_11::IE_IBSS Parameter Set;				// type 7
	SEQU 2 2;
	SKIP 2;
	802_11::IE_Generic;
	TRTS;
	DWRD 40000000 0 90 c2 ATIM Window:;
	TRTS;
	
//------------------------------------------------------

void 802_11::IE_Country;						// type 8
	CHR# 2 0 90 C2 Country Code:;
	HBYT 0 41 90 C2 Environment:;
		CEQU 20 41 0 14 Any;
		CEQU 4f 41 0 14 Outdoor;
		CEQU 49 41 0 14 Indoor;
	SUBG 3 2;
	802_11::Regulatory Triplet Loop;
	
	SEQU 0 2;
	SKIP 80000001;
	TRTS;
	HEX# 0 2 90 C2 Pad:;
	TRTS;

void 802_11::Regulatory Triplet Loop;
	DBYT 0 0 90 C2 Starting Channel:;
	DBYT 0 0 90 C2 Number of Channels:;
	DBYT 0 0 90 C2 Max Tx Power (dBm):;
	SUBG 3 2;
	if (3 > g[2])
	{
		TRTS;
	}
	TNXT -802_11::Regulatory Triplet Loop;
	TRTS;	

//------------------------------------------------------
//------------------------------------------------------
//Hopping Pattern Parameters element 				type 8

void 802_11::Hopping_Pattern;
	DBYT 0 0 90 C2 Prime Radix:;
	DBYT 0 0 90 C2 Number of Channels:;
	SUBG 3 2;
	
//------------------------------------------------------
//Hopping Pattern Table								type 9

void 802_11::Hopping_Pattern_Table;
	DBYT 0 0 90 C2 Flag:;
	DBYT 0 0 90 C2 Number of Sets:;
	DBYT 0 0 90 C2 Modulus:;
	DBYT 0 0 90 C2 Offset:;
	SUBG 4 2;
	HEX# 0 2 90 C2 Random Table:;
	
//------------------------------------------------------
//type 10
void 802_11::Request;
	HEX# 0 2 90 C2 Requested Element IDs:;

//------------------------------------------------------
void 802_11::IE_Type_11;						// QBSS Load Element
	if ( g[2] == 5 )
	{
		DWRD 40000000 0 90 c2 Station Count:;
		DBYT 0 41 90 c2 Channel Utilization:;
		l[1] *= 100;
		l[1] /= 255;
		LABL( 0, 0, 0, 0x14, " approx. " );
		DGLB( 0, l[1], 0x04, 0 );
		LABL 0 0 0 04 %;
		DWRD 40000000 0 90 c2 Avail Admission Capacity:;
	}

//------------------------------------------------------

void 802_11::IE_Type_12;						// EDCA Parameter Set Element
	if ( g[2] == 1 )
	{
		TRTS;
	}
	if ( g[2] == 18 )
	{
		BBYT 0 41 90 c9 AC Info:;
		 LABL 0 00 00 d4 xxxx .... Reserved;
		 ANDG f 41;
		 CST# 0 41 00 d4 802_11::IE_Type_12::AC_Info;
		 CLSE 0 00 00 d4 .... 0000 Param Set Count: 0;
		 LABL 0 00 00 c8;
		HBYT 0 0 90 c2 Reserved:;
		LABL 0 0 0 c7 Access Category - Best Effort;
		 802_11::IE_WME::AC;
		 LABL 0 0 0 c8;
		LABL 0 0 0 c7 Access Category - Background;
		 802_11::IE_WME::AC;
		 LABL 0 0 0 c8;
		LABL 0 0 0 c7 Access Category - Video;
		 802_11::IE_WME::AC;
		 LABL 0 0 0 c8;
		LABL 0 0 0 c7 Access Category - Voice;
		 802_11::IE_WME::AC;
		 LABL 0 0 0 c8;
	}

str# 802_11::IE_Type_12::AC_Info;
	.... 0001 Param Set Count: 1;
	.... 0010 Param Set Count: 2;
	.... 0011 Param Set Count: 3;
	.... 0100 Param Set Count: 4;
	.... 0101 Param Set Count: 5;
	.... 0110 Param Set Count: 6;
	.... 0111 Param Set Count: 7;
	.... 1000 Param Set Count: 8;
	.... 1001 Param Set Count: 9;
	.... 1010 Param Set Count: 10;
	.... 1011 Param Set Count: 11;
	.... 1100 Param Set Count: 12;
	.... 1101 Param Set Count: 13;
	.... 1110 Param Set Count: 14;
	.... 1111 Param Set Count: 15;

//------------------------------------------------------

void 802_11::IE_Type_13;			//traffic specification (tspec)
	if (g[2] == 55)
	{
		802_11::IE_Type_13::TS_Info;
		g[2] -= 3;
		DWRD 40000000 0 90 c2 Nominal MSDU Size:;
		DWRD 40000000 0 90 c2 Maximum MSDU Size:;
		g[2] -= 4;
		DLNG 40000000 0 90 c2 Min Service Interval:;
		DLNG 40000000 0 90 c2 Max Service Interval:;
		DLNG 40000000 0 90 c2 Inactivity Interval:;
		DLNG 40000000 0 90 c2 Suspension Interval:;
		g[2] -= 16;
		DLNG 40000000 0 90 c2 Service Start Time:;
		DLNG 40000000 0 90 c2 Min Data Rate:;
		DLNG 40000000 0 90 c2 Mean Data Rate:;
		DLNG 40000000 0 90 c2 Peak Data Rate:;
		g[2] -= 16;
		DLNG 40000000 0 90 c2 Burst Size:;
		DLNG 40000000 0 90 c2 Delay Bound:;
		DLNG 40000000 0 90 c2 Min PHY Rate:;
		g[2] -= 12;
		
		802_11::Print_Surplus_Bandwidth_Allowance;
		
		DWRD 40000000 0 90 c2 Medium Time:;
		g[2] -= 4;
		TRTS;
	}
	TRTS;

void 802_11::IE_Type_13::TS_Info()
{
	l[1] = pb[2];
	l[2] = pb[1];
	l[3] = pb[0];
	HEX#( 0, 3, 0x05, 0xc9, "TS Info:" );
	SHFL( 8, l[1] );
	l[1] += l[2];
	SHFL( 8, l[1] );
	l[1] += l[3];
	DGLB( 0, l[1], 0x90, 0x02);
		g[1] = l[1];
		
		//we need the APSD bit before interpreting the schedule bit
		l[2] = g[1];
		l[2] &= 0x400;
		SHFR 9 42;
		
		l[1] = g[1];
		ANDG 10000 41;
		SHFR 10 41;
		//combine APSD and schedule bits to get the schedule
		l[2] += l[1];
		
		CEQU 3 42 00 d4 .......1 .....1.. ........ Scheduled APSD;
		CEQU 2 42 00 d4 .......0 .....1.. ........ Unscheduled APSD;
		CEQU 1 42 00 d4 .......1 .....0.. ........ Scheduled PSMP;
		CEQU 0 42 00 d4 .......0 .....0.. ........ No Schedule;
		
		l[1] = g[1];
		ANDG c000 41;
		SHFR e 41;
		CEQU 3 41 00 d4 ........ 11...... ........ TSInfo Ack Policy: Block acknowledgement;
		CEQU 2 41 00 d4 ........ 10...... ........ TSInfo Ack Policy: Reserved;
		CEQU 1 41 00 d4 ........ 01...... ........ TSInfo Ack Policy: No acknowledgement;
		CEQU 0 41 00 d4 ........ 00...... ........ TSInfo Ack Policy: Normal IEEE 802.11 acknowledgement;

		l[1] = g[1];
		ANDG 3800 41;
		SHFR b 41;
		CST# 0 41 00 d4 802_11::IE_Type_13::UP_Field;
		
		CBIT a 1 00 d4 ........ .....1.. ........ APSD: Used for the traffic associated with the TSPEC;
		CLSE 0 0 00 d4 ........ .....0.. ........ APSD: Not Set;
		
		CBIT 9 1 00 d4 ........ ......1. ........ Aggregation: Provided;
		CLSE 0 0 00 d4 ........ ......0. ........ Aggregation: Not Provided;
		
		l[1] = g[1];
		ANDG 180 41;
		SHFR 7 41;
		CEQU 3 41 00 d4 ........ .......1 1....... AP: HEMM - HCCA, EDCA mixed mode;
		CEQU 2 41 00 d4 ........ .......1 0....... AP: HCCA - Controlled channel access;
		CEQU 1 41 00 d4 ........ .......0 1....... AP: EDCA - Contention based channel access;
		CEQU 0 41 00 d4 ........ .......0 0....... AP: PSMP - Power Save Multiple Poll;
		
		l[1] = g[1];
		ANDG 60 41;
		SHFR 5 41;
		CEQU 3 41 00 d4 ........ ........ .11..... Direction: Bidrectional Link;
		CEQU 2 41 00 d4 ........ ........ .10..... Direction: Direct Link;
		CEQU 1 41 00 d4 ........ ........ .01..... Direction: Downlink;
		CEQU 0 41 00 d4 ........ ........ .00..... Direction: Uplink;
		
		l[1] = g[1];
		ANDG 1e 41;
		SHFR 1 41;
		CST# 0 41 00 d4 802_11::IE_Type_13::TSID_Field;
		CLSE 0 00 00 d4 ........ ........ ...0000. TSID: EDCA: 0;
		
		CBIT 0 01 00 d4 ........ ........ .......1 Traffic Type: periodic traffic pattern;
		CLSE 0 00 00 d4 ........ ........ .......0 Traffic Type: unspecified traffic pattern;
		
		LABL 0 00 00 c8;
		TRTS;
}

str# 802_11::IE_Type_13::TSID_Field;
	........ ........ ...0001. TSID: EDCA: 1;
	........ ........ ...0010. TSID: EDCA: 2;
	........ ........ ...0011. TSID: EDCA: 3;
	........ ........ ...0100. TSID: EDCA: 4;
	........ ........ ...0101. TSID: EDCA: 5;
	........ ........ ...0110. TSID: EDCA: 6;
	........ ........ ...0111. TSID: EDCA: 7;
	........ ........ ...1000. TSID: HCCA/HEMM: 8;
	........ ........ ...1001. TSID: HCCA/HEMM: 9;
	........ ........ ...1010. TSID: HCCA/HEMM: 10;
	........ ........ ...1011. TSID: HCCA/HEMM: 11;
	........ ........ ...1100. TSID: HCCA/HEMM: 12;
	........ ........ ...1101. TSID: HCCA/HEMM: 13;
	........ ........ ...1110. TSID: HCCA/HEMM: 14;
	........ ........ ...1111. TSID: HCCA/HEMM: 15;

str# 802_11::IE_Type_13::UP_Field;
	0 | ........ ..000... ........ UP: 0 Best Effort;
	1 | ........ ..001... ........ UP: 1 Background;
	2 | ........ ..010... ........ UP: 2 Background;
	3 | ........ ..011... ........ UP: 3 Best Effort;
	4 | ........ ..100... ........ UP: 4 Video;
	5 | ........ ..101... ........ UP: 5 Video;
	6 | ........ ..110... ........ UP: 6 Voice;
	7 | ........ ..111... ........ UP: 7 Voice;
	
//------------------------------------------------------
//traffic classification
void 802_11::IE_Type_14()				
{			
	DBYT 0 0 90 c2 User Priority:;
	g[2] -= 1;
	while (g[2] > 0)
	{
		LABL 0 0 0 c7 Frame Classifier;
		DBYT 0 41 90 c2 Classifier Type:;
		 CEQU 0 41 00 14 Ethernet Parameters;
		 CEQU 1 41 00 14 TCP/UDP IP Parameters;
		 CEQU 2 41 00 14 IEEE 802.1D/Q Parameters;
		 if (l[1] > 2)
		 {
			LABL 0 0 00 14 Reserved;
		 }
		HBYT( 0, l[2], 0x90, 0xc9, "Classifier Mask:" );
			CBIT( 7, l[2], 0, 0xd4, "1....... Reserved: Yes" );
			CLSE( 7, l[2], 0, 0xd4, "0....... Reserved: No" );
			CBIT( 6, l[2], 0, 0xd4, ".1...... Protocol: Yes" );
			CLSE( 6, l[2], 0, 0xd4, ".0...... Protocol: No" );
			CBIT( 5, l[2], 0, 0xd4, "..1..... DSCP: Yes" );
			CLSE( 5, l[2], 0, 0xd4, "..0..... DSCP: No" );
			CBIT( 4, l[2], 0, 0xd4, "...1.... Destination Port: Yes" );
			CLSE( 4, l[2], 0, 0xd4, "...0.... Destination Port: No" );
			CBIT( 3, l[2], 0, 0xd4, "....1... Source Port: Yes" );
			CLSE( 3, l[2], 0, 0xd4, "....0... Source Port: No" );
			CBIT( 2, l[2], 0, 0xd4, ".....1.. Destination IP Address: Yes" );
			CLSE( 2, l[2], 0, 0xd4, ".....0.. Destination IP Address: No" );
			CBIT( 1, l[2], 0, 0xd4, "......1. Source IP Address: Yes" );
			CLSE( 1, l[2], 0, 0xd4, "......0. Source IP Address: No" );
			CBIT( 0, l[2], 0, 0xd4, ".......1 Version: Yes" );
			CLSE( 0, l[2], 0, 0xd4, ".......1 Version: No" );
		LABL 0 0 0 c8;

		g[2] -= 2;
		if (l[1] == 0)
		{
			ETHR 0 0 90 c2 Source:;
			ETHR 0 0 90 c2 Destination:;
			DWRD 0 0 90 c2 Type:;
			g[2] -= 14;
		}
		if (l[1] == 1)
		{
			DBYT( 0, l[3], 0x90, 0xc2, "Version:" );
			g[2] -= 1;
			if (l[3] == 4)
			{
				// IPv4
				IPLG 0 0 90 c2 Source IP Addr:;
				IPLG 0 0 90 c2 Dest IP Addr:;
				DWRD 0 0 90 c2 Source Port:;
				DWRD 0 0 90 c2 Dest Port:;
				DBYT 0 0 90 c2 DSCP:;
				DBYT 0 0 90 c2 Protocol:;
				DBYT 0 0 90 c2 Reserved:;
				g[2] -= 15;
			}
			if (l[3] == 6)
			{
				// IPv6
				IPV6 0 0 90 c2 Source IP Addr:;
				IPV6 0 0 90 c2 Dest IP Addr:;
				DWRD 0 0 90 c2 Source Port:;
				DWRD 0 0 90 c2 Dest Port:;
				DEC# 3 0 90 c2 Flow Label:;
				g[2] -= 39;
			}
		}
		if (l[1] == 2)
		{
			DWRD 0 0 90 c2 802.1Q Tag Type:;
			g[2] -= 2;
		}
		LABL 0 0 0 c8;
	}
}
//------------------------------------------------------

void 802_11::IE_Type_15;			//schedule element
	DWRD 0 1 90 c9 Schedule Info:;
		LABL 0 00 00 d4 xxxxxxxx x....... Reserved;
		l[1] = g[1];
		ANDG 60 41;
		SHFR 5 41;
		CST# 0 41 00 d4 802_11::IE_Type_15::ScheduleInfo::Direction;
		CLSE 0 00 00 d4 ........ ........ .00..... Direction: Uplink;
		l[1] = g[1];
		ANDG 1e 41;
		SHFR 1 41;
		CST# 0 41 00 d4 802_11::IE_Type_15::ScheduleInfo::TSID;
		CLSE 0 00 00 d4 ........ ...0000. TSID: 0;
		CBIT 0 01 00 d4 ........ .......1 Aggregation: Schedule is an Aggreate Schedule;
		CLSE 0 01 00 d4 ........ .......0 Aggregation: Schedule is NOT an Aggreate Schedule;
		LABL 0 0 00 c8;
	DLNG 0 0 90 c2 Service Start Time:;
	LABL 0 0 00 14 microseconds;
	DLNG 0 0 90 c2 Service Interval:;
	LABL 0 0 00 14 microseconds;
	DWRD 0 0 90 c2 Specification Interval:;
	g[2] -= 12;
	TRTS;

str# 802_11::IE_Type_15::ScheduleInfo::Direction;
	........ .01..... Direction: Downlink;
	........ .10..... Direction: Reserved;
	........ .11..... Direction: Bi-directional;

str# 802_11::IE_Type_15::ScheduleInfo::TSID;
	........ ...0001. TSID: 1;
	........ ...0010. TSID: 2;
	........ ...0011. TSID: 3;
	........ ...0100. TSID: 4;
	........ ...0101. TSID: 5;
	........ ...0110. TSID: 6;
	........ ...0111. TSID: 7;
	........ ...1000. TSID: 8;
	........ ...1001. TSID: 9;
	........ ...1010. TSID: 10;
	........ ...1011. TSID: 11;
	........ ...1100. TSID: 12;
	........ ...1101. TSID: 13;
	........ ...1110. TSID: 14;
	........ ...1111. TSID: 15;


//------------------------------------------------------

void 802_11::Challenge_Text;			//Type 19
	CHR# 0 2 90 c2 Challenge Text:;
	g[2] -= g[2];
	TRTS;

//------------------------------------------------------
void 802_11::IE_Type_32;			//power constraint
	DBYT 0 0 90 c2 Local Power Constraint:;
	LABL 0 0 0 14 dB;
	g[2] -= 1;
	TRTS;

//------------------------------------------------------

void 802_11::IE_Type_33;			//power capability
	DBYT 80000000 0 90 c2 Min Transmit Power Cap:;
	LABL 0 0 0 14 dBm;
	DBYT 80000000 0 90 c2 Max Transmit Power Cap:;
	LABL 0 0 0 14 dBm;
	g[2] -= 2;
	TRTS;

//------------------------------------------------------

void 802_11::IE_Type_34;			//tpc request
	TRTS;							//si: nothing in this one

//------------------------------------------------------

void 802_11::IE_Type_35;			//tpc report
	DBYT 80000000 0 90 c2 Transmit Power:;
	LABL 0 0 0 14 dBm;
	DBYT 80000000 0 90 c2 Link Margin:;
	LABL 0 0 0 14 dBm;
	g[2] -= 2;
	TRTS;

//------------------------------------------------------

void 802_11::IE_Type_36;			//supported channels
	while (g[2] >= 2)
	{
		DBYT 0 0 90 c2 First Channel #:;
		DBYT 0 0 90 c2 Num of Channels:;
		g[2] -= 2;
	}
	//si: eh?
	if (g[2] > 0)
	{
		DBYT 0 0 90 c2 Subchannel:;
		DBYT 0 0 90 c2 Num of Channels:;
		g[2] -= 2;
	}
	TRTS;

//------------------------------------------------------

void 802_11::IE_Type_37;			//channel switch announcement
	DBYT 0 1 90 c2 Channel Switch Mode:;
	CEQU 0 1 00 14 No requirements on the receiving STA;
	CEQU 1 1 00 14 STA in a BSS;
	DBYT 0 0 90 c2 New Channel Num:;
	DBYT 0 0 90 c2 Channel Switch Cnt:;
	TRTS;

//------------------------------------------------------

void 802_11::IE_Type_38;			//measurement request
	DBYT 0 1 90 c2 Measurement Token:;
	BBYT 0 1 90 c9 Measurement Rqst Mode:;
	 LABL 0 0 00 d4 xxx. .... Reserved;	
	 CBIT 4 1 00 d4 ...1 .... Duration Mandatory is contained;
	 CLSE 0 0 00 d4 ...0 .... Duration Mandatory is not contained;	 
	 CBIT 3 1 00 d4 .... 1... Report;
	 CLSE 0 0 00 d4 .... 0... Not Report;
	 CBIT 2 1 00 d4 .... .1.. Request;
	 CLSE 0 0 00 d4 .... .0.. Not Request;
	 CBIT 1 1 00 d4 .... ..1. Enable;
	 CLSE 0 0 00 d4 .... ..0. Not Enable;
	 CBIT 0 1 00 d4 .... ...1 Parallel;
	 CLSE 0 0 00 d4 .... ...0 Not Parallel;
	 LABL 0 0 00 c8;
	DBYT 0 5 90 c2 Measurement Type:;
	g[2] -= 3;
	CST# 0 5 00 14 802_11::IE_Type_38::Measurement_Type;	
	TSB# 0 5 00 0 802_11::IE_Type_38::Measurement_Type::Call;
	
void 802_11::IE_Type_38::Measurement_Type::Beacon_request()
{
	DBYT 0 41 90 c2 Regulatory Class:;
	DBYT 0 42 90 c2 Channel Number:;
	DWRD 0 43 90 c2 Randomization Interval:;
	DWRD 0 44 90 c2 Measurement Duration:;
	DWRD 0 45 90 c2 Measurement Mode:;
	ETHR 0 0 90 c2 BSSID:;
	g[2] -= 14;
	if(g[2] >= 2)
	{
		LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
			while(g[2] != 0)
			{
				DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
				
					CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS3 );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
				g[2] -= 2;
				g[44] = g[2];
				g[2] = g[22];
				TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS3::CALL );
				g[2] = g[44];
				g[2] -= g[22];
			}
		 LABL 0 0 00 c8;
	}
}

str# 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS3;
0	|	SSID;
1	|	Beacon Reporting Information;
2	|	Reporting Detail;
3	|	Request;
51	|	AP Channel Report;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS3::CALL;
0	|	802_11::IE_SSID;
1	|	802_11::IE_Type_38::OPTIONAL_SUBELEMENTS::Beacon_Reporting_Information;
2	|	802_11::IE_Type_38::OPTIONAL_SUBELEMENTS::Reporting_Detail;
51	|	802_11::IE_AP_Channel_Report;
221	|	802_11::IE_Type_221;

void 802_11::IE_Type_38::OPTIONAL_SUBELEMENTS::Beacon_Reporting_Information()
{
	DBYT 0 41 90 c2 Reporting Detail:;
		CST# 0 41 0 14 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS::Beacon_Reporting_Information;
		CLSE 0 0 0 14 Reserved;
	DBYT 0 42 90 c2 Threshold/Offset Reference Value:;		
	g[2] -= 2;
}
void 802_11::IE_Type_38::OPTIONAL_SUBELEMENTS::Reporting_Detail()
{
	DBYT 0 41 90 c2 Reporting Detail:;
		CST# 0 41 0 14 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS::Reporting_Detail;
		CLSE 0 0 0 14 Reserved;
	g[2] -= 1;
}

str# 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS::Reporting_Detail;
0	|	No fixed length fields or elements;
1	|	All fixed length fields and any requested elements in the Request information element if present;
2	|	All fixed length fields and elements (default, used when Reporting Detail subelement is not included in Beacon Request);

str# 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS::Beacon_Reporting_Information;
0	|	Report to be issued after each measurement (default);
1	|	The measured RCPI level is greater than the threshold indicated in the Threshold/Offset Reference Value;
2	|	The measured RCPI level is less the threshold indicated in the Threshold/Offset Reference Value;
3	|	The measured RSNI level is greater than the threshold indicated in the Threshold/Offset Reference Value;
4	|	The measured RSNI level is less than the threshold indicated in the Threshold/Offset Reference Value;
5	|	The measured RCPI level is greater than a threshold defined by an offset from the serving AP's reference RCPI, where the offset is indicated in the Threshold/Offset Reference Value;
6	|	The measured RCPI level is less than a threshold defined by an offset from the serving AP's reference RCPI, where the offset is indicated in the Threshold/Offset Reference Value;
7	|	The measured RSNI level is greater than a threshold defined by an offset from the serving AP's reference RSNI, where the offset is indicated in the Threshold/Offset Reference Value;
8	|	The measured RSNI level is less than a threshold defined by an offset from the serving AP's reference RSNI, where the offset is indicated in the Threshold/Offset Reference Value;
9	|	The measured RCPI level is in a range bound by the serving AP's reference RCPI and an offset from the serving AP's reference RCPI, where the offset is indicated in the Threshold/Offset Reference Value;
10	|	The measured RSNI level is in a range bound by the serving AP's reference RSNI and an offset from the serving AP's reference RSNI, where the offset is indicated in the Threshold/Offset Reference Value;

void 802_11::IE_Type_38::Measurement_Type::Basic_Request()
{
	DBYT 0 0 90 c2 Channel Num:;
	HEX# 8 0 90 c2 Measurement Start Time:;
	DWRD 0 0 90 c2 Measurement Duration:;
	g[2] -= 11;
}

void 802_11::IE_Type_38::Measurement_Type::Channel_load_request()
{
	DBYT 0 41 90 c2 Operating Class:;
	DBYT 0 42 90 c2 Channel Number:;
	DWRD 0 43 90 c2 Randomization Interval:;
	DWRD 0 44 90 c2 Measurement Duration:;
	g[2] -= 6;
	if(g[2] >= 2)
	{
		LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
			while(g[2] != 0)
			{
				DBYT( 0, l[5], 0x90, 0xc2, "Subelement ID:" );
				
					CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
				g[2] -= 2;
				g[44] = g[2];
				g[2] = g[22];
				TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS::CALL );
				g[2] = g[44];
				g[2] -= g[22];
			}
		 LABL 0 0 00 c8;
	}
}

str# 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS;
1	|	Channel Load Reporting Information;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS::CALL;
1	|	802_11::IE_TYPE_38::Channel_Load_Reporting_Information;
221	|	802_11::IE_Type_221;

void 802_11::IE_TYPE_38::Channel_Load_Reporting_Information()
{
	DBYT 0 41 90 c2 Reporting Condition:;
		CST# 0 41 00 14 802_11::IE_Type_38::Measurement_Type::Reporting_Condition;
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT 0 42 90 c2 Channel Load Reference Value:;
	g[2] -= 2;
}

void 802_11::IE_TYPE_38::Noise_Histogram_Request()
{
	DBYT 0 41 90 c2 Regulatory Class:;
	DBYT 0 42 90 c2 Channel Number:;
	DWRD 0 43 90 c2 Randomization Interval:;
	DWRD 0 44 90 c2 Measurement Duration:;
	g[2] -= 6;
	if(g[2] >= 2)
	{
		LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
			while(g[2] != 0)
			{
				DBYT( 0, l[5], 0x90, 0xc2, "Subelement ID:" );
				
					CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS2 );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
				g[2] -= 2;
				g[44] = g[2];
				g[2] = g[22];
				TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS2::CALL );
				g[2] = g[44];
				g[2] -= g[22];
			}
		 LABL 0 0 00 c8;
	}
}

str# 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS2;
1	|	Noise Histogram Reporting Information;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_38::OPTIONAL_SUBELEMENTS2::CALL;
1	|	802_11::IE_TYPE_38::Noise_Histogram_Reporting_Information;
221	|	802_11::IE_Type_221;

void 802_11::IE_TYPE_38::Noise_Histogram_Reporting_Information()
{
	DBYT 0 41 90 c2 Reporting Condition:;
		CST# 0 41 00 14 802_11::IE_Type_38::Noise_Histogram_Reporting_Information::Reporting_Condition;
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT 0 42 90 c2 ANPI Reference Value:;
	g[2] -= 2;
}

str#  802_11::IE_Type_38::Noise_Histogram_Reporting_Information::Reporting_Condition;
0	|	Report to be issued after each measuremen;
1	|	Noise Histogram Report to be issued when measured ANPI is equal to or greater than the reference value;
2	|	Noise Histogram Report to be issued when measured ANPI is equal to or less than the reference value;

str# 802_11::IE_Type_38::Measurement_Type::Reporting_Condition;
0	|	Report to be issued after each measuremen;
1	|	Report to be issued when measured Channel Load is equal to or greater than the reference value;
2	|	Report to be issued when measured Channel Load is equal to or less than the reference value;

void 802_11::IE_TYPE_38::Frame_request()
{
	DBYT 0 41 90 c2 Regulatory Class:;
	DBYT 0 42 90 c2 Channel Number:;
	DWRD 0 43 90 c2 Randomization Interval:;
	DWRD 0 44 90 c2 Measurement Duration:;
	DBYT 0 45 90 c2 Frame Request Type:;
	ETHR 0 46 90 c2 MAC Address:;
	g[2] -= 13;
	if(g[2] >= 2)
	{
		LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
			while(g[2] != 0)
			{
				DBYT( 0, l[5], 0x90, 0xc2, "Subelement ID:" );
				
					CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::Frame_request::OPTIONAL_SUBELEMENTS2 );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
				g[2] -= 2;
				g[44] = g[2];
				g[2] = g[22];
				TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::Frame_request::OPTIONAL_SUBELEMENTS2::CALL );
				g[2] = g[44];
				g[2] -= g[22];
			}
		 LABL 0 0 00 c8;
	}
}

str# 802_11::IE_TYPE_38::Frame_request::OPTIONAL_SUBELEMENTS2;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_38::Frame_request::OPTIONAL_SUBELEMENTS2::CALL;
221	|	802_11::IE_Type_221;

void 802_11::IE_TYPE_38::Measurement_Type::STA_statistics_request()
{
	ETHR 0 41 90 c2 MAC Address:;
	DWRD 0 42 90 c2 Randomization Interval:;
	DWRD 0 43 90 c2 Measurement Duration:;
	DBYT 0 44 90 c2 Group Identity:;
		CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::STA_statistics_request::Group_Identity );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	g[2] -= 11;
	if(g[2] >= 2)
	{
		LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:");
			while(g[2] != 0)
			{
				DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
				
					CST#( 0, l[2], 0, 0x14, 802_11::IE_TYPE_38::STA_statistics_request::OPTIONAL_SUBELEMENTS );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
				g[2] -= 2;
				g[44] = g[2];
				g[2] = g[22];
				TSB#( 0, l[2], 0, 0x14, 802_11::IE_TYPE_38::STA_statistics_request::OPTIONAL_SUBELEMENTS::CALL );
				g[2] = g[44];
				g[2] -= g[22];
			}
		 LABL 0 0 00 c8;
	}
}

str# 802_11::IE_TYPE_38::STA_statistics_request::OPTIONAL_SUBELEMENTS;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_38::STA_statistics_request::OPTIONAL_SUBELEMENTS::CALL;
221	|	802_11::IE_Type_221;

str# 802_11::IE_TYPE_38::STA_statistics_request::Group_Identity;
0	|	STA Counters from dot11CountersTable;
1	|	STA Counters from dot11MacStatistics group;
2	|	QoS STA Counters for UP0 from dot11QosCountersTable;
3	|	QoS STA Counters for UP1 from dot11QosCountersTable;
4	|	QoS STA Counters for UP2 from dot11QosCountersTable;
5	|	QoS STA Counters for UP3 from dot11QosCountersTable;
6	|	QoS STA Counters for UP4 from dot11QosCountersTable;
7	|	QoS STA Counters for UP5 from dot11QosCountersTable;
8	|	QoS STA Counters for UP6 from dot11QosCountersTable;
9	|	QoS STA Counters for UP7 from dot11QosCountersTable;
10	|	BSS Average Access Delays;

void 802_11::IE_TYPE_38::Measurement_Type::LCI_request()
{
	DBYT 0 41 90 c2 Location Subject:;
		CST#( 0, l[2], 0, 0x14, 802_11::IE_TYPE_38::Measurement_Type::LCI_request::Location_Subject );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT 0 42 90 c2 Latitude Requested Resolution:;
	DBYT 0 43 90 c2 Longitude Requested Resolution:;
	DBYT 0 44 90 c2 Altitude Requested Resolution:;
		
	g[2] -= 4;
	if(g[2] >= 2)
	{
		LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
			while(g[2] != 0)
			{
				DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
				
					CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::Measurement_Type::LCI_request::OPTIONAL_SUBELEMENTS );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
				g[2] -= 2;
				g[44] = g[2];
				g[2] = g[22];
				TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::Measurement_Type::LCI_request::OPTIONAL_SUBELEMENTS::CALL );
				g[2] = g[44];
				g[2] -= g[22];
			}
		 LABL 0 0 00 c8;
	}
}

str# 802_11::IE_TYPE_38::Measurement_Type::LCI_request::Location_Subject;
0	|	LCI Subject Local;
1	|	LCI Subject Remote;

str# 802_11::IE_TYPE_38::Measurement_Type::LCI_request::OPTIONAL_SUBELEMENTS;
1	|	Azimuth Request;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_38::Measurement_Type::LCI_request::OPTIONAL_SUBELEMENTS::CALL;
1	|	802_11::IE_TYPE_38::Measurement_Type::Azimuth_Request;
221	|	802_11::IE_Type_221;

void 802_11::IE_TYPE_38::Measurement_Type::Azimuth_Request()
{
	BBYT( 0, l[2], 0x90, 0xc2, "Azimuth Request:" );
}

void 802_11::IE_TYPE_38::Measurement_Type::Transmit_stream_category_measurement_request()
{
	DWRD 0 43 90 c2 Randomization Interval:;
	DWRD 0 44 90 c2 Measurement Duration:;
	ETHR 0 45 90 c2 Peer STA Address;
	DBYT 0 46 90 c2 Traffic Identifier:;
	DECR 1;
	BBIT 4 48 90 c2 Reserved:;
	BBIT 4 49 90 c2 TID:;
	DBYT 0 47 90 c2 Bin 0 Range:;
	g[2] -= 12;
	if(g[2] >= 2)
	{
		LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
			while(g[2] != 0)
			{
				DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
				
					CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::Transmit_stream_category_measurement_request::OPTIONAL_SUBELEMENTS );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
				g[2] -= 2;
				g[44] = g[2];
				g[2] = g[22];
				TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::Transmit_stream_category_measurement_request::OPTIONAL_SUBELEMENTS::CALL );
				g[2] = g[44];
				g[2] -= g[22];
			}
		 LABL 0 0 00 c8;
	}
}
str# 802_11::IE_TYPE_38::Transmit_stream_category_measurement_request::OPTIONAL_SUBELEMENTS;
1	|	Triggered Reporting;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_38::Transmit_stream_category_measurement_request::OPTIONAL_SUBELEMENTS::CALL;
1	|	802_11::IE_TYPE_38::Measurement_Type::Triggered_Reporting;
221	|	802_11::IE_Type_221;

void 802_11::IE_TYPE_38::Measurement_Type::Triggered_Reporting()
{
	BBYT( 0, l[2], 0x90, 0xc9, "Trigger Conditions:" );
	DECR 1;
		BBIT 1 48 90 c2 Average:;
		BBIT 1 48 90 c2 Consecutive:;
		BBIT 1 48 90 c2 Delay:;
		BBIT 5 49 90 c2 Reserved:;
	LABL 0 0 00 c8;
	DBYT( 0, l[3], 0x90, 0xc2, "Average Error Threshold:" );
	DBYT( 0, l[4], 0x90, 0xc2, "Consecutive Error Threshold:" );
	DBYT( 0, l[5], 0x90, 0xc2, "Delay Threshold:" );
	DECR 1;
		DBIT( 2, l[6], 0x90, 0xc2, "Delayed MSDU Range:" );
			CST#( 0, l[6], 0, 0x14, 802_11::IE_Type_38::Measurement_Type::Triggered_Reporting::Delayed_MSDU_Range );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBIT 6 49 90 c2 Delayed MSDU Count:;
	LABL 0 0 00 c8;
	DBYT( 0, l[7], 0x90, 0xc2, "Measurement Count:" );
	DBYT( 0, l[8], 0x90, 0xc2, "Trigger Time-out:" );
}

str# 802_11::IE_Type_38::Measurement_Type::Triggered_Reporting::Delayed_MSDU_Range;
0	|	Transmit Delay = Lower Bound of Bin 2;
1	|	Transmit Delay = Lower Bound of Bin 3;
2	|	Transmit Delay = Lower Bound of Bin 4;
3	|	Transmit Delay = Lower Bound of Bin 5;

void 802_11::IE_Type_38::Measurement_Type::Measurement_Pause_request()
{
	DWRD( 0x40000000, l[2], 0x90, 0xc9, "Pause Time:" );
	g[2] -= 2;
	if(g[2] >= 2)
	{
		LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
			while(g[2] != 0)
			{
				DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
				
					CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::Measurement_Type::Measurement_Pause_request::OPTIONAL_SUBELEMENTS );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
				g[2] -= 2;
				g[44] = g[2];
				g[2] = g[22];
				TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_38::Measurement_Type::Measurement_Pause_request::OPTIONAL_SUBELEMENTS::CALL );
				g[2] = g[44];
				g[2] -= g[22];
			}
		 LABL 0 0 00 c8;
	}
}

str# 802_11::IE_TYPE_38::Measurement_Type::Measurement_Pause_request::OPTIONAL_SUBELEMENTS;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_38::Measurement_Type::Measurement_Pause_request::OPTIONAL_SUBELEMENTS::CALL;
221	|	802_11::IE_Type_221;

str# 802_11::IE_Type_38::Measurement_Type::Call;
0 | 802_11::IE_Type_38::Measurement_Type::Basic_Request;
1 | 802_11::IE_Type_38::Measurement_Type::Basic_Request;
2 | 802_11::IE_Type_38::Measurement_Type::Basic_Request;
3 | 802_11::IE_Type_38::Measurement_Type::Channel_load_request;
4 | 802_11::IE_Type_38::Measurement_Type::Noise_Histogram_Request;
5 |	802_11::IE_Type_38::Measurement_Type::Beacon_request;
6 |	802_11::IE_Type_38::Measurement_Type::Frame_request;
7 |	802_11::IE_Type_38::Measurement_Type::STA_statistics_request;
8 |	802_11::IE_Type_38::Measurement_Type::LCI_request;
9 | 802_11::IE_Type_38::Measurement_Type::Transmit_stream_category_measurement_request;
255	| 802_11::IE_Type_38::Measurement_Type::Measurement_Pause_request;
	
str# 802_11::IE_Type_38::Measurement_Type;
	0 | Basic Request;
	1 | Clear Channel Assessment Request;
	2 | Receive Power Indication Histogram Request;
	3 | Channel load request;
	4 | Noise histogram request;
	5 |	Beacon request;
	6 |	Frame request;
	7 |	STA statistics request;
	8 |	LCI request;
	9 | Transmit stream/category measurement request;
	255 | Measurement Pause request;
//------------------------------------------------------

void 802_11::IE_Type_39;			//measurement report
	DBYT 0 0 90 c2 Measurement Token:;
	BBYT 0 1 90 c9 Measurement Report Mode:;
	 LABL 0 0 00 d4 xxxx x... Reserved;
	 CBIT 2 1 00 d4 .... .1.. Refused;
	 CLSE 0 0 00 d4 .... .0.. Not Refused;
	 CBIT 1 1 00 d4 .... ..1. Incapable;
	 CLSE 0 0 00 d4 .... ..0. Capable;
	 CBIT 0 1 00 d4 .... ...1 Late;
	 CLSE 0 0 00 d4 .... ...0 Not Late;
	 LABL 0 0 00 c8;
	DBYT 0 5 90 c2 Measurement Type:;
	CST# 0 5 00 14 802_11::IE_Type_39::Measurement_Type;
	g[2] -= 3;
	if (g[5] == 0)
	{
		DBYT 0 0 90 c2 Channel Num:;
		HEX# 8 0 90 c2 Measurement Start Time:;
		DWRD 0 0 90 c2 Measurement Duration:;
		BBYT 0 1 90 c9 Map:;
		 LABL 0 0 00 d4 xxx. .... Reserved;
		 CBIT 0 1 00 d4 ...1 .... Unmeasured: This channel has not been measured;
		 CLSE 0 0 00 d4 ...0 .... Unmeasured: This channel has been measured;
		 CBIT 0 1 00 d4 .... 1... Radar: Radar was detected operating;
		 CLSE 0 0 00 d4 .... 0... Radar: Radar was not detected operating;
		 CBIT 0 1 00 d4 .... .1.. Unidentified Signal: True;
		 CLSE 0 0 00 d4 .... .0.. Unidentified Signal: False;
		 CBIT 0 1 00 d4 .... ..1. OFDM: Sequence of short training symbols detected;
		 CLSE 0 0 00 d4 .... ..0. OFDM: Sequence of short training symbols not detected;
		 CBIT 0 1 00 d4 .... ...1 BSS: At least one valid MPDU received;
		 CLSE 0 0 00 d4 .... ...0 BSS: No valid MPDU's received;
		g[2] -= 12;
	}
	if (g[5] == 1)
	{
		DBYT 0 0 90 c2 Channel Num:;
		HEX# 8 0 90 c2 Measurement Start Time:;
		DWRD 0 0 90 c2 Measurement Duration:;
		DBYT 0 0 90 c2 CCA Busy Fraction:;
		g[2] -= 12;
	}
	if (g[5] == 2)
	{
		DBYT 0 0 90 c2 Channel Num:;
		HEX# 8 0 90 c2 Measurement Start Time:;
		DWRD 0 0 90 c2 Measurement Duration:;
		g[2] -= 11;
		if (g[2] >= 8)
		{
			DBYT 0 0 90 c2 RPI 0 Density:;
			DBYT 0 0 90 c2 RPI 1 Density:;
			DBYT 0 0 90 c2 RPI 2 Density:;
			DBYT 0 0 90 c2 RPI 3 Density:;
			DBYT 0 0 90 c2 RPI 4 Density:;
			DBYT 0 0 90 c2 RPI 5 Density:;
			DBYT 0 0 90 c2 RPI 6 Density:;
			DBYT 0 0 90 c2 RPI 7 Density:;
			g[2] -= 8;
		}
		if (g[2] > 0)
		{
			DUMP 0 2 90 c2 Value:;
		}
	}
	if (g[5] == 3)
	{
		DBYT 0 41 90 c2 Operating Class:;
		DBYT 0 42 90 c2 Channel Number:;
		D64B 0 43 90 c2 Actual Measurement Start Time:;
		DWRD 0 44 90 c2 Measurement Duration:;
		DBYT 0 42 90 c2 Channel Load:;
		g[2] -= 13;
			if(g[2] >= 2)
			{
				LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
					while(g[2] != 0)
					{
						DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
						
							CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::3::Channel Load Report::OPTIONAL_SUBELEMENTS );
							CLSE( 0, 0, 0, 0x14, "Reserved" );
						DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
						g[2] -= 2;
						g[44] = g[2];
						g[2] = g[22];
						TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::3::Channel Load Report::OPTIONAL_SUBELEMENTS::CALL );
						g[2] = g[44];
						g[2] -= g[22];
					}
				 LABL 0 0 00 c8;
			}
	}	
	if (g[5] == 4)
	{
		DBYT 0 41 90 c2 Operating Class:;
		DBYT 0 42 90 c2 Channel Number:;
		D64B 0 43 90 c2 Actual Measurement Start Time:;
		DWRD 0 44 90 c2 Measurement Duration:;
		DBYT 0 45 90 c2 Antenna ID:;
		DBYT 0 46 90 c2 ANPI:;
		DBYT 0 47 90 c2 IPI 0 Density:;
		DBYT 0 48 90 c2 IPI 1 Density:;
		DBYT 0 49 90 c2 IPI 2 Density:;
		DBYT 0 50 90 c2 IPI 3 Density:;
		DBYT 0 51 90 c2 IPI 4 Density:;
		DBYT 0 52 90 c2 IPI 5 Density:;
		DBYT 0 53 90 c2 IPI 6 Density:;
		DBYT 0 54 90 c2 IPI 7 Density:;
		DBYT 0 55 90 c2 IPI 8 Density:;
		DBYT 0 56 90 c2 IPI 9 Density:;
		DBYT 0 57 90 c2 IPI 10 Density:;
		g[2] -= 25;
			if(g[2] >= 2)
			{
				LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
					while(g[2] != 0)
					{
						DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
						
							CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::4::OPTIONAL_SUBELEMENTS );
							CLSE( 0, 0, 0, 0x14, "Reserved" );
						DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
						g[2] -= 2;
						g[44] = g[2];
						g[2] = g[22];
						TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::4::OPTIONAL_SUBELEMENTS::CALL );
						g[2] = g[44];
						g[2] -= g[22];
					}
				 LABL 0 0 00 c8;
			}
	}
	if (g[5] == 5)
	{
		DBYT 0 41 90 c2 Regulatory Class:;
		DBYT 0 42 90 c2 Channel Number:;
		D64B 0 43 90 c2 Actual Measurement Start Time:;

		* Original: DWRD 0 44 90 c2 Measurement Duration:;
		* SamChen:  Set the 2nd high bit -0100- to perform byte swap
		DWRD( 0x40000000, l[44], 0x90, 0xc2, "Measurement Duration:" );

		* SamChen:  Conversion from IEEE TU to absolute time domain
		l[44] *= 1024;

		if (l[44] <= 1000000)
		{
			l[42] = 0;
			l[42] = l[44];
			l[44] /= 1000;
			DGLB( 0, l[44], 0x04, 0, "   " );
			LABL( 0, 0, 0, 0x04, " Milli-seconds, and " );
			l[44] *= 1000;
			l[42] -= l[44];
			DGLB( 0, l[42], 0x04, 0 );
			LABL( 0, 0, 0, 0x04, " Micro-seconds" );
		}

		if (l[44] > 1000000)
		{
			LABL( 0, 0, 0, 0x04, "~" );
			l[44] /= 1000000;
			DGLB( 0x40000000, l[44], 0x04, 0 );
			LABL( 0, 0, 0, 0x04, " Seconds" );
		}
		* SamChen:  Conversion completed

		DBYT 0 45 90 c2 Reported Frame Information:;
		DBYT 0 46 90 c2 RCPI:;
		DBYT 0 47 90 c2 RSNI:;
		ETHR 0 0 90 c2 BSSID:;
		DBYT 0 48 90 c2 Antenna ID:;
		DLNG 0 49 90 c2 Parent TSF:;
		g[2] -= 26;
		if (g[2] != 0)
		{
			DBYT 0 51 90 c2 TYPE:;
			DBYT 0 52 90 c2 Length:;
			// DUMP 0 53 90 c2 BLOCK:;
			// DECR l[13];
			DGLB 0 51 90 c2 TYPE:;
			if(l[2] == 1)
			{
				LABL( 0, 0, 0, 0xb1, "Reported Frame Body:" ); 
				//LABL( 0, 0, 0, 0xc9);	
				802_11::Main2;
			}
			if(l[2] == 221)
			{
				802_11::IE_Type_221;
			}
		}
	}
	if (g[5] == 6)
	{
		DBYT 0 41 90 c2 Operating Class:;
		DBYT 0 42 90 c2 Channel Number:;
		D64B 0 43 90 c2 Actual Measurement Start Time:;
		DWRD 0 44 90 c2 Measurement Duration:;
		g[2] -= 12;
			if(g[2] >= 2)
			{
				LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
					while(g[2] != 0)
					{
						DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
						
							CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::6::OPTIONAL_SUBELEMENTS );
							CLSE( 0, 0, 0, 0x14, "Reserved" );
						DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
						g[2] -= 2;
						g[44] = g[2];
						g[2] = g[22];
						TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::6::OPTIONAL_SUBELEMENTS::CALL );
						g[2] = g[44];
						g[2] -= g[22];
					}
				 LABL 0 0 00 c8;
			}
	}
	if (g[5] == 7)
	{
		DWRD( 0x40000000, l[1], 0x90, 0xc2, "Measurement Duration:" );
		DBYT( 0, l[2], 0x90, 0xc2, "Group Identity:" );
		g[2] -= 2;
		if (l[2] == 0)
		{
			DUMP( 0, 28, 0x90, 0xc2, "Statistics Group Data field:" );
			g[2] -= 28;
		}
		if (l[2] == 1)
		{
			DUMP( 0, 24, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 24;
		}
		if (l[2] == 2)
		{
			DUMP( 0, 52, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 52;
		}
		if (l[2] == 3)
		{
			DUMP( 0, 52, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 52;	
		}
		if (l[2] == 4)
		{
			DUMP( 0, 52, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 52;		
		}
		if (l[2] == 5)
		{
			DUMP( 0, 52, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 52;		
		}
		if (l[2] == 6)
		{
			DUMP( 0, 52, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 52;		
		}
		if (l[2] == 7)
		{
			DUMP( 0, 52, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 52;		
		}
		if (l[2] == 8)
		{
			DUMP( 0, 52, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 52;		
		}
		if (l[2] == 9)
		{
			DUMP( 0, 52, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 52;		
		}
		if (l[2] == 10)
		{
			DUMP( 0, 7, 0x90, 0xc2, "Statistics Group Data field:" );g[2] -= 7;		
		}
		if(g[2] >= 2)
			{
				LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
					while(g[2] != 0)
					{
						DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
						
							CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::7::OPTIONAL_SUBELEMENTS );
							CLSE( 0, 0, 0, 0x14, "Reserved" );
						DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
						g[2] -= 2;
						g[44] = g[2];
						g[2] = g[22];
						TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::7::OPTIONAL_SUBELEMENTS::CALL );
						g[2] = g[44];
						g[2] -= g[22];
					}
				 LABL 0 0 00 c8;
			}
	}
	if (g[5] == 8)
	{
 		DBIT( 6, l[1], 0x90, 0xc2, "Latitude Resolution:" );
		HBIT( 25, l[2], 0x90, 0xc2, "Latitude Fraction:" );
		DBIT( 9, l[3], 0x90, 0xc2, "Latitude Integer:" );
		DBIT( 6, l[4], 0x90, 0xc2, "Latitude Resolution:" );
		HBIT( 25, l[5], 0x90, 0xc2, "Latitude Fraction:" );
		DBIT( 9, l[6], 0x90, 0xc2, "Latitude Integer:" );
		DBIT( 4, l[7], 0x90, 0xc2, "Altitude Type:" );
		DBIT( 6, l[8], 0x90, 0xc2, "Altitude Resolution:" );
		DBIT( 8, l[9], 0x90, 0xc2, "Altitude Fraction:" );
		DBIT( 22, l[10], 0x90, 0xc2, "Altitude Integer:" );
		DBYT( 8, l[11], 0x90, 0xc2, "Datum:" ); 
		g[2] -= 18;	
			if(g[2] >= 2)
			{
				LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
					while(g[2] != 0)
					{
						DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
						
							CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::8::OPTIONAL_SUBELEMENTS );
							CLSE( 0, 0, 0, 0x14, "Reserved" );
						DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
						g[2] -= 2;
						g[44] = g[2];
						g[2] = g[22];
						TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::8::OPTIONAL_SUBELEMENTS::CALL );
						g[2] = g[44];
						g[2] -= g[22];
					}
				 LABL 0 0 00 c8;
			}
	}
	if (g[5] == 9)
	{
		D64B( 0x40000000, l[1], 0x90, 0xc2, "Actual Measurement Start Time:" );
		DWRD( 0x40000000, l[2], 0x90, 0xc2, "Measurement Duration:" );
		ETHR( 0, l[3], 0x90, 0xc2, "Peer STA Address:" );
		DBYT( 0, l[4], 0x90, 0xc2, "Traffic Identifier:" );
		DBYT( 0, l[5], 0x90, 0xc2, "Reporting Reason:" );
		DLNG( 0x40000000, l[6], 0x90, 0xc2, "Transmitted MSDU Count:" );
		DLNG( 0x40000000, l[7], 0x90, 0xc2, "MSDU Discarded Count:" );
		DLNG( 0x40000000, l[8], 0x90, 0xc2, "MSDU Failed Count:" );
		DLNG( 0x40000000, l[9], 0x90, 0xc2, "MSDU Multiple Retry Count:" );
		DLNG( 0x40000000, l[10], 0x90, 0xc2, "QoS CF-Polls Lost Count:" );
		DLNG( 0x40000000, l[11], 0x90, 0xc2, "Average Queue Delay:" );
		DLNG( 0x40000000, l[12], 0x90, 0xc2, "Average Transmit Delay:" );
		DBYT( 0x40000000, l[13], 0x90, 0xc2, "Bin 0 Range:" );
		DLNG( 0x40000000, l[12], 0x90, 0xc2, "Bin 0:" );
		DLNG( 0x40000000, l[12], 0x90, 0xc2, "Bin 1:" );
		DLNG( 0x40000000, l[12], 0x90, 0xc2, "Bin 2:" );
		DLNG( 0x40000000, l[12], 0x90, 0xc2, "Bin 3:" );
		DLNG( 0x40000000, l[12], 0x90, 0xc2, "Bin 4:" );
		DLNG( 0x40000000, l[12], 0x90, 0xc2, "Bin 5:" );
		g[2] -= 70;	
		if(g[2] >= 2)
			{
				LABL( 0, 0, 0x90, 0xc9, "Optional Subelements:" );
					while(g[2] != 0)
					{
						DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
						
							CST#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::9::OPTIONAL_SUBELEMENTS );
							CLSE( 0, 0, 0, 0x14, "Reserved" );
						DBYT( 0, g[22], 0x90, 0xc2, "Subelement Length:" );	
						g[2] -= 2;
						g[44] = g[2];
						g[2] = g[22];
						TSB#( 0, l[5], 0, 0x14, 802_11::IE_TYPE_39::9::OPTIONAL_SUBELEMENTS::CALL );
						g[2] = g[44];
						g[2] -= g[22];
					}
				 LABL 0 0 00 c8;
			}
	}
	LABL 0 0 00 c8;


str# 802_11::IE_Type_39::Measurement_Type;
	0 | Basic Report;
	1 | CCA Report;
	2 | RPI Histogram Report;
	3 | Channel load report;
	4 | Noise histogram report;
	5 | Beacon report;
	6 | Frame report;
	7 | STA statistics report;
	8 | LCI report;
	9 | Transmit stream/category measurement report;
	255 |	Measurement Pause Request;
	
str# 802_11::IE_TYPE_39::3::Channel Load Report::OPTIONAL_SUBELEMENTS;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_39::3::Channel Load Report::OPTIONAL_SUBELEMENTS::CALL;
221	|	802_11::IE_Type_221;

str# 802_11::IE_TYPE_39::4::OPTIONAL_SUBELEMENTS;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_39::4::OPTIONAL_SUBELEMENTS::CALL;
221	|	802_11::IE_Type_221;

str# 802_11::IE_TYPE_39::6::OPTIONAL_SUBELEMENTS;
1	|	Frame Count Report;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_39::6::OPTIONAL_SUBELEMENTS::CALL;
1	|	802_11::IE_TYPE_39::6::Frame_Count_Report;
221	|	802_11::IE_Type_221;

void 802_11::IE_TYPE_39::6::Frame_Count_Report()
{
	ETHR 0 0 90 c2 MAC Address:;
	ETHR 0 0 90 c2 BSSID:;
	DBYT 0 41 90 c2 PHY Type:;
	HBYT 0 42 90 c2 Average RCPI:;
	DBYT 0 43 90 c2 Last RSNI:;
	DBYT 0 44 90 c2 Last RCPI:;
	DBYT 0 45 90 c2 Antenna ID:;
	DWRD 0 46 90 c2 Frame Count:;
}

str# 802_11::IE_TYPE_39::7::OPTIONAL_SUBELEMENTS;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_39::7::OPTIONAL_SUBELEMENTS::CALL;
221	|	802_11::IE_Type_221;

str# 802_11::IE_TYPE_39::8::OPTIONAL_SUBELEMENTS;
1	|	Azimuth Report;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_39::8::OPTIONAL_SUBELEMENTS::CALL;
1	|	802_11::IE_TYPE_39::8::Azimuth_Report;
221	|	802_11::IE_Type_221;

void 802_11::IE_TYPE_39::8::Azimuth_Report()
{
	DBIT( 2, l[1], 0x90, 0xc2, "Reserved:" );
	DBIT( 1, l[1], 0x90, 0xc2, "Azimuth Type:" );
	DBIT( 4, l[1], 0x90, 0xc2, "Azimuth Resolution:" );
	DBIT( 9, l[6], 0x90, 0xc2, "Azimuth:" );
}

str# 802_11::IE_TYPE_39::9::OPTIONAL_SUBELEMENTS;
221	|	Vendor Specific;

str# 802_11::IE_TYPE_39::9::OPTIONAL_SUBELEMENTS::CALL;
221	|	802_11::IE_Type_221;
//------------------------------------------------------

void 802_11::IE_Type_40;					//Quiet
	DBYT 0 0 90 c2 Quiet Count:;
	DBYT 0 0 90 c2 Quiet Period:;
	DWRD 40000000 0 90 c2 Quiet Duration:;
	DWRD 40000000 0 90 c2 Quiet Offset:;
	TRTS;

//------------------------------------------------------

void 802_11::IE_Type_41;					//IBSS DFS
	ETHR 0 0 90 c2 DFS Owner:;
	DBYT 0 0 90 c2 DFS Recovery Interval:;
	g[2] -= 7;
	while (g[2] >= 2)
	{
		LABL 0 0 00 b9 Channel Map;
		DBYT 0 0 90 c2 Channel Num:;
		DBYT 0 0 90 c2 Map:;
		LABL 0 0 00 b8;
		g[2] -= 2;
	}
	TRTS;

//------------------------------------------------------

void 802_11::IE_ERP()
{											//type 42
	BBYT 0 1 90 c9 ERP Flags:;
	 LABL 0 0 0 d4 x... .... Reserved;
	 LABL 0 0 0 d4 .x.. .... Reserved;
	 LABL 0 0 0 d4 ..x. .... Reserved;
	 LABL 0 0 0 d4 ...x .... Reserved;
	 LABL 0 0 0 d4 .... x... Reserved;
	 CBIT 2 1 0 d4 .... .1.. Barker Preamble Mode;
	 CLSE 0 0 0 d4 .... .0.. Not Barker Preamble Mode;
	 CBIT 1 1 0 d4 .... ..1. Use Protection;
	 CLSE 0 0 0 d4 .... ..0. Disable Use of Protection;
	 CBIT 0 1 0 d4 .... ...1 Non-ERP Present;
	 CLSE 0 0 0 d4 .... ...0 Non-ERP Not Present;
	LABL 0 0 0 c8;
	g[2] -= 1;
	if (g[2] > 0)
	{
	 DUMP 0 2 90 c2 Remaining Data:;
	}
	TRTS;
}

//------------------------------------------------------

void 802_11::IE_Type_43;	
	if (g[2] == 4)
	{
		DLNG 0 0 90 c2 Delay:;
		TRTS;
	}

//------------------------------------------------------

void 802_11::IE_Type_44;	
	if (g[2] == 2)
	{
		HWRD 0 4 90 c2 Processing:;
		CEQU 0 4 00 14 Elements to be processed serially;
		CEQU 1 4 00 14 Elements to be processed in parallel;
		g[2] -= 2;
		TRTS;
	}
	if (g[2] == 1)
	{
		HBYT 0 4 90 c2 Processing:;
		CEQU 0 4 00 14 Incoming MSDUs higher-layer parameters have to match to the parameters in all the associated TCLAS elements.;
		CEQU 1 4 00 14 Incoming MSDU higher-layer parameters have to match to at least one of the associated TCLAS elements.;
		CEQU 2 4 00 14 Incoming MSDUs that do not belong to any other TS, are classified to the TS for which this TCLAS Processing element is used.;
		g[2] -= 1;
		TRTS;
	}

//------------------------------------------------------

void 802_11::IE_Type_46;						// QoS Capability
	if (g[0xa] == 0)							// management
		{
			if (g[0xe] == 0)						// association request
			{
				802_11::QoSInfo_STA();
			}
			if (g[0xe] == 1)						// association response
			{
				802_11::QoSInfo_AP();
			}
		}
	if (g[0xa] == 2)							// data
	{
		TEQU 0 C 0 0 802_11::QoSInfo_STA;		//IBSS			
		TEQU 1 C 0 0 802_11::QoSInfo_AP;		//From the AP
		TEQU 2 C 0 0 802_11::QoSInfo_STA;		//To the AP
		TEQU 3 C 0 0 802_11::QoSInfo_AP;		//Wireless DS
	}
	TRTS;
	

// QoS Info field when sent by a non-AP QSTA (33.11)
void 802_11::QoSInfo_STA()
{
	BBYT( 0, l[1], 0x90, 0xc9, "QoS Info:" );
	DECR 1;
	BBIT( 1, l[2], 0x5, 0xc9);										
		CEQU( 1, l[2], 0x0, 0x54, "1... .... More Data Ack: can process Ack frames with the More Data bit" );
		CEQU( 0, l[2], 0x0, 0x54, "0... .... More Data Ack: not Set" );
	BBIT( 2, l[2], 0x5, 0xc9);
		CEQU( 3, l[2], 0x0, 0x54, ".11. .... QAP may deliver a maximum of 6 MSDUs and MMPDUs per SP" );
		CEQU( 2, l[2], 0x0, 0x54, ".10. .... QAP may deliver a maximum of 4 MSDUs and MMPDUs per SP" );
		CEQU( 1, l[2], 0x0, 0x54, ".01. .... QAP may deliver a maximum of 2 MSDUs and MMPDUs per SP" );
		CEQU( 0, l[2], 0x0, 0x54, ".00. .... QAP may deliver all buffered MSDUs and MMPDUs" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, "...1 .... Q-Ack: dot11QAckOptionImplemented Set" );
		CEQU( 0, l[2], 0x0, 0x54, "...0 .... Q-Ack: not set" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, ".... 1... Access category: Best Effort U-APSD - Enabled" );
		CEQU( 0, l[2], 0x0, 0x54, ".... 0... Access category: Best Effort U-APSD - Disabled" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, ".... .1.. Access category: Background U-APSD - Enabled" );
		CEQU( 0, l[2], 0x0, 0x54, ".... .0.. Access category: Background U-APSD - Disabled" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, ".... ..1. Access category: Video U-APSD - Enabled" );
		CEQU( 0, l[2], 0x0, 0x54, ".... ..0. Access category: Video U-APSD - Disabled" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, ".... ...1 Access category: Voice U-APSD - Enabled" );
		CEQU( 0, l[2], 0x0, 0x54, ".... ...0 Access category: Voice U-APSD - Disabled" );
	LABL( 0, 0, 0, 0xc8);
}

// QoS Info field when sent by a QAP (33.10)
void 802_11::QoSInfo_AP()
{
	BBYT 0 1 90 c9 QoS Info:;
	CBIT 7 1 00 d4 1... .... Reserved;
	CLSE 0 0 00 d4 0... .... Reserved;
	CBIT 6 1 00 d4 .1.. .... TXOP Request: can process non-zero TXOP duration requested subfield;
	CLSE 0 0 00 d4 .0.. .... TXOP Request: not set;
	CBIT 5 1 00 d4 ..1. .... Queue Request: can process a non-zero queue size subfield;
	CLSE 0 0 00 d4 ..0. .... Queue Request: not set;
	CBIT 4 1 00 d4 ...1 .... Q-Ack: dot11QAckOptionImplemented Set;
	CLSE 0 0 00 d4 ...0 .... Q-Ack: not set;
	ANDG f 1;
	CST# 0 1 00 d4 802_11::IE_Type_12::AC_Info;
	CLSE 0 0 00 d4 .... 0000 Param Set Count: 0;
	LABL 0 0 00 c8;
}

//------------------------------------------------------

void 802_11::IE_Type_48()
{
	if (g[2] == 1)
	{
		BBYT 0 0 90 c2 QoS Info:;		//si: 802.11e
		g[2] -= 1;
		TRTS;
	}
	DWRD 40000000 1 90 c2 Version:;
	GLNG 0 41;
	HEX# 80000001 0 90 c2 Group Cipher OUI:;
	HEX# 80000001 0 90 00 -;
	HEX# 80000001 0 90 00 -;
	SHFR 8 41;
	CST# 0 41 0 24 802_11::OUI_Strings;
	DBYT 0 1 90 c2 Group Cipher Type:;
	CST# 0 1  0 14 802_11::IE_Type_48::Cipher_Suites_List;
	DWRD 40000000 3 90 c2 Pairwise Cipher Count:;
	g[2] -= 8;
	LABL 0 0 0 c9 PairwiseKey Cipher List;
	while (g[3] > 0)
	{
		TGTE 4 10 0 0 RETURN;
		TGTE 0  2 0 0 RETURN;
		g[4] = pb[3];
		HEX# 80000001 0 90 c2 Pairwise Cipher OUI:;
		HEX# 80000001 0 90 00 -;
		HEX# 80000001 0 90 00 -;
		HEX# 80000001 0 90 00 -;
		CST# 0 4 0 14 802_11::IE_Type_48::Cipher_Suites_List;
		g[3] -= 1;
		g[2] -= 4;
	}
	LABL 0 0 0 c8;
	DWRD 40000000 3 90 c2 AuthKey Mngmnt Count:;
	g[2] -= 2;
	LABL 0 0 0 c9 AuthKey Mngmnt Suite List;
	while (g[3] > 0)
	{
		TGTE 4 10 0 0 RETURN;
		TGTE 0  2 0 0 RETURN;
		g[4] = pb[3];
		HEX# 80000001 0 90 C2 AKMP Suite OUI:;
		HEX# 80000001 0 90 00 -;
		HEX# 80000001 0 90 00 -;
		HEX# 80000001 0 90 00 -;
		CST# 0 4 0 14 802_11::IE_Type_48::AuthKey_Mngmnt_Suites_List;
		g[3] -= 1;
		g[2] -= 4;
	}
	LABL 0 0 0 c8;
	TGTE 0  2 0 0 RETURN;
	BWRD 40000001 1 90 c9 RSN Capabilities:;
		LABL 0 0 00 d4 xx...... ........ Reserved;
		l[1] = g[1];
		CBIT d 41 00 d4 ..1..... ........ Extended Key ID for Individually Addressed Frames: PTKSA and STKSA when the cipher suite is CCMP;
		CLSE 0 0 00 d4 ..0..... ........ Extended Key ID for Individually Addressed Frames: PTKSA and STKSA;		
		CBIT c 41 00 d4 ...1.... ........ PBAC Supported;
		CLSE 0 0 00 d4 ...0.... ........ PBAC Not Supported;
		CBIT b 41 00 d4 ....1... ........ SPP A-MSDU Required Allowed;
		CLSE 0 0 00 d4	....0... ........ SPP A-MSDU Required Not Allowed;
		CBIT a 41 00 d4	.....1.. ........ SPP A-MSDU Capable Supported;
		CLSE 0 0 00 d4	.....0.. ........ SPP A-MSDU Capable Not Supported;
		CBIT 9 41 00 d4 ......1. ........ PeerKey Handshake Supported;
		CLSE 0 0 00 d4  ......0. ........ PeerKey Handshake Not Supported;
		LABL 0 0 00 d4  .......x ........ Reserved;
		CBIT 7 41 00 d4 ........ 1....... Management Frame Protection Capable (MFPC): enabled;
		CLSE 0 0 00 d4 ........ 0....... Management Frame Protection Capable (MFPC): disabled;		
		CBIT 6 41 00 d4 ........ .1...... Management Frame Protection Required (MFPR): mandatory;
		CLSE 0 0 00 d4 ........ .0...... Management Frame Protection Required (MFPR): not mandatory;		
		ANDG 30 41;
		SHFR 4 41;
		if (l[1] == 0)
		{
			LABL 0 0 00 d4 ........ ..00.... GTKSA Replay Ctr: 0 - 1 replay counter;
		}
		if (l[1] == 1)
		{
			LABL 0 0 00 d4 ........ ..01.... GTKSA Replay Ctr: 1 - 2 replay counters;
		}
		if (l[1] == 2)
		{
			LABL 0 0 00 d4 ........ ..10.... GTKSA Replay Ctr: 2 - 4 replay counters;
		}
		if (l[1] == 3)
		{
			LABL 0 0 00 d4 ........ ..11.... GTKSA Replay Ctr: 3 - 16 replay counters;
		}
		l[1] = g[1];
		ANDG c 41;
		SHFR 2 41;
		if (l[1] == 0)
		{
			LABL 0 0 00 d4 ........ ....00.. PTKSA Replay Ctr: 0 - 1 replay counter;
		}
		if (l[1] == 1)
		{
			LABL 0 0 00 d4 ........ ....01.. PTKSA Replay Ctr: 1 - 2 replay counters;
		}
		if (l[1] == 2)
		{
			LABL 0 0 00 d4 ........ ....10.. PTKSA Replay Ctr: 2 - 4 replay counters;
		}
		if (l[1] == 3)
		{
			LABL 0 0 00 d4 ........ ....11.. PTKSA Replay Ctr: 3 - 16 replay counters;
		}
		CBIT 1 1 00 d4 ........ ......1. Supports No Pairwise;
		CLSE 0 0 00 d4 ........ ......0. Does not Support No Pairwise;
		CBIT 0 1 00 d4 ........ .......1 Supports Pre-Authentication;
		CLSE 0 0 00 d4 ........ .......0 Does Not Support Pre-Authentication;
		LABL 0 0 00 c8;
	g[2] -= 2;
	TGTE 0  2 0 0 RETURN;
	DWRD( 0x40000000, g[3], 0x90, 0xc2, "PMKID Count:" );
	g[2] -= 2;
	TGTE 0  2 0 0 RETURN;
	while (g[3] > 0)
	{
		TGTE 0 2 0 0 RETURN;
		HEX# 10 0 90 c2 PMKID:;
		g[2] -= 16;
		g[3] -= 1;
	}
	if (g[2] > 0)
	{
		g[4] = pb[3];
		HEX# 80000001 0 90 c2 Group Management Cipher Suite:;
		HEX# 80000001 0 90 00 -;
		HEX# 80000001 0 90 00 -;
		HEX# 80000001 0 90 00 -;
		CST# 0 4 0 14 802_11::IE_Type_48::Cipher_Suites_List;
		g[2] -= 4;
	}
	if (g[2] > 0)
	{
		DUMP 0 2 90 c2 Remaining Data:;
		g[2] = 0;
	}
	TRTS;
}

str# 802_11::IE_Type_48::Cipher_Suites_List;
	0 | Use Group cipher suite;
	1 | WEP-40;
	2 | TKIP;
	3 | Reserved;
	4 | CCMP - default in an RSN;
	5 | WEP-104;
	6 | BIP;
	7 | Group addressed traffic not allowed;

str# 802_11::IE_Type_48::AuthKey_Mngmnt_Suites_List;
	0 | Reserved;
	1 | 802.1X Authentication;
	2 | PSK;
	3 | FT authentication negotiated over IEEE 802.1X;
	4 | FT authentication using PSK;
	5 | Authentication negotiated over IEEE 802.1X or using PMKSA caching with SHA256 Key Derivation;
	6 | PSK with SHA256 Key Derivation;
	7 | TDLS;
	8 | SAE Authentication with SHA-256 or using PMKSA caching with SHA-256 key derivation;
	9 | FT authentication over SAE with SHA-256;

//------------------------------------------------------
//type 50
void 802_11::IE_EXT_Supported_Rates()
{											
	g[3] = g[2];
	802_11::IE_Supported Rates Loop();
	TRTS;
}

//type 51
void 802_11::IE_AP_Channel_Report()
{
	l[1] = g[2];
	l[1] -= 1;	//account for the regulatory class
	
	DBYT 0 42 90 c2 Regulatory Class:;
	
	if( l[1] > 0 )
	{
		LABL 0 0 90 c9 Access Point Channel List;
		
		while( l[1] > 0 )
		{
			DBYT 0 42 90 c2 Channel:;
			l[1] -= 1;
		}
		
		LABL 0 0 0 c8;
	}
}
//type 52 (Neighbor Report) 802.11k
void 802_11::IE_Type_52()
{
	ETHR 0 0 90 c2 BSSID:;		g[2] -= 6;
	LABL( 0x40000000, l[1], 0x90, 0xc9, "BSSID Information:" );
	//DECR 4;
	DBIT( 2, l[5], 0x90, 0xc2, "AP Reachability:" );
		CST#( 0, l[5], 0, 0x14, 802_11::IE_Type_52::AP Reachability );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	BBIT( 1, l[6], 0x90, 0xc2, "Security:" );
		CEQU( 0, l[6], 0, 0x14, "security information is not available" );
		CEQU( 1, l[6], 0, 0x14, "the AP identified by this BSSID supports the same security provisioning as used by the STA" );
	BBIT( 1, l[7], 0x90, 0xc2, "Key Scope:" );
		CEQU( 0, l[7], 0, 0x14, "distinct authenticator or the information is not available" );
		CEQU( 1, l[7], 0, 0x14, "this BSSID has the same authenticator as the AP sending the report" );
	BBIT( 6, l[8], 0x90, 0xc9, "Capabilities:" );
	BBIT( 6, 0, 0x05, 0x05 );
	//DECR 2;
	BBIT( 4, 0, 0x05, 0x05 );
	BBIT( 1, l[14], 0x90, 0xc2, "Spectrum Management:" ); 
	BBIT( 1, l[13], 0x90, 0xc2, "QoS:" );
	BBIT( 1, l[12], 0x90, 0xc2, "APSD:" );
	BBIT( 1, l[11], 0x90, 0xc2, "Radio Measurement:" );
	BBIT( 1, l[10], 0x90, 0xc2, "Delayed Block Ack:" );
	BBIT( 1, l[9], 0x90, 0xc2, "Immediate Block Ack:" );	
	LABL 0 0 0 c8;	
	BBIT( 1, 0, 0x90, 0xc2, "Mobility Domain:" );
	BBIT( 1, 0, 0x90, 0xc2, "High Throughput:" );
	BBIT( 4, 0, 0x05, 0x05, "Reserved:" );
	LABL 0 0 0 c8; 	g[2] -= 4;
	//DBYT( 0, l[2], 0x90, 0xc2, "Regulatory Class:" );
	//DBYT( 0, l[3], 0x90, 0xc2, "Channel Number:" );
	//DBYT( 0, l[4], 0x90, 0xc2, "PHY Type:" );
	//g[2] -= 4;
	//DLNG( 0, l[4], 0x90, 0xc2, "BSSID Information:" );		g[2] -= 4;
	//LABL( 0, 0, 0, 0xc8 );
	DBYT( 0, l[2], 0x90, 0xc2, "Regulatory Class:" );		g[2] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "Channel Number:" );			g[2] -= 1;
	if (g[2] > 0)
	{
		DBYT( 0, l[4], 0x90, 0xc2, "PHY Type:" );
	}
	//LABL( 0, 0, 0, 0xc8 );
	//802_11::IE_TYPE_52::OPTIONAL_SUBELEMENTS_LOOP;
	//LABL( 0, 0, 0, 0xc8 );
	TRTS;
}

void 802_11::IE_TYPE_52::OPTIONAL_SUBELEMENTS_LOOP()
{
	if (g[2] > 0)
	{
		DGLB( 0, g[2], 0x90, 0xc2, "Optional Subelements length:" );
		LABL( 0, 0, 0x90, 0xb7, "Optional Subelements:" );
		g[22] = g[2];
		while(g[22] != 0)
			{
				GWRD( 0, l[1] ); // if more than one byte is 0 something is wrong in the capture
				if (l[1] == 0)
				{
					DUMP( 0, g[2], 0x90, 0xc2, "Optional Subelements:" );
					g[2] -= g[22];
					g[22] = 0;
				}
				if (l[1] != 0)
				{
					DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
						CST#( 0, l[5], 0, 0x14, 802_11::IE_Type_52::OPTIONAL_SUBELEMENTS );
						CLSE( 0, 0, 0, 0x14, "Reserved" );
					DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	
					g[2] -= 2;		g[22] -= 2;
					g[44] = g[2];
					g[2] = g[20];
					TSB#( 0, l[5], 0, 0x14, 802_11::IE_Type_52::OPTIONAL_SUBELEMENTS::CALL );
					TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
					g[2] = g[44];
				}
			}
	}
	//LABL( 0, 0, 0, 0xc8 );
}

void 802_11::IE_Type_52::TSF_Information()
{
	DBYT( 0, l[2], 0x90, 0xc2, "TSF Offset:" );
	DBYT( 0, l[3], 0x90, 0xc2, "Beacon Interval:" );
}

void 802_11::IE_Type_52::Condensed_Country_String()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Condensed Country String:" );
}


void 802_11::IE_Type_52::BSS_Transition_Candidate_Preference()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Preference:" );
}

void 802_11::IE_Type_52::BSS_Termination_Duration()
{
	D64B( 0x40000000, l[2], 0x90, 0xc2, "BSS Termination TSF:" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "Duration:" );	 
}

void 802_11::IE_Type_52::Bearing()
{
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Bearing:" );
	DLNG( 0x40000000, l[3], 0x90, 0xc2, "Distance:" );
	DWRD( 0x40000000, l[4], 0x90, 0xc2, "Relative Height:" );
}

str# 802_11::IE_Type_52::OPTIONAL_SUBELEMENTS::CALL;
1	|	802_11::IE_Type_52::TSF_Information;
2	|	802_11::IE_Type_52::Condensed_Country_String;
3	|	802_11::IE_Type_52::BSS_Transition_Candidate_Preference;
4	|	802_11::IE_Type_52::BSS_Termination_Duration;
5	|	802_11::IE_Type_52::Bearing;
66	|	802_11::IE_Type_52;
70	|	802_11::RRM_Enabled_Capabilities;
71	|	802_11::Multiple_BSSID;
221	|	802_11::IE_Type_221;

str# 802_11::IE_Type_52::OPTIONAL_SUBELEMENTS;
1	|	TSF Information;
2	|	Condensed Country String;
3	|	BSS Transition Candidate Preference;
4	|	BSS Termination Duration;
5	|	Bearing;
66	|	Measurement Pilot Transmission Information;
70	|	RRM Enabled Capabilities;
71	|	Multiple BSSID;
221	|	Vendor Specific;

str# 802_11::IE_Type_52::AP Reachability;
1	|	Not Reachable;
2	|	Unknown;
3	|	Reachable;

//type 53 (RCPI element) 802.11k
void 802_11::IE_Type_53()
{
	DBYT( 0, l[2], 0x90, 0xc2, "RCPI:" );
	g[2] -= 1;
	TRTS;
}
// Type 54 (Mobility Report)  802.11r
void 802_11::IE_Type_54()
{
	HWRD 40000000 0 90 c2 Mobility Domain Id:;
	BBYT 0 41 90 c9 FT Capability:;
	LABL 0 0 0 d4 xxxxxx.. Reserved;
	CBIT 1 41 0 d4 ......1. Resource Request Protocol Capability: enabled;
	CLSE 0 0 0 d4 ......0. Resource Request Protocol Capability: not enabled;
	CBIT 0 41 0 d4 .......1 Fast BSS Transition over DS: enabled;
	CLSE 0 0 0 d4 .......0 Fast BSS Transition over DS: disabled;
	LABL( 0, 0, 0, 0xc8 );
	TRTS;
}
//Type 55   Fast BSS transition information element (FTIE) 802.11r
void 802_11::Fast_BSS_transition()
{
	BWRD( 0x40000000, l[1], 0x90, 0xc9, "MIC Control:" ); 	g[2] -= 2;
	DECR 2;
		 BBYT( 0, l[2], 0x90, 0xc2, "Reserved:" );
		 BBYT( 0, l[3], 0x90, 0xc2, "Information element count:" );
	LABL( 0, 0, 0, 0xc8 );
	HEX#( 0x40000000, 16, 0x90, 0xc2, "MIC:" ); 	g[2] -= 16;
	HEX#( 0x40000000, 32, 0x90, 0xc2, "ANonce:" ); 	g[2] -= 32;
	HEX#( 0x40000000, 32, 0x90, 0xc2, "SNonce:" ); 	g[2] -= 32;	
	LABL( 0, 0, 0x90, 0xc9, "Optional Parameters:" ); 
	while (g[2] != 0)
	{	
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Fast_BSS_transition::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1; //g[20] -= 2;
			TSB#( 0, l[2], 0, 0, 802_11::Fast_BSS_transition::Subelements::Call );
			XLSE( 0, 0, 0, 0, 802_11::Subelementsfail );		
	}
	LABL( 0, 0, 0, 0xb8 );
	TRTS;
}

str# 802_11::Fast_BSS_transition::Subelements;
0	|	Reserved;
1	|	PMK-R1 key holder identifier (R1KH-ID);
2	|	GTK;
3	|	PMK-R0 key holder identifier (R0KH-ID);
4	|	IGTK;

str# 802_11::Fast_BSS_transition::Subelements::Call;
//1	|	802_11::Fast_BSS_transition::Subelements::PMK-R1_key_holder_identifier;
2	|	802_11::Fast_BSS_transition::Subelements::GTK;
//3	|	802_11::Fast_BSS_transition::Subelements::PMK-R0_key_holder_identifier;

void 802_11::Fast_BSS_transition::Subelements::GTK()
{
	BLNG( 0x40000000, l[1], 0x90, 0xc9, "Key Info:" ); 	g[2] -= 2;
	DECR 2;
	BBIT( 2, l[10], 0x90, 0xc2, "Key ID:" );
	BBIT( 14, l[11], 0x90, 0xc2, "Reserved:" );
	LABL( 0, 0, 0, 0xc8 );
	DBYT( 0, l[2], 0x90, 0xc2, "Key Length:" ); 	g[2] -= 1;
	D64B( 0x40000000, l[3], 0x90, 0xc2, "RSC:" ); 	g[2] -= 8;
	HEX#( 0x40000000, l[2], 0x90, 0xc2, "Key:" ); 	g[2] -= l[2];
}

//------------------------------------------------------
void 802_11::Subelementsfail()
{
	HEX#( 0, g[20], 0x90, 0xc2, "Subelement Data:" ); 	g[2] -= g[20];
	TRTS;
}
//------------------------------------------------------
//Type 56 802.11r
void 802_11::Timeout_Interval()
{
	DBYT( 0, l[1], 0x90, 0xc9, "Timeout Interval Type:" ); 	g[2] -= 1;
		CST#( 0, l[1], 0, 0x14, 802_11::Timeout_Interval::Type );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DLNG( 0x40000000, l[2], 0x90, 0xc9, "Timeout Interval Value:" ); 	g[2] -= 4;
}
str# 802_11::Timeout_Interval::Type;
1	|	Reassociation deadline interval Time units (TUs);
2	|	Key lifetime interval (Seconds);
3	|	Association Comeback time (TUs);
//------------------------------------------------------
//Type 57 802.11r
void 802_11::RIC_Data()
{
	DBYT( 0, l[1], 0x90, 0xc9, "RDIE Identifier:" ); 	g[2] -= 1;
	DBYT( 0, l[2], 0x90, 0xc9, "Resource Descriptor Count:" ); 	g[2] -= 1;
	DWRD( 0x40000000, l[3], 0x90, 0xc9, "Status Code:" ); 	g[2] -= 2;
}
//------------------------------------------------------

//Type 58 DSE Registered Location element
void 802_11::DSE_Registered_Location()
{
	BBIT( 6, l[1], 0x90, 0xc2, "Latitude Resolution:" );
	BBIT( 25, l[2], 0x90, 0xc2, "Latitude Fraction:" );	
	BBIT( 9, l[3], 0x90, 0xc2, "Latitude Integer:" );
	BBIT( 6, l[4], 0x90, 0xc2, "Longitude Resolution:" );
	BBIT( 25, l[5], 0x90, 0xc2, "Longitude Fraction:" );
	BBIT( 9, l[6], 0x90, 0xc2, "Longitude Integer:" );
	BBIT( 4, l[7], 0x90, 0xc2, "Altitude Type:" );
	BBIT( 6, l[8], 0x90, 0xc2, "Altitude Resolution:" );
	BBIT( 8, l[9], 0x90, 0xc2, "Altitude Fraction:" );
	BBIT( 22, l[10], 0x90, 0xc2, "Altitude Integer:" );
	BBIT( 3, l[11], 0x90, 0xc2, "Datum:" );
	BBIT( 1, l[12], 0x90, 0xc2, "RegLoc Agreement:" );
	BBIT( 1, l[13], 0x90, 0xc2, "RegLoc DSE:" );
	BBIT( 1, l[14], 0x90, 0xc2, "Dependent STA:" );
	BBIT( 2, l[15], 0x90, 0xc2, "Reserved:" );
	BWRD( 2, l[16], 0x90, 0xc2, "Dependent Enablement Identifier:" );
	DBYT( 8, l[17], 0x90, 0xc2, "Operating Class:" );	
	DBYT( 8, l[18], 0x90, 0xc2, "Channel Number:" );
	g[2] -= 20;
}
//------------------------------------------------------
//Type 59 Supported Regulatory Classes
void 802_11::Supported_Regulatory_Classes()
{
	DBYT( 0, 0, 0x90, 0xc2, "Current Operating Class:" );	g[2] -= 1;
	while (g[2] != 0 )
	{
		DBYT( 0, 0, 0x90, 0xc2, "Operating Classes:" );	g[2] -= 1;
	}
}
//------------------------------------------------------

//------------------------------------------------------
void 802_11::IE_Request; 
	TRTS;

//------------------------------------------------------
//type 60 
void 802_11::IE_Extended_Channel_Switch_Announcement()
{
	DBYT 0 41 90 c2 Channel Switch Mode:;
	DBYT 0 41 90 c2 New Regulatory Class:;
	DBYT 0 41 90 c2 New Channel Number:;
	DBYT 0 41 90 c2 Channel Switch Count:;
	
	if( l[1] == 0 )
	{
		LABL 0 0 0 14 Switching anytime after this frame;
	}
	
	if( l[1] == 1 )
	{
		LABL 0 0 0 14 Switching before next target beacon transmission;
	}
	TRTS;
}
//------------------------------------------------------
//type 61 
//802_11n.dcd
//------------------------------------------------------
//type 62
//802_11n.dcd
//------------------------------------------------------
//type 63 802.11k
void 802_11::BSS_Average_Access_Delay()
{
	DBYT( 0, l[1], 0x90, 0xc2, "AP Average Access Delay:" );	g[2] -= 1;
		CST#( 0, l[1], 0, 0x14, 802_11::BSS_Average_Access_Delay::Values );
		l[2] = l[1];
		l[3] = l[1];
		if (l[1] >= 17)
		{
			if (l[1] <= 106)
			{
				l[2] = l[1];
				l[2] *= 16;
				l[2] -= 128;
				DGLB( 0, l[2], 0x14, 0 );
				LABL( 0, 0, 0, 0x04, " ï¿½s =  Access Delay <: " );
				l[3] + = 1;
				l[2] *= 16;
				l[2] -= 128;
				DGLB( 0, l[3], 0x04, 0 );
				LABL( 0, 0, 0, 0x04, " ï¿½s" );
			}
		}
		if (l[1] >= 109)
		{
			if (l[1] <= 246)
			{
				l[2] = l[1];
				l[2] *= 32;
				l[2] -= 1856;
				DGLB( 0, l[2], 0x14, 0 );
				LABL( 0, 0, 0, 0x04, " ï¿½s =  Access Delay <: " );
				l[3] + = 1;
				l[2] *= 32;
				l[2] -= 1856;
				DGLB( 0, l[3], 0x04, 0 );
				LABL( 0, 0, 0, 0x04, " ï¿½s" );
			}
		}
	
	TRTS;
}
str# 802_11::BSS_Average_Access_Delay::Values;
0	|	Access Delay < 8 ï¿½s;
1	|	8 ï¿½s  =  Access Delay < 16 ï¿½s;
2 	|	16 ï¿½s =  Access Delay < (3)  ï¿½ 8 ï¿½s;
3 	|	24 ï¿½s =  Access Delay < (4)  ï¿½ 8 ï¿½s;
4 	|	32 ï¿½s =  Access Delay < (5)  ï¿½ 8 ï¿½s;
5 	|	40 ï¿½s =  Access Delay < (6)  ï¿½ 8 ï¿½s;
6 	|	48 ï¿½s =  Access Delay < (7)  ï¿½ 8 ï¿½s;
7 	|	56 ï¿½s =  Access Delay < (8)  ï¿½ 8 ï¿½s;
8 	|	64 ï¿½s =  Access Delay < (9)  ï¿½ 8 ï¿½s;
9 	|	9  ï¿½ 8 ï¿½s =  Access Delay < (10)  ï¿½ 8 ï¿½s;
10 	|	10  ï¿½ 8 ï¿½s =  Access Delay < (11)  ï¿½ 8 ï¿½s;
11	|	11  ï¿½ 8 ï¿½s =  Access Delay < (12)  ï¿½ 8 ï¿½s;
12	|	12  ï¿½ 8 ï¿½s =  Access Delay < (13)  ï¿½ 8 ï¿½s;
13	|	13  ï¿½ 8 ï¿½s =  Access Delay < (14)  ï¿½ 8 ï¿½s;
14	|	14  ï¿½ 8 ï¿½s =  Access Delay < (15)  ï¿½ 8 ï¿½s;
15	|	120 ï¿½s  =  Access Delay < 128 ï¿½s;
16	|	128 ï¿½s  =  Access Delay <  144 ï¿½s;
107	|	1584 ï¿½s =  Access Delay < 1600 ï¿½s;
108	|	1600 ï¿½s =  Access Delay < 1632 ï¿½s;
247	|	6048 ï¿½s =  Access Delay < 6080 ï¿½s;
248	|	6080 ï¿½s =  Access Delay < 8192 ï¿½s;
249	|	8192 ï¿½s =  Access Delay < 12288 ï¿½s;
250	|	12288 ï¿½s  =  Access Delay < 16384 ï¿½s;
251	|	16384 ï¿½s  =  Access Delay < 20480 ï¿½s;
252	|	20480 ï¿½s  =  Access Delay < 24576 ï¿½s;
253	|	24576 ï¿½s  =  Access Delay;
254	|	Service unable to access channel;
255	|	Measurement not available;
//type 64 802.11k
void 802_11::Antenna()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Antenna ID:" );	g[2] -= 1;
	TRTS;
}
//type 65 802.11k
void 802_11::RSNI()
{
	DBYT( 0, l[1], 0x90, 0xc2, "RSNI:" );	g[2] -= 1;
	TRTS;
}
//type 66 802.11k
void 802_11::Measurement_Pilot_Transmission()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Measurement Pilot Transmission:" );	g[2] -= 1;
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Measurement_Pilot_Transmission::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::Measurement_Pilot_Transmission::Subelements::Call );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
	}
	TRTS;
}

str# 802_11::Measurement_Pilot_Transmission::Subelements;
221	|	Vendor Specific;

str# 802_11::Measurement_Pilot_Transmission::Subelements::Call;
221	|	802_11::IE_Type_221;

//type 67 802.11k
void 802_11::BSS_Available_Admission_Capacity()
{
	BWRD( 0x40000000, l[1], 0x90, 0xc2, "Available Admission Capacity Bitmask:" );	g[2] -= 2;	
	LABL( 0, 0, 0x90, 0xc7, "Available Admission Capacity List" );
	while (g[2] != 0)
	{		
		BWRD( 0x40000000, l[2], 0x90, 0xc2, "Available Admission Capacity field:" );	g[2] -= 2;
	}
	LABL 0 0 0 c8;
	TRTS;
}
//---------------------------------------------------------------
//TYPE 68
//802_11n.dcd
//---------------------802.11p-----------------------------
//TYPE 69
void 802_11::Wave_Service_Information()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Timing Capabilities:" );
		CEQU( 1, l[1], 0x0, 0x14, "Timestamp offset based on UTC" );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	g[2] -= 1;
	if (g[2] >= 10)
	{
		HEX#( 0x40000000, 10, 0x90, 0xc2, "Time Value:" );
		g[2] -= 10;
	}
	if (g[2] >= 5)
	{
		HEX#( 0x40000000, 5, 0x90, 0xc2, "Time Error:" );
		g[2] -= 5;
	}
	if (g[2] >= 1)
	{
		HEX#( 0x40000000, 1, 0x90, 0xc2, "Time Update Counter:" );
		g[2] -= 1;
	}
	TRTS;
}

//------------------------------------------------------
//Type 70

void 802_11::RM_Enabled_Capabilities()
{
	//Bit 0-7
	BBYT 0 41 90 c9 RM Enabled Capabilities:;
	CBIT 7 41 0 d4 "1... .... Beacon Measurement Reporting conditions capability: enabled";
	CLSE 0  0 0 d4 "0... .... Beacon Measurement Reporting conditions capability: disabled";
	CBIT 6 41 0 d4 ".1.. .... Beacon Table Measurement capability: enabled";
	CLSE 0  0 0 d4 ".0.. .... Beacon Table Measurement capability: disabled";
	CBIT 5 41 0 d4 "..1. .... Beacon Active Measurement capability: enabled";
	CLSE 0  0 0 d4 "..0. .... Beacon Active Measurement capability: disabled";
	CBIT 4 41 0 d4 "...1 .... Beacon Passive Measurement capability: enabled";
	CLSE 0  0 0 d4 "...0 .... Beacon Passive Measurement capability: disabled";
	CBIT 3 41 0 d4 ".... 1... Repeated Measurements capability: enabled";
	CLSE 0  0 0 d4 ".... 0... Repeated Measurements capability: disabled";
	CBIT 2 41 0 d4 ".... .1.. Parallel Measurements capability: enabled";
	CLSE 0  0 0 d4 ".... .0.. Parallel Measurements capability: disabled";
	CBIT 1 41 0 d4 ".... ..1. Neighbor Report capability: enabled";
	CLSE 0  0 0 d4 ".... ..0. Neighbor Report capability: disabled";
	CBIT 0 41 0 d4 ".... ...1 Link Measurement capability: enabled";
	CLSE 0  0 0 d4 ".... ...0 Link Measurement capability: disabled";
	LABL 0 0 0 c8;
	g[2] -= 1;
	if (g[2] >= 1)
	{
		//Bit 8-15
		BBYT 0 41 90 c9 RM Enabled Capabilities:;
		CBIT 7 41 0 d4 "1... .... Triggered Transmit Stream/Category capability: enabled";
		CLSE 0  0 0 d4 "0... .... Triggered Transmit Stream/Category capability: disabled";
		CBIT 6 41 0 d4 ".1.. .... Transmit Stream/Category capability: enabled";
		CLSE 0  0 0 d4 ".0.. .... Transmit Stream/Category capability: disabled";
		CBIT 5 41 0 d4 "..1. .... LCI Azimuth capability: enabled";
		CLSE 0  0 0 d4 "..0. .... LCI Azimuth capability: disabled";
		CBIT 4 41 0 d4 "...1 .... LCI Measurement capability: enabled";
		CLSE 0  0 0 d4 "...0 .... LCI Measurement capability: disabled";
		CBIT 3 41 0 d4 ".... 1... Statistics Measurement capability: enabled";
		CLSE 0  0 0 d4 ".... 0... Statistics Measurement capability: disabled";
		CBIT 2 41 0 d4 ".... .1.. Noise Histogram Measurement capability: enabled";
		CLSE 0  0 0 d4 ".... .0.. Noise Histogram Measurement capability: disabled";
		CBIT 1 41 0 d4 ".... ..1. Channel Load Measurement capability: enabled";
		CLSE 0  0 0 d4 ".... ..0. Channel Load Measurement capability: disabled";
		CBIT 0 41 0 d4 ".... ...1 Frame measurement capability: enabled";
		CLSE 0  0 0 d4 ".... ...0 Frame measurement capability: disabled";		
		LABL 0 0 0 c8;
		g[2] -= 1;
		if (g[2] >= 1)
		{
			//Bit 16-23
			BBYT 0 41 90 c9 RM Enabled Capabilities:;
			l[2] = l[1] & 0xe0;
			SHFR 5 42;
			CEQU 0 42 0 d4 "000";
			CEQU 1 42 0 d4 "001";
			CEQU 2 42 0 d4 "010";
			CEQU 3 42 0 d4 "011";
			CEQU 4 42 0 d4 "100";
			CEQU 5 42 0 d4 "110";
			CEQU 6 42 0 d4 "111";
			LABL 0  0 0 04 ". .... Non-Operating Channel Max Measurement Duration = ";
			DGLB 0 42 4;	
			LABL 0  0 0 04 " Tick Units";
			LABL 0 0 0  d4 "...";
			l[2] = l[1] & 0x1c;
			SHFR 2 42;
			CEQU 0 42 0 04 "0 00";
			CEQU 1 42 0 04 "0 01";
			CEQU 2 42 0 04 "0 10";
			CEQU 3 42 0 04 "0 11";
			CEQU 4 42 0 04 "1 00";
			CEQU 5 42 0 04 "1 10";
			CEQU 6 42 0 04 "1 11";
			LABL 0  0 0 04 ".. Operating Channel Max Measurement Duration = ";
			DGLB 0 42 4;
			LABL 0  0 0 04 " Tick Units";
			CBIT 1 41 0 d4 ".... ..1. RRM MIB capability: enabled";
			CLSE 0  0 0 d4 ".... ..0. RRM MIB capability: disabled";	
			CBIT 0 41 0 d4 ".... ...1 AP Channel Report capability: enabled";
			CLSE 0  0 0 d4 ".... ...0 AP Channel Report capability: disabled";		
			LABL 0 0 0 c8;
			g[2] -= 1;
			if (g[2] >= 1)
			{
				//Bit 24-31
				BBYT 0 41 90 c9 RM Enabled Capabilities:;
				CBIT 7 41 0 d4 "1... .... BSS Average Access Delay capability: enabled";
				CLSE 0  0 0 d4 "0... .... BSS Average Access Delay capability: disabled";
				CBIT 6 41 0 d4 ".1.. .... RSNI Measurement capability: enabled";
				CLSE 0  0 0 d4 ".0.. .... RSNI Measurement capability: disabled";
				CBIT 5 41 0 d4 "..1. .... RCPI Measurement capability: enabled";
				CLSE 0  0 0 d4 "..0. .... RCPI Measurement capability: disabled";
				CBIT 4 41 0 d4 "...1 .... Neighbor Report TSF Offset capability: enabled";
				CLSE 0  0 0 d4 "...0 .... Neighbor Report TSF Offset capability: disabled";
				CBIT 3 41 0 d4 ".... 1... Measurement Pilot Transmission Information capability: enabled";
				CLSE 0  0 0 d4 ".... 0... Measurement Pilot Transmission Information capability: disabled";
				LABL 0 0 0  d4 ".... .";
				l[2] = l[1] & 0x07;
				CEQU 0 42 0 04 "000";
				CEQU 1 42 0 04 "001";
				CEQU 2 42 0 04 "010";
				CEQU 3 42 0 04 "011";
				CEQU 4 42 0 04 "100";
				CEQU 5 42 0 04 "110";
				CEQU 6 42 0 04 "111";
				LABL 0  0 0 04 " Measurement Pilot capability = ";
				DGLB 0 42 4;	
				LABL 0 0 0 c8;
				g[2] -= 1;
				if (g[2] >= 1)
				{
					//Bit 32-39
					BBYT 0 41 90 c9 RM Enabled Capabilities:;
					LABL 0  0 0 d4 "xxxx xx.. Reserved";
					CBIT 1 41 0 d4 ".... ..1. Antenna capability enabled: enabled";
					CLSE 0  0 0 d4 ".... ..0. Antenna capability enabled: disabled";
					CBIT 0 41 0 d4 ".... ...1 BSS Available Admission Capacity capability: enabled";
					CLSE 0  0 0 d4 ".... ...0 BSS Available Admission Capacity capability: disabled";
					LABL 0 0 0 c8;
					g[2] -= 1;
				}
			}
		}
	}
}

//------------------------------------------------------
//Type 71 //
void 802_11::Multiple_BSSID()
{
	DBYT( 0, l[1], 0x90, 0xc2, "MaxBSSID Indicator:" );	g[2] -= 1;
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Multiple_BSSID::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0,g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::Multiple_BSSID::Subelements::Call );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
	}
	TRTS;
}

str# 802_11::Multiple_BSSID::Subelements;
0	|	Nontransmitted BSSID Profile;
221	|	Vendor Specific;

str# 802_11::Multiple_BSSID::Subelements::Call;
0	|	802_11::Non-transmitted_BSSID_Capability;
221	|	802_11::IE_Type_221;
//------------------------------------------------------
//Type 72, 73, 74 ->802_11n.dcd
//------------------------------------------------------

//------------------------------------------------------
//Type 75 802.11r
void 802_11::RIC_Descriptor()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Resource Type:" );	g[2] -= 1;
	if (l[1] == 1)
	{
		BWRD( 0x40000000, l[1], 0x90, 0xc9, "Block Ack Parameter Set:" );	g[2] -= 2;
		DECR 2;
			BBIT( 1, l[1], 0x90, 0xc2, "A-MSDU Supported:" );
			CEQU( 1, l[1], 0, 0x14, "enabled:" );
			CEQU( 0, l[1], 0, 0x14, "disabled" );
			BBIT( 1, l[2], 0x90, 0xc2, "Block Ack Policy:" );
			CEQU( 1, l[2], 0, 0x14, "enabled:" );
			CEQU( 0, l[2], 0, 0x14, "disabled" );
			DBIT( 4, l[3], 0x90, 0xc2, "TID:" );
			DBIT( 10, l[4], 0x90, 0xc2, "Buffer Size:" );
		LABL 0 0 0 c8;
		BWRD( 0x40000000, l[1], 0x90, 0xc2, "Block Ack Timeout Value:" );	g[2] -= 2;
		DUMP( 0, g[2], 0x90, 0xc2, "Additional Data:" );	g[2] -= g[2];

	}
	if (l[1] != 0)
	{
		DUMP( 0, g[2], 0x90, 0xc2, "Not Supported:" );	g[2] -= g[2];
	}
}
//------------------------------------------------------


//Type 76 802.11w
void 802_11::Management_MIC()
{
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "KeyID:" );	g[2] -= 2;	
	HEX#( 6, 0, 0x90, 0xc2, "IPN:" );	g[2] -= 6;	
	D64B( 0x40000000, l[2], 0x90, 0xc2, "MIC:" );	g[2] -= 8;			
}
//------------------------------------------------------

//Type 77 reserved

//------------------------------------------------------

//---------------------802.11v
//802.11v Type 78
void 802_11::Event_Request()
{
	HBYT( 0, l[1], 0x90, 0xc2, "Event Token:" );
	HBYT( 0, l[2], 0x90, 0xc2, "Event Type:" );
		CST#( 0, l[2], 0, 0x14, 802_11::Event_Request::Event_Type );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[3], 0x90, 0xc2, "Event  Response Limit:" );
	g[2] -= 3;
	TSB#( 0, l[2], 0, 0, 802_11::Event_Request::Event_Type::Call );
	TRTS;
}

void 802_11::Transition_Event_Request()
{
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Transition_Event_Request::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::Transition_Event_Request::Subelements::Call );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );			
	}
}

void 802_11::Transition_Event_Request::Transition Target BSSID()
{
	ETHR( 0, l[2], 0x90, 0xc2, "Target BSSID:" );	g[2] -= 6;	g[20] -= 6;
}

void 802_11::Transition_Event_Request::Transition Source BSSID()
{
	ETHR( 0, l[2], 0x90, 0xc2, "Source BSSID:" );	g[2] -= 6;	g[20] -= 6;
}

void 802_11::Transition_Event_Request::Transition Time Threshold()
{
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Transition Time Threshold:" );	g[2] -= 2;	g[20] -= 2;
}

void 802_11::Transition_Event_Request::Transition Result()
{
	BBYT( 0, l[2], 0x90, 0xc2, "Match Value:" );	g[2] -= 1;	g[20] -= 1;
}

void 802_11::Transition_Event_Request::Frequent Transition()
{
	BBYT( 0, l[2], 0x90, 0xc2, "Frequent Transition Count Threshold:" );	g[2] -= 1;	g[20] -= 1;	
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Time Interval:" );	g[2] -= 2;	g[20] -= 2;
}

//---------------------------------------

void 802_11::RSNA_E_R()
{
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::RSNA_E_R::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0,g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::RSNA_E_R::Subelements::Call );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );			
	}
}

void 802_11::RSNA_E_R::RSNA Target BSSID()
{
	ETHR( 0, l[2], 0x90, 0xc2, "RSNA Target BSSID:" );	g[2] -= 6;	g[20] -= 6;
}

void 802_11::RSNA_E_R::Authentication Type()
{
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Authentication Type:" );	g[2] -= 2;	g[20] -= 2;
		CST#( 0, l[2], 0, 0x14, 802_11::IE_Type_48::AuthKey_Mngmnt_Suites_List );
		CLSE( 0, 0, 0, 0x14, "Reserved" );		
}

void 802_11::RSNA_E_R::EAP Method()
{
	DBYT( 0, l[2], 0x90, 0xc2, "EAP Method:" );	g[2] -= 1;	g[20] -= 1;
	if (l[2] == 254)
	{
		HEX# 3 0 90 c2 Vendor ID:;	g[2] -= 3;	g[20] -= 3;
		HEX# 4 0 90 c2 EAP Vendor Type:;	g[2] -= 3;	g[20] -= 3;
	}	
}

void 802_11::RSNA_E_R::RSNA Result()
{
	BBYT( 0, l[2], 0x90, 0xc2, "Match Value:" );	g[2] -= 1;	g[20] -= 1;
}

str# 802_11::RSNA_E_R::Subelements::Call;
1	|	802_11::RSNA_E_R::Subelements::RSNA Target BSSID;
2	|	802_11::RSNA_E_R::Subelements::Authentication Type;
3	|	802_11::RSNA_E_R::Subelements::EAP Method;
4	|	802_11::RSNA_E_R::Subelements::RSNA Result;

str# 802_11::RSNA_E_R::Subelements;
1	|	RSNA Target BSSID;
2	|	Authentication Type;
3	|	EAP Method;
4	|	RSNA Result;
//------------------------------------------------------
//---------------------------------------


void 802_11::Peer-to-PeerLink()
{
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Peer-to-PeerLink::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0,g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::Peer-to-PeerLink::Subelements::Call );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );			
	}
}
void 802_11::Peer-to-PeerLink::Subelements::Peer Address()
{
	ETHR( 0, l[2], 0x90, 0xc2, "Peer STA/BSSID Address:" );	g[2] -= 6;	g[20] -= 6;
}

void 802_11::Peer-to-PeerLink::Subelements::Channel Number()
{
	DBYT( 0, 0, 0x90, 0xc2, "Regulatory Class:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, 0, 0x90, 0xc2, "Channel:" );	g[2] -= 1;	g[20] -= 1;
}
str# 802_11::Peer-to-PeerLink::Subelements::Call;
1	|	802_11::Peer-to-PeerLink::Subelements::Peer Address;
2	|	802_11::Peer-to-PeerLink::Subelements::Channel Number;

str# 802_11::Peer-to-PeerLink::Subelements;
1	|	Peer Address;
2	|	Channel Number;

str# 802_11::Event_Request::Event_Type::Call;
0	|	802_11::Transition_Event_Request;
1	|	802_11::RSNA_E_R;
2	|	802_11::Peer-to-PeerLink;
3	|	802_11::Information_Element_Loop;
221	|	802_11::Information_Element_Loop;

str# 802_11::Event_Request::Event_Type;
0	|	Transition;
1	|	RSNA;
2	|	Peer-to-Peer Link;
3	|	WNM Log;
221	|	Vendor Specific; *221
6	|	Reserved; *222-255
//------------------------------------------------------
//-----------------TYPE 79---------------------
void 802_11::Event_Report()
{
	HBYT( 0, l[1], 0x90, 0xc2, "Event Token:" );
	HBYT( 0, l[2], 0x90, 0xc2, "Event Type:" );
		CST#( 0, l[2], 0, 0x14, 802_11::Event_Report::Event_Type );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[3], 0x90, 0xc2, "Event Report Status:" );
		CST#( 0, l[3], 0, 0x14, 802_11::Event_Report::Event Report Status );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	g[2] -= 3;
	if (l[3] == 0)
	{
		D64B( 0x40000000, l[1], 0x90, 0xc2, "Event TSF:" );
		HEX#( 10, 0, 0x90, 0xc2, "UTC Offset:" );
		HEX#( 5, 0, 0x90, 0xc2, "Event Time Error:" );
		g[2] -= 21;
	}
	TSB#( 0, l[2], 0, 0x14, 802_11::Event_Report::Event_Type::Call );
	TRTS;
}
void 802_11::Transition_Event_Report()
{
	ETHR( 0, l[2], 0x90, 0xc2, "Source BSSID:" );	g[2] -= 6;	g[20] -= 6;
	ETHR( 0, l[2], 0x90, 0xc2, "Target BSSID:" );	g[2] -= 6;	g[20] -= 6;
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "Transition Time:" );	g[2] -= 2;	g[20] -= 2;
	DWRD( 0x40000000, l[4], 0x90, 0xc2, "Transition Reason:" );	g[2] -= 1;	g[20] -= 1;
		CST#( 0, l[4], 0, 0x14, 802_11::Transition_Event_Report::Transition Reason );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DWRD( 0x40000000, l[5], 0x90, 0xc2, "Transition Result:" );	g[2] -= 2;	g[20] -= 2;
	DBYT( 0, l[6], 0x90, 0xc2, "Source RCPI:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[7], 0x90, 0xc2, "Source RSNI:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[8], 0x90, 0xc2, "Target RCPI:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[9], 0x90, 0xc2, "Target RSNI:" );	g[2] -= 1;	g[20] -= 1;
}

void 802_11::RSNA_E_Rep()
{
	ETHR( 0, 0, 0x90, 0xc2, "Source BSSID:" );	g[2] -= 6;	g[20] -= 6;
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Authentication Type:" );	g[2] -= 2;	g[20] -= 2;
		CST#( 0, l[2], 0, 0x14, 802_11::IE_Type_48::AuthKey_Mngmnt_Suites_List );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	if (l[2] == 0)
	{
		DBYT( 0, l[6], 0x90, 0xc2, "EAP Method:" );	g[2] -= 1;	g[20] -= 1;
	}
	if (l[2] == 1)
	{
		HEX#( 8, 0, 0x90, 0xc2, "EAP Method:" );	g[2] -= 1;	g[20] -= 1;
	}
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "RSNA Result:" );	g[2] -= 2;	g[20] -= 2;
}

void 802_11::Peer-to-PeerLink_Rep()
{
	ETHR( 0, l[2], 0x90, 0xc2, "Peer STA/BSSID Address:" );	g[2] -= 6;	g[20] -= 6;
	DBYT( 0, l[3], 0x90, 0xc2, "Regulatory Class:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[4], 0x90, 0xc2, "Channel:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[5], 0x90, 0xc2, "STA Tx Power:" );	g[2] -= 1;	g[20] -= 1;
	HEX#( 3, 0, 0x90, 0xc2, "Connection Time:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[6], 0x90, 0xc2, "Peer Status:" );	g[2] -= 1;	g[20] -= 1;
		CST#( 0, l[6], 0, 0x14, 802_11::Peer-to-PeerLink_Rep::Peer Status );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
}
//------------------------------------------------------
void 802_11::WNMLog()
{
	TRTS;
}
//-------------------------------------------------
//-------------------Diagnostic Request element----80-------------------------
void 802_11::Diagnostic_Request()
{
	HBYT( 0, l[1], 0x90, 0xc2, "Diagnostic Token:" );
	HBYT( 0, l[2], 0x90, 0xc2, "Diagnostic Request Type:" );
		CST#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Type );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "Diagnostic Timeout:" );
	TSB#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Type::Call );
	g[2] -= 3;
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0,g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Subelements::Call );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
	}
	TRTS;
}
str# 802_11::Diagnostic_Request::Type::Call;
//0	|	802_11::Diagnostic_Request::Type::Cancel Diagnostic Request;
//1	|	802_11::Diagnostic_Request::Type::Manufacturer Information STA Report;
//2	|	802_11::Diagnostic_Request::Type::Configuration Profile;
3	|	802_11::Diagnostic_Request::Type::Association Diagnostic;
4	|	802_11::Diagnostic_Request::Type::IEEE 802.1X Authentication Diagnostic;
221	|	802_11::Information_Element_Loop;

void 802_11::Diagnostic_Request::Type::Association Diagnostic()
{
	802_11::Diagnostic_Request::Subelements::AP Descriptor;
	802_11::Diagnostic_Request::Subelements::Profile ID;
}

void 802_11::Diagnostic_Request::Type::IEEE 802.1X Authentication Diagnostic()
{
	802_11::Diagnostic_Request::Subelements::AP Descriptor;
	802_11::Diagnostic_Request::Subelements::EAP Method;
	802_11::Diagnostic_Request::Subelements::Credential_Type;
	802_11::Diagnostic_Request::Subelements::Profile ID;
}

//SEs
void 802_11::Diagnostic_Request::Subelements::Credential_Type()
{
	while (g[20] >= 1)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Credential Values:" );	g[2] -= 1;	g[20] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Credential Values );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
	}
}

void 802_11::Diagnostic_Request::Subelements::AKM Suite()
{
	802_11::Print_OUI;
	g[20] -= 3;	g[2] -= 3;
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "AKM Suite:" );	g[2] -= 2;	g[20] -= 2;
		CST#( 0, l[2], 0, 0x14, 802_11::IE_Type_48::AuthKey_Mngmnt_Suites_List );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
}
void 802_11::Diagnostic_Request::Subelements::AP Descriptor()
{
	ETHR( 0, l[2], 0x90, 0xc2, "BSSID:" );	g[2] -= 6;	g[20] -= 6;
	DBYT( 0, l[3], 0x90, 0xc2, "Regulatory Class:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[4], 0x90, 0xc2, "Channel:" );	g[2] -= 1;	g[20] -= 1;
}
void 802_11::Diagnostic_Request::Subelements::Antenna Type()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Antenna Count:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "Antenna Gain(dbi):" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[4], 0x90, 0xc2, "Antenna Type:" );	g[2] -= 1;	g[20] -= 1;
}
void 802_11::Diagnostic_Request::Subelements::Cipher Suite()
{
	802_11::Print_OUI;
	g[20] -= 3;	g[2] -= 3;
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "AKM Suite:" );	g[2] -= 2;	g[20] -= 2;
		CST#( 0, l[2], 0, 0x14, 802_11::IE_Type_48::Cipher_Suites_List );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
}
void 802_11::Diagnostic_Request::Subelements::Collocated Radio Type()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Collocated Radio Type:" );	g[2] -= 1;	g[20] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Subelements::Collocated Radio Types );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
}

void 802_11::Diagnostic_Request::Subelements::EAP Method()
{
	DBYT( 0, l[2], 0x90, 0xc2, "EAP Method:" );	g[2] -= 1;	g[20] -= 1;
	if (l[2] == 254)
	{
		HEX# 3 0 90 c2 Vendor ID:;
		g[2] -= 3;	g[20] -= 3;
		HEX# 4 0 90 c2 EAP Vendor Type:;
		g[2] -= 3;	g[20] -= 3;
	}
}
void 802_11::Diagnostic_Request::Subelements::Firmware Version()
{
	CHR#( 0, g[20], 0x90, 0xc2, "Firmware Version:" );	g[2] -= g[20];	g[20] -= g[20];	
}
void 802_11::Diagnostic_Request::Subelements::MAC Address()
{
	ETHR( 0, 0, 0x90, 0xc2, "MAC Address:" );	g[2] -= 6;	g[20] -= 6;	
}
void 802_11::Diagnostic_Request::Subelements::Manufacturer ID String()
{
	CHR#( 0, g[20], 0x90, 0xc2, "ID:" );	g[2] -= g[20];	g[20] -= g[20];	
}
void 802_11::Diagnostic_Request::Subelements::Manufacturer Model String()
{
	CHR#( 0, g[20], 0x90, 0xc2, "Model:" );	g[2] -= g[20];	g[20] -= g[20];	
}
void 802_11::Diagnostic_Request::Subelements::Manufacturer Serial Number String()
{
	CHR#( 0, g[20], 0x90, 0xc2, "Serial Number String:" );	g[2] -= g[20];	g[20] -= g[20];	
}
void 802_11::Diagnostic_Request::Subelements::Manufacturer OI()
{
	CHR#( 0, g[20], 0x90, 0xc2, "OI:" );	g[2] -= g[20];	g[20] -= g[20];	
}
void 802_11::Diagnostic_Request::Subelements::Power Save Mode()
{
	DLNG( 0x40000000, l[2], 0x90, 0xc2, "Collocated Radio Type:" );	g[2] -= 4;	g[20] -= 4;
		BST#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Subelements::Power Save Modes );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
}
void 802_11::Diagnostic_Request::Subelements::Profile ID()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Profile ID:" );	g[2] -= 1;	g[20] -= 1;
}
void 802_11::Diagnostic_Request::Subelements::Supported Regulatory Classes()
{
	DBYT( 0, 0, 0x90, 0xc2, "Current Operating Class:" );	g[2] -= 1;	g[20] -= 1;
	while (g[20] != 0 )
	{
			DBYT( 0, 0, 0x90, 0xc2, "Operating Classes:" );	g[2] -= 1;	g[20] -= 1;
	}
}
void 802_11::Diagnostic_Request::Subelements::Status Code()
{
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Status Code:" );	g[2] -= 2;	g[20] -= 2;
		CST#( 0, l[2], 0, 0x14, 802_11::Status Code );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
}
void 802_11::Diagnostic_Request::Subelements::SSID()
{
	CHR#( 0, g[20], 0x90, 0xc2, "SSID:" );	g[2] -= g[20];	g[20] -= g[20];
}
void 802_11::Diagnostic_Request::Subelements::Tx Power Capability()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Tx Power Mode:" );	g[2] -= 1;	g[20] -= 1;
		CEQU( 0, l[2], 0, 0x14, "Discrete" );
		CEQU( 1, l[2], 0, 0x14, "Range" );
}
void 802_11::Diagnostic_Request::Subelements::Certificate ID()
{
	CHR#( 0, g[20], 0x90, 0xc2, "Certificate ID:" );	g[2] -= g[20];	g[20] -= g[20];
}
str# 802_11::Diagnostic_Request::Subelements;
0	|	Credential Type;
1	|	AKM Suite;
2	|	AP Descriptor;
3	|	Antenna Type;
4	|	Cipher Suite;
5	|	Collocated Radio Type;
6	|	Device Type;
7	|	EAP Method;
8	|	Firmware Version;
9	|	MAC Address;
10	|	Manufacturer ID String;
11	|	Manufacturer Model String;
12	|	Manufacturer OI;
13	|	Manufacturer Serial Number String;
14	|	Power Save Mode;
15	|	Profile ID;
16	|	Supported Regulatory Classes;
17	|	Status Code;
18	|	SSID;
19	|	Tx Power Capability;
20	|	Certificate ID;
//21ï¿½220 Reserved;
221	|	Vendor Specific;
//221ï¿½255 Reserved;


str# 802_11::Diagnostic_Request::Type;
0	|	Cancel Diagnostic Request;
1	|	Manufacturer Information STA Report;
2	|	Configuration Profile;
3	|	Association Diagnostic;
4	|	IEEE 802.1X Authentication Diagnostic;
221	|	Vendor Specific;

str# 802_11::Diagnostic_Request::Subelements::Power Save Modes;
0	|	Unknown;
1	|	None;
2	|	PS mode (ReceiveDTIMs=1);
3	|	PS mode (ReceiveDTIMs=0);
4	|	U-APSD;
5	|	S-APSD;
6	|	U-PSMP;
7	|	S-PSMP;
8	|	SM Power Save;
9	|	WNM-Sleep Mode;
10	|	FMS;
11	|	TIM Broadcast;
12	|	TFS;
13	|	TDLSPeer U-APSD;
14	|	TDLSPeer PSM;

str# 802_11::Diagnostic_Request::Subelements::Collocated Radio Types;
0	|	Reserved;
1	|	Cellular;
2	|	Cordless;
3	|	GPS;
4	|	IEEE 802.11;
5	|	IEEE 802.15;
6	|	IEEE 802.16;
7	|	IEEE 802.20;
8	|	IEEE 802.22;
9	|	Digital Audio Broadcasting;
10	|	Digital Video Broadcasting;

str# 802_11::Diagnostic_Request::Subelements::Device Types;
0	|	Reserved;
1	|	Reference Design;
2	|	Access Point or Wireless Routerfor Home or Small Office;
3	|	Enterprise Access Point;
4	|	Cable, DSL or Other Broadband Gateway;
5	|	Digital Still Camera;
6	|	Portable Video Camera;
7	|	Networked Web Camera;
8	|	Digital Audioï¿½Stationary;
9	|	Digital Audioï¿½Portable;
10	|	Set-Top Box, Media Extender, Media Server (includes players & recorders);
11	|	Display Device (television, monitor, picture frame);
12	|	Game Console or GameConsole Adapter;
13	|	Gaming Device ï¿½ Portable;
14	|	Media Server or Media Adapter;
15	|	Network Storage Device;
16	|	External Card;
17	|	Internal Card;
18	|	Ultra-Mobile PC;
19	|	Notebook Computer;
20	|	PDA (Personal Digital Assistant);
21	|	Printer or Print Server (includes scanner and/or fax capability);
22	|	Phoneï¿½Dual-Mode;
23	|	Phoneï¿½Single-Mode;
24	|	Smartphoneï¿½Dual-Mode;
25	|	Smartphoneï¿½Single-Mode;
221 |	Other devices;
//Reserved 222ï¿½255

//----------------------------Type 81---------------------
void 802_11::Diagnostic_Report()
{
	HBYT( 0, l[1], 0x90, 0xc2, "Diagnostic Token:" );
	HBYT( 0, l[2], 0x90, 0xc2, "Diagnostic Report Type:" );
		CST#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Report::Type );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	HBYT( 0, l[3], 0x90, 0xc2, "Diagnostic Status:" );	
		CST#( 0, l[2], 0, 0x14, 802_11::Event_Report::Event Report Status );
	g[2] -= 3;
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc7, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::Diagnostic_Request::Subelements::Call );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
		LABL( 0, 0, 0, 0xb8 );
	}
	TRTS;
}
//------------------------------------------------------

//----------------------------Type 82-----------LOC Param----------
void 802_11::Location_Parameters()
{
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc7, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::Location_Parameters::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::Location_Parameters::Subelements::Call );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
		LABL( 0, 0, 0, 0xb8 );
	}
}


void 802_11::Location_Parameters::Location_Indication_Options()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Options Used:" );	g[2] -= 1;
	CHR#( 0, g[20], 0x90, 0xc2, "Indication Parameters:" );	g[2] -= g[20];	g[20] -= g[20];
}
void 802_11::Location_Parameters::Time_Of_Departure()
{
	BLNG( 0x40000000, l[2], 0x90, 0xc2, "TOD Timestamp :" );	g[2] -= 4;	g[20] -= 4;
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "TOD RMS:" );	g[2] -= 2;	g[20] -= 2;
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "TOD Clock Rate:" );	g[2] -= 2;	g[20] -= 2;
}
void 802_11::Location_Parameters::Location_Indication_Broadcast_Data_Rate()
{
	DLNG( 0x40000000, l[2], 0x90, 0xc2, "Broadcast Target Data Rate:" );	g[2] -= 4;	g[20] -= 4;
}
void 802_11::Location_Parameters::Motion()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Motion Indicator:" );	g[2] -= 1;	g[20] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Location_Parameters::Motions );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Bearing:" );	g[2] -= 2;	g[20] -= 2;
	DBYT( 0, l[2], 0x90, 0xc2, "Speed Units:" );	g[2] -= 1;	g[20] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Location_Parameters::Speed Units );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Horizontal Speed:" );	g[2] -= 2;	g[20] -= 2;
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Vertical Speed:" );	g[2] -= 2;	g[20] -= 2;

}

void 802_11::Location_Parameters::Radio_Information()
{
	HBYT( 0, l[1], 0x90, 0xc2, "Transmit Power(DB):" );  g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "Antenna ID:" );		g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "Antenna Gain(db):" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[4], 0x90, 0xc2, "Antenna Type:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[5], 0x90, 0xc2, "RSNI:" );  g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[6], 0x90, 0xc2, "RCPI:" );  g[2] -= 1;	g[20] -= 1;
}
void 802_11::Location_Parameters::Location_Status()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Config Subelement ID:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "Status:" );	g[2] -= 1;	g[20] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Event_Report::Event Report Status );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
}
void 802_11::Location_Parameters::Location_Indication_Channels()
{
	while (g[20] != 0)
	{
		DBYT( 0, l[1], 0x90, 0xc2, "Regulatory Class:" );	g[2] -= 1;	g[20] -= 1;
		DBYT( 0, l[2], 0x90, 0xc2, "Channel:" );	g[2] -= 1;	g[20] -= 1;
	}
}
void 802_11::Location_Parameters::Location_Indication_Parameters()
{
	ETHR( 0, 0, 0x90, 0xc2, "Indication Multicast Address:" );	g[2] -= 6;	g[20] -= 6;
	DBYT( 0, l[2], 0x90, 0xc2, "Interval Units:" );	g[2] -= 1;	g[20] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Location_Parameters::Location_Indication_Parameters::Interval Units );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "Normal Report Interval:" );	g[2] -= 2;	g[20] -= 2;
	DBYT( 0, l[4], 0x90, 0xc2, "Normal Number of Frames per Channel:" );	g[2] -= 1;	g[20] -= 1;
	DWRD( 0x40000000, l[5], 0x90, 0xc2, "In-Motion Report Interval:" );	g[2] -= 2;	g[20] -= 2;
	DBYT( 0, l[6], 0x90, 0xc2, "In-Motion Number of Frames per Channel:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[7], 0x90, 0xc2, "Burst Inter-frame Interval:" );	g[2] -= 1;	g[20] -= 1;	
	DBYT( 0, l[8], 0x90, 0xc2, "Tracking Duration:" );	g[2] -= 1;	g[20] -= 1;
	DBYT( 0, l[9], 0x90, 0xc2, "ESS Detection Interval:" );	g[2] -= 1;	g[20] -= 1;
}




str# 802_11::Location_Parameters::Location_Indication_Parameters::Interval Units;
0	|	Hours;
1	|	Minutes;
2	|	Seconds;
3 	|	Milliseconds;

str# 802_11::Transition_Event_Request::Subelements;
0	|	Transition Target BSSID;
1	|	Transition Source BSSID;
2	|	Transition Time Threshold;
3	|	Transition Result;
4	|	Frequent Transition;

str# 802_11::Transition_Event_Request::Subelements::Call;
0	|	802_11::Transition_Event_Request::Transition Target BSSID;
1	|	802_11::Transition_Event_Request::Transition Source BSSID;
2	|	802_11::Transition_Event_Request::Transition Time Threshold;
3	|	802_11::Transition_Event_Request::Transition Result;
4	|	802_11::Transition_Event_Request::Frequent Transition;

str# 802_11::Location_Parameters::Speed Units;
0	|	Centimeters per second;
1	|	Meters per second;

str# 802_11::Location_Parameters::Motions;
0	|	Stationary: the device is stationary and not in motion;
1	|	Start of motion: the device was stationary and is now in motion;
2	|	In motion: the device isand has been in motion;
3	|	End of motion: the device was inmotion andis now stationary;
4	|	Unknown: information related to motion is unknown;

str# 802_11::Location_Parameters::Subelements;
1	|	Location Indication Parameters;
2	|	Location Indication Channels;
3	|	Location Status;
4	|	Radio Information;
5	|	Motion;
6	|	Location Indication Broadcast Data Rate;
7	|	Time Of Departure;
8	|	Location Indication Options;
221	|	Vendor Specific;

str# 802_11::Location_Parameters::Subelements::Call;
1	|	802_11::Location_Parameters::Location_Indication_Parameters;
2	|	802_11::Location_Parameters::Location_Indication_Channels;
3	|	802_11::Location_Parameters::Location_Status;
4	|	802_11::Location_Parameters::Radio_Information;
5	|	802_11::Location_Parameters::Motion;
6	|	802_11::Location_Parameters::Location_Indication_Broadcast_Data_Rate;
7	|	802_11::Location_Parameters::Time_Of_Departure;
8	|	802_11::Location_Parameters::Location_Indication_Options;
221	|	802_11::IE_Type_221;

str# 802_11::Diagnostic_Report::Type::Call;
//0	|	802_11::Diagnostic_Report::Type::Cancel Diagnostic Request;
1	|	802_11::Diagnostic_Report::Type::Manufacturer Information STA Report;
2	|	802_11::Diagnostic_Report::Type::Configuration Profile;
3	|	802_11::Diagnostic_Report::Type::Association Diagnostic;
4	|	802_11::Diagnostic_Report::Type::IEEE 802.1X Authentication Diagnostic;
221	|	802_11::IE_Type_221;

str# 802_11::Diagnostic_Report::Type;
0	|	Cancel Diagnostic Report;
1	|	Manufacturer Information STA Report;
2	|	Configuration Profile;
3	|	Association Diagnostic;
4	|	IEEE 802.1X Authentication Diagnostic;
221	|	Vendor Specific;

str# 802_11::Diagnostic_Request::Subelements::Call;
0	|	802_11::Diagnostic_Request::Subelements::Credential Type;
1	|	802_11::Diagnostic_Request::Subelements::AKM Suite;
2	|	802_11::Diagnostic_Request::Subelements::AP Descriptor;
3	|	802_11::Diagnostic_Request::Subelements::Antenna Type;
4	|	802_11::Diagnostic_Request::Subelements::Cipher Suite;
5	|	802_11::Diagnostic_Request::Subelements::Collocated Radio Type;
6	|	802_11::Diagnostic_Request::Subelements::Device Type;
7	|	802_11::Diagnostic_Request::Subelements::EAP Method;
8	|	802_11::Diagnostic_Request::Subelements::Firmware Version;
9	|	802_11::Diagnostic_Request::Subelements::MAC Address;
10	|	802_11::Diagnostic_Request::Subelements::Manufacturer ID String;
11	|	802_11::Diagnostic_Request::Subelements::Manufacturer Model String;
12	|	802_11::Diagnostic_Request::Subelements::Manufacturer OI;
13	|	802_11::Diagnostic_Request::Subelements::Manufacturer Serial Number String;
14	|	802_11::Diagnostic_Request::Subelements::Power Save Mode;
15	|	802_11::Diagnostic_Request::Subelements::Profile ID;
16	|	802_11::Diagnostic_Request::Subelements::Supported Regulatory Classes;
17	|	802_11::Diagnostic_Request::Subelements::Status Code;
18	|	802_11::Diagnostic_Request::Subelements::SSID;
19	|	802_11::Diagnostic_Request::Subelements::Tx Power Capability;
20	|	802_11::Diagnostic_Request::Subelements::Certificate ID;

str# 802_11::Diagnostic_Request::Credential Values;
0	|	None;
1	|	Pre-shared key;
2	|	Username and password;
3	|	X.509 certificate;
4	|	Other certificate;
5	|	One time password;
6	|	Token;


str#  802_11::Transition_Event_Report::Transition Reason;
0	|	Unspecified;
1	|	Excessive frame loss rates and/or poor conditions;
2	|	Excessive delay for current traffic streams;
3	|	Insufficient QoS capacity for currenttraffic streams (TSPEC rejected);
4	|	First association to ESS (the association initiated by an Association Request message instead of a Reassociation Request message);
5	|	Load balancing;
6	|	Better AP found;
7	|	Deauthenticated or Disassociated from the previous AP;
8	|	AP failed IEEE 802.1X EAP Authentication;
9	|	AP failed 4-Way Handshake;
10	|	Received too many replay counter failures;
11	|	Received too many data MIC failures;
12	|	Exceeded maximum number of retransmissions;
13	|	Received too many broadcast disassociations;
14	|	Received too many broadcast deauthentications;
15	|	Previous transition failed;
16	|	Low RSSI;
17	|	Roam from a non-IEEE 802.11 system;
18	|	Transition due to received BSS Transition Request frame;
19	|	Preferred BSS Transition Candidate List Included;
20	|	Leaving ESS;

str# 802_11::Peer-to-PeerLink_Rep::Peer Status;
0	|	Direct Link terminated;
1	|	Direct Link active;
2	|	IBSS membership terminated;
3	|	IBSS membership active;


str# 802_11::Event_Report::Event_Type::Call;
0	|	802_11::Transition_Event_Report;
1	|	802_11::RSNA_E_Rep;
2	|	802_11::Peer-to-PeerLink_Rep;
3	|	802_11::WNMLog;
221	|	802_11::Information_Element_Loop;

str# 802_11::Event_Report::Event_Type;
0	|	Transition;
1	|	RSNA;
2	|	Peer-to-Peer Link;
3	|	WNM Log;
221	|	Vendor Specific; *221

str# 802_11::Event_Report::Event Report Status;
0	|	Successful;
1	|	Request failed;
2	|	Request refused;
3	|	Request incapable;
4	|	Detected frequent transition;
//--------------------------------------------------------

//----------------------------Type 83---------------------
void 802_11::Non-transmitted_BSSID_Capability()
{
	BWRD( 0x40000000, l[2], 0x90, 0xc2, "Nontransmitted BSSID Capability:" );	g[2] -= 2;
	TRTS;
}

//---------------------
void 802_11::SSID_List()
{
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
		if (l[2] == 0x0001)
		{
			LABL( 0, 0, 0, 0x14, "SSID" );
			DBYT( 0, l[3], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			CHR#( 0, l[3], 0x90, 0xc2, "SSID:" );	g[2] -= l[3];		
		}
		if (l[2] != 0x0001)
		{
			LABL( 0, 0, 0, 0x14, "unknown SE" );
			DBYT( 0, l[3], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			CHR#( 0, l[3], 0x90, 0xc2, "unknown:" );	g[2] -= l[3];		
		}
	}	
	TRTS;
}
//----------------------------Type 83---------------------
void 802_11::Multiple_BSSID-Index()
{
	HBYT( 0, l[2], 0x90, 0xc2, "BSSID Index:" );	g[2] -= 1;
	if (g[2] != 0)
	{
		DBYT 0 0 90 c2 DTIM Count:;	g[2] -= 1;
	}
	if (g[2] != 0)
	{
		DBYT 0 0 90 c2 DTIM Period:;	g[2] -= 1;
	}
	TRTS;
}
//---------------------
void 802_11::FMS_Descriptor()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Number of FMS Counters:" );	g[2] -= 1;
	if (g[2] == 0)
	{
		LABL( 0, 0, 0, 0x14, "no FMS streams are accepted at the AP" );
	}
	l[2] -= 1;
	if (g[2] != 0)
	{
		while (l[2] != 0)
		{
			BBYT( 0, l[3], 0x90, 0xc7, "FMS Counters:" );	g[2] -= 1; l[2] -= 1;
			DECR 1;
				BBIT( 5, l[3], 0x90, 0xc2, "Current Count:" ); 
				BBIT( 3, l[3], 0x90, 0xc2, "FMS Counter ID:" );
			LABL( 0, 0, 0, 0xb8 );
			BBYT( 0, l[3], 0x90, 0xc2, "FMSIDs:" );	g[2] -= 1; l[2] -= 1;
		}
	}
	TRTS;
}
//---------------------
void 802_11::FMS_Request()
{
	DBYT( 0, l[2], 0x90, 0xc2, "FMS Token:" );	g[2] -= 1;
	LABL( 0, 0, 0x90, 0xc9, "Request subelements:" ); 
		while (g[2] != 0)
		{
			DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
				CST#( 0, l[2], 0, 0x14, 802_11::FMS_Request::Subelements );
				CLSE( 0, 0, 0, 0x14, "Reserved" );
			DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
				TSB#( 0, l[2], 0, 0x14, 802_11::FMS_Request::Subelements );
				TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
		}
	LABL( 0, 0, 0, 0xb8 );
	TRTS;
}
str# 802_11::FMS_Request::Subelements;
1	|	FMS subelement;
221	|	Vendor Specific;

str# 802_11::FMS_Request::Subelements::Call;
1	|	802_11::FMS_subelement;
221	|	802_11::IE_Type_221;

void 802_11::FMS_subelement()
{
	HBYT( 0, l[2], 0x90, 0xc2, "Delivery Interval:" );	g[2] -= 1;
	HBYT( 0, l[2], 0x90, 0xc2, "Max Delivery Interval:" );	g[2] -= 1;
	HLNG( 0, l[2], 0x90, 0xc2, "Rate Identification:" );	g[2] -= 4;
	CHR#( 0, l[2], 0x90, 0xc2, "TCLAS Elements:" );	g[2] -= g[2];	
}
//---------------------
void 802_11::FMS_Response()
{
	DBYT( 0, l[2], 0x90, 0xc2, "FMS Token:" );	g[2] -= 1;
	LABL( 0, 0, 0x90, 0xc9, "Response subelements:" ); 
		while (g[2] != 0)
		{
			DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
				CST#( 0, l[2], 0, 0x14, 802_11::FMS_Request::Subelements );
				CLSE( 0, 0, 0, 0x14, "Reserved" );
			DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
				TSB#( 0, l[2], 0, 0x14, 802_11::FMS_Request::Subelements );
				TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );

		}
	LABL( 0, 0, 0, 0xb8 );
	TRTS;
}
str# 802_11::FMS_Response::Subelements;
1	|	FMS Status subelement;
2	|	TCLAS Status subelement;
221	|	Vendor Specific;

str# 802_11::FMS_Response::Subelements::Call;
1	|	802_11::FMS_status_subelement;
2	|	802_11::TCLAS_Status_subelement;
221	|	802_11::IE_Type_221;

void 802_11::FMS_status_subelement()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Element Status:" );	g[2] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::FMS_Response::FMS_Element_Status_TFS_Response_Status );
		CLSE( 0, 0, 0, 0x14, "Reserved" );		
	DBYT( 0, l[3], 0x90, 0xc2, "Delivery Interval:" );	g[2] -= 1;
	DBYT( 0, l[4], 0x90, 0xc2, "Max Delivery Interval:" );	g[2] -= 1;
	DBYT( 0, l[5], 0x90, 0xc2, "FMSID:" );	g[2] -= 1;
	DBYT( 0, l[6], 0x90, 0xc2, "FMS Counter:" );	g[2] -= 1;
	DLNG( 0x40000000, l[7], 0x90, 0xc2, "Rate Identification:" );	g[2] -= 1;
	ETHR( 0, l[8], 0x90, 0xc2, "Multicast Address:" );	g[2] -= 1;
}
void 802_11::TCLAS_Status_subelement()
{
	DBYT( 0, l[5], 0x90, 0xc2, "FMSID:" );	g[2] -= 1;
	CHR#( 0, g[2], 0x90, 0xc2, "TCLAS Elements:" );	g[2] -= g[2];	
}
str# 802_11::FMS_Response::FMS_Element_Status_TFS_Response_Status;
0 |	Accept;
1 | Deny, due to request format error or ambiguous classifier;
2 | Deny, due to lack of resources on AP;
3 | Deny, due to requested classifier(s) matching 2 or more existing streams on different intervals;
4 | Deny, by policy, requested stream or filter is not permitted to participate in the service;
5 | Deny, reason unspecified;
6 | Alternate Preferred, due to existing stream with di fferent delivery interval;
7 | Alternate Preferred, due to policy limits on AP;
8 | Alternate Preferred, due to AP changed the delivery interval;
9 | Alternate Preferred, due to AP multicast rate policy;
10 | Terminate, due to AP policy change;
11 | Terminate, due to lack of resources of AP;
12 | Terminate, due to other FMS stream with higher priority;
13 | Alternate Preferred, due to AP changed the maximum delivery interval;
14 | Alternate Preferred, due to AP unable to provide requested TCLAS-based classifiers;
//---------------------
void 802_11::QoS_Traffic_Capability()
{
	BBYT( 0, l[1], 0x90, 0xc2, "QoS Traffic Capability Bitmask/Flags:" );	g[2] -= 1;
		CEQU( 0, l[1], 0x0, 0xd4, ".......1 Reserved: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 Reserved: disabled" );
		CEQU( 1, l[1], 0x0, 0xd4, "......1. UP 6 Traffic: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, "......0. UP 6 Traffic: disabled" );
		CEQU( 2, l[1], 0x0, 0xd4, ".......1 UP 5 Traffic: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 UP 5 Traffic: disabled" );
		CEQU( 3, l[1], 0x0, 0xd4, ".......1 UP 4 Traffic: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 UP 4 Traffic: disabled" );
		CEQU( 4, l[1], 0x0, 0xd4, ".......1 Reserved: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 Reserved: disabled" );
		CEQU( 5, l[1], 0x0, 0xd4, ".......1 Reserved: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 Reserved: disabled" );
		CEQU( 6, l[1], 0x0, 0xd4, ".......1 AC_VI: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 AC_VI: disabled" );
		CEQU( 7, l[1], 0x0, 0xd4, ".......1 AC_VO: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 AC_VO: disabled" );
	CHR#( 0, g[2], 0x90, 0xc9, "AC STA Count List:" );
		DECR( 0, g[2] );
		while (g[2] != 0)
		{
			BBYT( 0, l[2], 0x90, 0xc2, "STA Count:" );	g[2] -= 1;
		}
	LABL( 0, 0, 0, 0xb8 );
	//CHR#( 0, g[2], 0x90, 0xc2, "AC STA Count List:" );	g[2] -= g[2];
	TRTS;
}
//---------------------
void 802_11::BSS_Max_Idle_Period()
{
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "Max Idle Period:" );	g[2] -= 2;
	BBYT( 0, l[2], 0x90, 0xc2, "Idle Options:" );	g[2] -= 1;
		CEQU( 7, l[2], 0x0, 0xd4, ".......1 Protected Keep-Alive Required: yes" );
		CLSE( 0, l[2], 0x0, 0xd4, ".......0 Protected Keep-Alive Required: no" );
	TRTS;
}
//---------------------
void 802_11::TFS_Request()
{
	DBYT( 0, l[2], 0x90, 0xc2, "TFS ID:" );	g[2] -= 1;
	BBYT( 0, l[1], 0x90, 0xc2, "TFS Action Code:" );	g[2] -= 1;
		CEQU( 6, l[1], 0x0, 0xd4, ".......1 Notify: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 Notify: disabled" );
		CEQU( 7, l[1], 0x0, 0xd4, ".......1 Delete after match: enabled" );
		CLSE( 0, l[1], 0x0, 0xd4, ".......0 Delete after match: disabled" );
	LABL( 0, 0, 0x90, 0xc9, "TFS Request subelements:" ); 
		while (g[2] != 0)
		{
			DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
				CST#( 0, l[2], 0, 0x14, 802_11::TFS_Request::Subelements );
				CLSE( 0, 0, 0, 0x14, "Reserved" );
			DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
				TSB#( 0, l[2], 0, 0x14, 802_11::TFS_Request::Subelements );
				TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );

		}
	LABL( 0, 0, 0, 0xb8 );
	TRTS;
}
str# 802_11::TFS_Request::Subelements;
1	|	TFS subelement;
221	|	Vendor Specific;
str# 802_11::TFS_Request::Subelements::Call;
1	|	802_11::TFS_subelement;
221	|	802_11::IE_Type_221;

void 802_11::TFS_subelement()
{
	CHR#( 0, g[2], 0x90, 0xc2, "TCLAS Elements:" );	g[2] -= g[2];
	TRTS;
}
//---------------------
void 802_11::TFS_Response()
{
	LABL( 0, 0, 0x90, 0xc9, "Status subelements:" );
	while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::TFS_Response::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[2], 0, 0x14, 802_11::TFS_Response::Subelements );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
	}
	LABL( 0, 0, 0, 0xb8 );
	TRTS;
}

str# 802_11::TFS_Response::Subelements;
1	|	TFS Status subelement;
2	|	TFS subelement;
221	|	Vendor Specific;

str# 802_11::TFS_Response::Subelements::Call;
1	|	802_11::TFS_Status_subelement;
2	|	802_11::TFS_subelement;
221	|	802_11::IE_Type_221;

void 802_11::TFS_Status_subelement()
{
	DBYT( 0, l[1], 0x90, 0xc2, "TFS Respons Status:" );	g[2] -= 1;
	DBYT( 0, l[1], 0x90, 0xc2, "TFS ID:" );	g[2] -= 1;
	TRTS;
}
//---------------------
void 802_11::WNM-Sleep_Mode()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Action Type:" );	g[2] -= 1;
		CST#( 0, l[1], 0, 0x14, 802_11::WNM-Sleep_Mode::Action_Type );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[2], 0x90, 0xc2, "WNM-Sleep Mode Response Status:" );	g[2] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::WNM-Sleep_Mode_Response_Status_definition );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "WNM-Sleep Interval:" );	g[2] -= 2;
	TRTS;
}
str# 802_11::WNM-Sleep_Mode::Action_Type;
0	|	Enter WNM-Sleep Mode;
1	|	Exit WNM-Sleep Mode;
str# 802_11::WNM-Sleep_Mode_Response_Status_definition;
0	|	Enter/Exit WNM-Sleep Mode Accept;
1	|	Exit WNM-Sleep Mode Ac cept, GTK/IGTK update required;
2	|	Denied, The AP is unable to perform the requested action;
3	|	Denied temporarily, The AP is unable to perform the requested action at the current time, The request can be submitted ag ain at a later time;
4	|	Denied, Due to the pending key expiration;
5	|	Denied, The requested action cannot be granted due to other WNM services in use by the requesting STA;
//---------------------
//
void 802_11::TIM_Broadcast_Request()
{
	DBYT( 0, l[1], 0x90, 0xc2, "TIM Broadcast Interval:" );	g[2] -= 1;
	TRTS;
}
//---------------------
void 802_11::TIM_Broadcast_Response()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Status:" );	g[2] -= 1;
		CST#( 0, l[1], 0, 0x14, 802_11::TIM_Broadcast_Response::Status );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[2], 0x90, 0xc2, "TIM Broadcast Interval:" );	g[2] -= 1;
	if (g[2] >= 4)
	{
		DLNG( 0x40000000, l[3], 0x90, 0xc2, "TIM Broadcast Offset:" );	g[2] -= 4;
	}
	if (g[2] >= 2)
	{
		DWRD( 0x40000000, l[4], 0x90, 0xc2, "High Rate TIM Rate:" );	g[2] -= 2;
	}
	if (g[2] >= 2)
	{
		DWRD( 0x40000000, l[5], 0x90, 0xc2, "Low Rate TIM Rate:" );	g[2] -= 2;
	}
	TRTS;
}
str# 802_11::TIM_Broadcast_Response::Status;
0	|	Accept;
1	|	Accept, valid timestamp present in TIM frames;
2	|	Denied;
3	|	Overridden;
//---------------------
void 802_11::Collocated_Interference_Report()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Report Period:" );	g[2] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "Interference Level:" );	g[2] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "Interference Level Accuracy/Interference Index:" );	g[2] -= 1;
	HLNG( 0x40000000, l[4], 0x90, 0xc2, "Interference Interval:" );	g[2] -= 4;
	DLNG( 0x40000000, l[5], 0x90, 0xc2, "Interference Burst Length:" );	g[2] -= 4;
	DLNG( 0x40000000, l[6], 0x90, 0xc2, "Interference Start Time/Duty Cycle:" );	g[2] -= 4;
	DLNG( 0x40000000, l[7], 0x90, 0xc2, "Interference Center Frequency:" );	g[2] -= 4;
	DWRD( 0x40000000, l[8], 0x90, 0xc2, "Interference Bandwidth:" );	g[2] -= 2;
	TRTS;
}
//---------------------
void 802_11::Channel_Usage()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Usage Mode:" );	g[2] -= 1;
		CST#( 0, l[1], 0, 0x14, 802_11::Channel_Usage::Mode_definitions );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	l[2] = g[2];
	l[2] /= 2;
	while (l[2] != 0)
	{
		DWRD( 0x40000000, l[3], 0x90, 0xc2, "Channel Entry:" );	g[2] -= 2;
		l[2] -= 1;
	}
	TRTS;
}
str# 802_11::Channel_Usage::Mode_definitions;
0	|	Non-infrastructure IEEE 802.11 network;
1	|	Off-channel TDLS direct link;
//---------------------
void 802_11::Time_Zone()
{
	CHR#( 0, g[2], 0x90, 0xc2, "Time Zone:" );	g[2] -= g[2];
	TRTS;
}
//---------------------

 void 802_11::DMS_Request()
{
	LABL( 0, 0, 0x90, 0xc9, "DMS Descriptor List:" );
	while (g[2] != 0)
	{
		DBYT( 0, l[1], 0x90, 0xc2, "DMS ID:" );	g[2] -= 1;
		DBYT( 0, l[2], 0x90, 0xc2, "DMS Length:" );	g[2] -= 1;
		DBYT( 0, l[3], 0x90, 0xc2, "DMS Request Type:" );	g[2] -= 1;
			CST#( 0, l[3], 0, 0x14, 802_11::DMS_Request::Request_Type );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		*CHR#( 0, g[2], 0x90, 0xc2, "TCLAS Elements:" );	g[2] -= g[2];
		*HEX#( 0, g[2], 0x90, 0xc2, "TCLAS Elements:" );	g[2] -= g[2];

		* SamChen
		if (g[2] >= 2)
		{
			LABL( 0, 0, 0x90, 0xc9, "TCLAS Elements:" );
			DBYT( 0, 0, 0x90, 0xc2, "Element ID:" );	g[2] -= 1;
			DBYT( 0, l[4], 0x90, 0xc2, "Length:" );	    g[2] -= 1;

			while (l[4] > 0)
			{
				DBYT( 0, 0, 0x90, 0xc2, "User Priority:" );
				g[2] -= 1;
				l[4] -= 1;
				DBYT( 0, 0, 0x90, 0xc2, "Classifier Type:" );
				g[2] -= 1;
				l[4] -= 1;
				DBYT( 0, 0, 0x90, 0xc2, "Classifier Mask:" );
				g[2] -= 1;
				l[4] -= 1;
				DBYT( 0, l[5], 0x90, 0xc2, "Version:" );
				g[2] -= 1;
				l[4] -= 1;

				if (l[5] == 4)
				{
					* IPv4
					IPLG 0 0 90 c2 Source IP Address:;
					IPLG 0 0 90 c2 Destination IP Addr:;
					DWRD 0 0 90 c2 Source Port:;
					DWRD 0 0 90 c2 Destination Port:;
					DBYT 0 0 90 c2 DSCP:;
					DBYT 0 0 90 c2 Protocol:;
					DBYT 0 0 90 c2 Reserved:;
					g[2] -= 15;
					l[4] -= 15;
				}

				if (l[5] == 6)
				{
					* IPv6
					IPV6 0 0 90 c2 Source IP Address:;
					IPV6 0 0 90 c2 Destination IP Addr:;
					DWRD 0 0 90 c2 Source Port:;
					DWRD 0 0 90 c2 Destination Port:;
					DEC# 3 0 90 c2 Flow Label:;
					g[2] -= 39;
					l[4] -= 39;
				}

				if (l[4] != 0)
				{
					HEX#( 0, g[2], 0x90, 0xc2, "TCLAS Optional:" );
					g[2] -= g[2];
					l[4] -= l[4];
				}
			}
		}
	}
	LABL( 0, 0, 0, 0xb8 );
	TRTS;
}
str# 802_11::DMS_Request::Request_Type;
0	|	Add;
1	|	Remove;
2	|	Change;
//---------------------
 void 802_11::DMS_Response()
{
	LABL( 0, 0, 0x90, 0xc9, "DMS Status List:" );
	while (g[2] != 0)
	{
		* SamChen
		DBYT( 0, 0, 0x90, 0xc2, "DMS ID:" );		g[2] -= 1;
		DBYT( 0, 0, 0x90, 0xc2, "DMS Length:" );	g[2] -= 1;
		DBYT( 0, l[1], 0x90, 0xc2, "DMS Response Type:" );	g[2] -= 1;
			CST#( 0, l[1], 0, 0x14, 802_11::DMS_Request::Response_Type );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		HEX#( 0, g[2], 0x90, 0xc2, "Last Sequence Control:" );	g[2] -= g[2];
		*DWRD( 0x40000000, l[2], 0x90, 0xc2, "Last Sequence Control:" );	g[2] -= 2;
		*CHR#( 0, g[2], 0x90, 0xc2, "TCLAS Elements:" );	g[2] -= g[2];
		*HEX#( 0, g[2], 0x90, 0xc2, "TCLAS Elements:" );	g[2] -= g[2];
	}
	LABL( 0, 0, 0, 0xb8 );
	TRTS;
}
str# 802_11::DMS_Request::Response_Type;
0	|	Accept;
1	|	Denied;
2	|	Terminate;
//---------------------
 void 802_11::Destination_URI()
{
	DBYT( 0, l[1], 0x90, 0xc2, "ESS Detection Interval:" );	g[2] -= 1;
	CHR#( 0, g[2], 0x90, 0xc2, "URI:" );	g[2] -= g[2];
	TRTS;
}
//---------------------
 void 802_11::U-APSD_Coexistence()
{
	D64B( 0x40000000, l[1], 0x90, 0xc2, "TSF 0 Offset:" );	g[2] -= 8;
	DLNG( 0x40000000, l[7], 0x90, 0xc2, "Interval/Duration:" );	g[2] -= 4;
	LABL( 0, 0, 0x90, 0xc9, "Optional subelements:" );
	DUMP( 0, g[2], 0x90, 0xc2, "data:" ); g[2] -= g[2];
	/*while (g[2] != 0)
	{
		DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );	g[2] -= 1;
			CST#( 0, l[2], 0, 0x14, 802_11::U-APSD_Coexistence::Subelements );
			CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0, g[20], 0x90, 0xc2, "Subelement Length:" );	g[2] -= 1;
			TSB#( 0, l[3], 0, 0x14, 802_11::U-APSD_Coexistence::Subelements );
			TLSE( 0, 0, 0, 0, 802_11::Subelementsfail );
	}*/
	LABL( 0, 0, 0, 0xb8 );
}
str# 802_11::U-APSD_Coexistence::Subelements;
221	|	Vendor Specific;
str# 802_11::U-APSD_Coexistence::Subelements::Call;
221	|	802_11::IE_Type_221;

//Type 101---------------------
//8.4.2.64 Link Identifier element
//-------------------------------------------------
void 802_11::Link_Identifier()
{
	ETHR 0 0 90 C2 BSSID:;
	ETHR 0 0 90 C2 TDLS initiator STA Address:;
	ETHR 0 0 90 C2 TDLS responder STA Address:;
	g[2] -= 18;
}
//-------------------------------------------------
void 802_11::TDLS_Link_Identifier()
{
	LABL 0 0 0 b7 Link Identifier;
	DBYT( 0, 0, 0x90, 0xc2, "Link Identifier Tag:");
	DBYT( 0, l[2], 0x90, 0xc2, "Length:");
	ETHR 0 0 90 c2 BSSID:;
	ETHR 0 0 90 C2 TDLS initiator STA Address:;
	ETHR 0 0 90 C2 TDLS responder STA Address:;
	g[2] -= 18;
	LABL 0 0 0 b8;
}
//------------------------------------------------------
//Type 102---------------------
//8.4.2.65 Wakeup Schedule element
void 802_11::Wakeup_Schedule()
{
	if( g[2] == 18 )
	{
		DLNG( 0x40000000, l[1], 0x90, 0xc2, "Offset:" );	g[2] -= 4;
		DLNG( 0x40000000, l[2], 0x90, 0xc2, "Interval:" );	g[2] -= 4;
		DLNG( 0x40000000, l[2], 0x90, 0xc2, "Awake Window Slots:" );	g[2] -= 4;
		DLNG( 0x40000000, l[2], 0x90, 0xc2, "Maximum Awake Window Duration:" );	g[2] -= 4;
		DWRD( 0x40000000, l[2], 0x90, 0xc2, "Idle Count:" );	g[2] -= 2;
	}
}
//------------------------------------------------------
//Type 103---------------------
//reserved
//------------------------------------------------------
//Type 104---------------------
//Channel Switch Timing
void 802_11::Channel_Switch_Timing()
{
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "SwitchTime:" );	g[2] -= 2;
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Switch Timeout:" );	g[2] -= 2;
}
//------------------------------------------------------
//Type 105---------------------
//PTI Control element
void 802_11::PTI_Control()
{
	BBYT( 0, l[2], 0x90, 0xc2, "TID:" );	g[2] -= 1;
	DWRD( 0x40000000, l[2], 0x90, 0xc2, "Sequence Control:" );	g[2] -= 2;
}
//------------------------------------------------------
//Type 106---------------------
//8.4.2.68 TPU Buffer Status element
void 802_11::TPU_Buffer_Status()
{
	DBYT( 0, l[2], 0x90, 0xc2, "TID:" );	g[2] -= 1;
}
//------------------------------------------------------
//Type 107
//Interworking (see 8.4.2.94) 107 3, 5, 9, 11
//start_802.11u-2011------------------------------------------
void 802_11::IE_Type_107()
{
	*BBYT( 0, l[1], 0x90, 0xc7, "Access Network Options:" );
	* Fix for TT 29072
	HBYT( 0, l[1], 0x90, 0xc9, "Access Network Options:" );
	DECR 2;
	GBYT( 0, l[8] );
	INCR 1;
	*DECR 1;
	
		BBIT( 1, l[6], 0x90, 0xc2, "UESA" );
			CEQU( 1, l[6], 0x0, 0x14, "higher layer unauthenticated emergency services are reachable through this AP" );
			CLSE( 0, 0, 0, 0x14, "no unauthenticated emergency services are reachable through this AP" );
		BBIT( 1, l[5], 0x90, 0xc2, "ESR" );
			CEQU( 1, l[5], 0x0, 0x14, "emergency services are reachable through the AP" );
			CLSE( 0, 0, 0, 0x14, "unspecified whether emergency services are reachable" );
		BBIT( 1, l[4], 0x90, 0xc2, "ASRA" );
			CEQU( 1, l[4], 0x0, 0x14, "the network requires a further step for access" );
			CLSE( 0, 0, 0, 0x14, "dot11RSNAEnabled should be true" );
		BBIT( 1, l[3], 0x90, 0xc2, "Internet" );
			CEQU( 1, l[4], 0x0, 0x14, "true" );
			CLSE( 0, 0, 0, 0x14, "false" );	
		BBIT( 4, l[2], 0x90, 0xc2, "Access Network Type:" );
			CST#( 0, l[2], 0, 0x14, 802_11::Access_Network_Options );
			CLSE( 0, 0, 0, 0x14, "reserved" );	
		LABL( 0, 0, 0, 0xb8 );
	g[2] -= 1;
*	if (g[2] != 0)
*	INCR 1;

	if (l[8] == 3)
	{
		802_11::Venue_Info_field;
	}

	if (l[8] == 7)
	{
		HEX#( 6, 0, 0x90, 0xc2, "HESSID:" );
		*g[2] -= 6;
	}

	if (l[8] == 9)
	{
		802_11::Venue_Info_field;
		HEX#( 6, 0, 0x90, 0xc2, "HESSID:" );
		*g[2] -= 6;
	}

	TRTS;
}
//-------------------------------------------------
void 802_11::Venue_Info_field()
{
	BBYT( 0, l[1], 0x90, 0xc2, "Venue Group:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Venue_Group_codes );
		CLSE( 0, 0, 0, 0x14, "reserved" );
	BBYT( 0, l[1], 0x90, 0xc2, "Venue Type:" );
		CST#( 0, l[1], 0, 0x14, 802_11::Venue_Type_codes );
		CLSE( 0, 0, 0, 0x14, "reserved" );
	g[2] -= 2;
}

str# 802_11::Venue_Group_codes;
0	|	 Unspecified;
1	|	  Assembly;
2	|	  Business;
3	|	  Educational;
4	|	  Factory and Industrial;
5	|	  Institutional;
6	|	  Mercantile;
7	|	  Residential;
8	|	  Storage;
9	|	  Utility and Miscellaneous;
10	|	  Vehicular;
11	|	  Outdoor;
//12 ï¿½ 255 Reserved;
str# 802_11::Venue_Type_codes;
0x0100 | Unspecified Assembly;
0x0101 | Arena;
0x0102 | Stadium;
0x0103 | Passenger Terminal e.g., airport, bus, ferry, train station;
0x0104 | Amphitheater;
0x0105 | Amusement Park;
0x0106 | Place of Worship;
0x0107 | Convention Center;
0x0108 | Library;
0x0109 | Museum;
0x010A | Restaurant;
0x010B | Theater;
0x010C | Bar;
0x010D | Coffee Shop;
0x010E | Zoo or Aquarium;
0x010F | Emergency Coordination Center;
0x0200 | Unspecified Business;
0x0201 | Doctor or Dentist office;
0x0202 | Bank;
0x0203 | Fire Station;
0x0204 | Police Station;
0x0206 | Post Office;
0x0207 | Professional Office;
0x0208 | Research and jail;
0x0209 | Attorney Office;
0x0300 | Unspecified Educational;
0x0301 | School, Primary;
0x0302 | School, Secondary;
0x0303 | University or College;
0x0400 | Unspecified Factory and Industrial;
0x0401 | Factory;
0x0500 | Unspecified Institutional;
0x0501 | Hospital;
0x0502 | Long-Term Care Facility e.g., Nursing home, Hospice, etc.;
0x0503 | Alcohol and Drug Re-habilitation Center;
0x0504 | Group Home;
0x0505 | Prison or Jail;
0x0600 | Unspecified Mercantile;
0x0601 | Retail Store;
0x0602 | Grocery Market;
0x0603 | Automotive Service Station;
0x0604 | Shopping Mall;
0x0605 | Gas Station;
0x0700 | Unspecified Residential;
0x0701 | Private Residence;
0x0702 | Hotel or Motel;
0x0703 | Dormitory;
0x0704 | Boarding House;
0x0800 | Unspecified Storage;
0x0900 | Unspecified Utility and Miscellaneous;
0x0A00 | Unspecified Vehicular;
0x0A01 | Automobile or Truck;
0x0A02 | Airplane;
0x0A03 | Bus;
0x0A04 | Ferry;
0x0A05 | Ship or Boat;
0x0A06 | Train;
0x0A07 | Motor Bike;
0x0B00 | Unspecified Outdoor;
0x0B01 | Muni-mesh Network;
0x0B02 | City Park;
0x0B03 | Rest Area;
0x0B04 | Traffic Control;
0x0B05 | Bus Stop;
0x0B06 | Kiosk;
//------------------------------------------------- Advertisement Protocol 
//Type 108
void 802_11::IE_Type_108()
{
	l[2] = 1;
	while (g[2] != 0)
	{
		
		LABL( 0, 0, 0x90, 0xc2, "Advertisement Protocol Tuple # " );
		DGLB( 0, l[2], 0x02, 0 );
		l[2] += 1;
		LABL( 0, 0, 0, 0x02, ":" );
		BBYT( 0, l[3], 0x90, 0xc2, "Query Response Info:" );
			CBIT( 0, l[3], 0x90, 0xd4, ".... ...1 PAME-BI: the Query Response is independent of the BSSID" );
			CLSE( 0, l[3], 0x90, 0xd4, ".... ...0 PAME-BI: the Query Response may be dependent on the BSSID" );
		DECR 1;
		BBIT( 7, l[6], 0x90, 0xc2, "Query Response Length Limit:" );		
		BBIT( 1, 0, 0x05, 0x05 );
		g[2] -= 1;
		BBYT( 0, l[3], 0x90, 0xc2, "Query Response Info:" );
		g[2] -= 1;
		HEX#( 0, g[2], 0x90, 0xc2, "Advertisement Protocol ID:" );
	}
	TRTS;
}
str# 802_11::Advertisement_protocol_ID_defs;
0	|	Access Network Query Protocol (ANQP);
1	|	MIH Information Service;
2	|	MIH Command and Event Services Capability Discovery;
3	|	Emergency Alert System (EAS);
221	|	Vendor Specific;

//-------------------------------------------------
void 802_11::IE_Type_109()
{
	BBYT( 0, l[3], 0x90, 0xc2, "Precedence Level:" );
		CST#( 0, l[3], 0, 0x14, 802_11::Precedence_Level );
		CLSE( 0, 0, 0, 0x14, "reserved" );
	g[2] -= 1;
	TRTS;
}
str# 802_11::Precedence_Level;
0x10	|	Emergency call;
0x11	|	First responder (public);
0x12	|	First responder (private);
0x13	|	MLPP Level A;
0x14	|	MLPP Level B;
0x15	|	MLPP Level 0;
0x16	|	MLPP Level 1;
0x17	|	MLPP Level 2;
0x18	|	MLPP Level 3;
0x19	|	MLPP Level 4;
//-------------------------------------------------
void 802_11::IE_Type_110()
{
	l[2] = 0;
	if (g[2] > 16)
	{
		while( g[2] > 16)
		{
			LABL( 0, 0, 0x90, 0xc2, "DSCP Exception " );
			DGLB( 0, l[2], 0x02, 0 );
			LABL( 0, 0, 0, 0x02, ":" );
			DBYT( 0, l[3], 0x90, 0xc2, "DSCP Value:" );
				
			DBYT( 0, l[4], 0x90, 0xc2, "User Priority:" );
			g[2] -= 2;
			l[2] += 1;
		}
	}
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "UP 0 DSCP Range:" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "UP 1 DSCP Range:" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "UP 2 DSCP Range:" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "UP 3 DSCP Range:" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "UP 4 DSCP Range:" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "UP 5 DSCP Range:" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "UP 6 DSCP Range:" );
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "UP 7 DSCP Range:" );
	g[2] -= 16;
	TRTS;
}
//-------------------------------------------------
void 802_11::IE_Type_111()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Number of ANQP OIs:" );
	DBYT( 0, l[2], 0x90, 0xc7, "OI #1 and #2 Lengths:" );
	DECR 1;
	BBIT( 4, l[3], 0x90, 0xc2, "OI #1 Length" );
	BBIT( 4, l[4], 0x90, 0xc2, "OI #2 Length" );
	LABL( 0, 0, 0, 0xb8 );
	g[2] -= 2;
	HEX#( 0, l[3], 0x90, 0xc2, "OI #1:" );
	g[2] -= l[3];
	HEX#( 0, l[4], 0x90, 0xc2, "OI #2:" );
	g[2] -= l[4];
	if (g[2] != 0)
	{
		HEX#( 0, g[2], 0x90, 0xc2, "OI #3:" );	
	}	
	TRTS;
}
//-------------------------------------------------
void 802_11::IE_Type_112()
{
	HEX#( 8, 0, 0x90, 0xc2, "Alert Identifier Hash:" );
	g[2] -= 8;
	TRTS;
}

//-------------------------------------------------
str# 802_11::ANQP_information_ID;
0x00000100 | ANQP Query list;
0x00000101 | ANQP Capability list;
0x00000102 | Venue Name information;
0x00000103 | Emergency Call Number information;
0x00000104 | Network Authentication Type information;
0x00000105 | Roaming Consortium list;
0x00000106 | IP Address Type Availability information;
0x00000107 | NAI Realm list;
0x00000108 | 3GPP Cellular Network information;
0x00000109 | AP Geospatial Location;
0x0000010A | AP Civic Location;
0x0000010B | AP Location Public Identifier URI;
0x0000010C | Domain Name list;
0x0000010D | Emergency Alert Identifier URI;
0x0000010E | TDLS Capability;
0x0000010F | Emergency NAI;
0x00000110 | Neighbor Report;
0x0000DDDD | ANQP vendor-specific list;

str# 802_11::ANQP_information_ID_Ldr;
0x00000100 | 802_11::ANQP_Query_list;
0x00000101 | 802_11::ANQP_Capability_list;
0x00000102 | 802_11::Venue_Name_information;
0x00000103 | 802_11::Emergency_Call_Number_information;
0x00000104 | 802_11::Network_Authentication_Type_information;
0x00000105 | 802_11::Roaming_Consortium_list;
0x00000106 | 802_11::IP_Address_Type_Availability_information;
0x00000107 | 802_11::NAI_Realm_list;
0x00000108 | 802_11::3GPP_Cellular_Network_information;
0x00000109 | 802_11::AP_Geospatial_Location;
0x0000010A | 802_11::AP_Civic_Location;
0x0000010B | 802_11::AP_Location_Public_Identifier_URI;
0x0000010C | 802_11::Domain_Name_list;
0x0000010D | 802_11::Emergency_Alert_Identifier_URI;
0x0000010E | 802_11::TDLS_Capability;
0x0000010F | 802_11::Emergency_NAI;
0x00000110 | 802_11::Neighbor_Report;
0x0000DDDD | 802_11::ANQP_vendor-specific_list;
// -------------------------------------
void 802_11::Domain_Name_list()
{
	CHR#( 0, g[2], 0x90, 0xc2, "Payload:" );
}
// -------------------------------------
void 802_11::ANQP_Query_list()
{
	l[2] = 1;
	if (g[2] > 2)
	{
		while( g[2] > 0)
		{
			LABL( 0, 0, 0x90, 0xc2, "ANQP Query ID #" );
			DGLB( 0, l[2], 0x02, 0 );
			LABL( 0, 0, 0, 0x02, ":" );
			HWRD( 0x40000000, l[3], 0, 0x02, "" );
			CST#( 0, l[3], 0, 0x14, 802_11::ANQP_information_ID);
			g[2] -= 2;
			l[2] += 1;
		}
	}
	TRTS;
}
// -------------------------------------
void 802_11::ANQP_Capability_list()
{
	l[2] = 1;
		if (g[2] > 2)
	{
		while( g[2] > 0)
		{
			LABL( 0, 0, 0x90, 0xc2, "ANQP Capability ID #" );
			DGLB( 0, l[2], 0x02, 0 );
			LABL( 0, 0, 0, 0x02, ":" );
			HWRD( 0x40000000, l[3], 0, 0x02, "" );
			CST#( 0, l[3], 0, 0x14, 802_11::ANQP_information_ID);
			if (l[3] == 0xdddd)
			{
				HWRD( 0x40000000, l[3], 0x90, 0xc2, "Vendor-specific Capability Length:" );
				l[1] = pl[0];
				ANDG ffffff00 41;
				802_11::Print_OUI();
				//	DBYT 0 41 90 c2 Subtype:;
				g[2] -= 7;
				while (g[2] > 0)
					{
						DBYT 0 43 90 c2 Queried Subtype:;
							CST# 0 43 0 14 802_11::ANQP_vendor-specific_list_HS20_Type;
							CLSE 0 0 0 14 unknown;
						g[2] -= 1;
					}
				//HEX#( 0, g[2], 0x90, 0xc2, "Vendor Specific Content:" );
				g[2] -= g[2];
			}
			g[2] -= 2;
			l[2] += 1;
		}
	}
	TRTS;
}
// -------------------------------------
void 802_11::Venue_Name_information()
{
	HWRD( 0, l[3], 0x90, 0xc2, "Venue Info:" );
	g[2] -= 2;
	l[2] = 1;
	//here might be sth left
	if (g[2] == 2)
	{
		DBYT( 0, l[3], 0x90, 0xc2, "Venue Group:" );
		CST#( 0, l[3], 0, 0x14, 802_11::Venue_Name_information::Venue_Group );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
		DBYT( 0, l[4], 0x90, 0xc2, "Venue Type:" );
		g[2] -= 2;
	}
	if (g[2] > 4)
	{
		while( g[2] > 4)
		{
			LABL( 0, 0, 0x90, 0xc7, "Venue Name Duple #" );
			DGLB( 0, l[2], 0x02, 0 );
			LABL( 0, 0, 0, 0x02, ": " );
			DBYT( 0, l[3], 0x90, 0xc2, "Length:" );
			CHR#( 0, l[4], 0x90, 0xc2, "Language Code:" );			//ISO-14962-1997 encoded string 
			CHR#( 0, l[3], 0x90, 0xc2, "Venue Name:" );				//UTF-8 formatted field
			LABL( 0, 0, 0, 0xb8 );	
			l[3] += 1;
			g[2] -= l[3];
			l[2] += 1;
		}
	}
	TRTS;
}

str# 802_11::Venue_Name_information::Venue_Group;
0	|	Unspecified;
1	|	Assembly;
2	|	Business;
3	|	Educational;
4	|	Factory and Industrial;
5	|	Institutional;
6	|	Mercantile;
7	|	Residential;
8	|	Storage;
9	|	Utility and Miscellaneous;
10	|	Vehicular;
11	|	Outdoor;
// -------------------------------------
void 802_11::Emergency_Call_Number_information()
{
	l[2] = 1;
	if (g[2] > 4)
	{
		while( g[2] > 4)
		{
			LABL( 0, 0, 0x90, 0xc7, "Venue Name Duple #" );
			DGLB( 0, l[2], 0x02, 0 );
			LABL( 0, 0, 0, 0x02, ": " );
			DBYT( 0, l[3], 0x90, 0xc2, "Length:" );
			CHR#( 0, l[3], 0x90, 0xc2, "Emergency Call Number:" );
			LABL( 0, 0, 0, 0xb8 );	
			l[3] += 1;
			g[2] -= l[3];
			l[2] += 1;
		}
	}
	TRTS;
}
// -------------------------------------
void 802_11::Network_Authentication_Type_information()
{
	l[2] = 1;
	if (g[2] > 0)
	{
		while( g[2] > 3)
		{
			LABL( 0, 0, 0x90, 0xc7, "Network Authentication Type Unit #" );
			DGLB( 0, l[2], 0x02, 0 );
			LABL( 0, 0, 0, 0x02, ": " );
			DBYT( 0, l[4], 0x90, 0xc2, "Network Authentication Type Indicator:" );
				CST#( 0, l[4], 0, 0x14, 802_11::Network_Authentication_Type_Indicator_definitions );
				CLSE( 0, 0, 0, 0x14, "reserved" );
			DWRD( 0x40000000, l[5], 0x90, 0xc2, "Length:" );
			CHR#( 0x00000000, l[5], 0x90, 0xc2, "Re-direct URL:" );
			LABL( 0, 0, 0, 0xb8 );
			l[5] += 3;
			g[2] -= l[5];
			l[2] += 1;
		}
	}
	TRTS;
}
str# 802_11::Network_Authentication_Type_Indicator_definitions;
0x00 	|	Acceptance of terms and conditions;
0x01	|	Online enrollment supported;
0x02	|	http https redirection;
0x03	|	DNS redirection;
//4 - 255 Reserved

// ------------------------------------
void 802_11::Roaming_Consortium_list()
{
	l[2] = 1;
	if (g[2] > 2)
	{
		while( g[2] > 2)
		{
			LABL( 0, 0, 0x90, 0xc9, "OI Duple #" );
			DGLB( 0, l[2], 0x02, 0 );
			LABL( 0, 0, 0, 0x02, ": " );
			DBYT( 0, l[3], 0x90, 0xc2, "Length:" );
			HEX#( 0x00000000, l[3], 0x90, 0xc2, "OI:" );
			LABL( 0, 0, 0, 0xb8 );
			l[3] += 1;
			g[2] -= l[3];
			l[2] += 1;
		}
	}
	TRTS;
}
// ------------------------------------
void 802_11::ANQP_vendor-specific_list()
{
	l[1] = pl[0];
	ANDG ffffff00 41;
	802_11::Print_OUI();
	DECR 3;
	GWRD( 0, l[22] );
	INCR 3;
	g[2] -= 3;
	if (l[22] == 0x506f)
	{
		DBYT 0 41 90 c2 ANQP Subtype:;
			CST# 0 41 0 14 802_11::ANQP_vendor-specific_list_Types;
			CLSE 0 0 0 14 unknown;
		DBYT 0 42 90 c2 Subtype:;
			CST# 0 42 0 14 802_11::ANQP_vendor-specific_list_HS20_Type;
			CLSE 0 0 0 14 unknown;
		g[2] -= 2;
		if ( l[2] == 1)
		{
			DBYT 0 0 90 c2 Reserved:;
			g[2] -= 1;
			while (g[2] > 0)
			{
				DBYT 0 43 90 c2 Queried Subtype:;
					CST# 0 43 0 14 802_11::ANQP_vendor-specific_list_HS20_Type;
					CLSE 0 0 0 14 unknown;
				g[2] -= 1;
			}
			LABL( 0, 0, 0, 0xb8 );
		}
		if ( l[2] == 2)
		{
			DBYT 0 0 90 c2 Reserved:;
			g[2] -= 1;
			while (g[2] > 0)
			{
				DBYT 0 43 90 c2 Capability:;
					CST# 0 43 0 14 802_11::ANQP_vendor-specific_list_HS20_Type;
					CLSE 0 0 0 14 unknown;
				g[2] -= 1;				
			}
		}
		if ( l[2] == 3)
		{
			DBYT 0 0 90 c2 Reserved:;
			g[2] -= 1;
			while (g[2] > 0)
			{
				DBYT 0 19 90 c2 Length:;
				CHR# 3 0 90 c2 Language Code:;
				g[25] -= 3; g[2] -= 4;
				CHR# 0 19 90 c2 Operator Friendly Name:;
				g[2] -= g[25];
			}
		}
		if ( l[2] == 4)
		{
			DBYT 0 0 90 c2 Reserved:;
			g[2] -= 1;
			BBYT 0 45 90 c9 Flags:;
				LABL 0 0 0 d4  xxxx .... Reserved;
				CBIT 3 45 0 d4 .... 1... At Capacity: set;
				CLSE 0 0 0 d4  .... 0... At Capacity: not set;				
				CBIT 2 45 0 d4 .... .1.. Symetric Link: set;
				CLSE 0 0 0 d4  .... .0.. Symetric Link: not set;
				ANDG 03 45;
				CEQU 3 45 00 d4 .... ..11 Link Status: in test stat (3);
				CEQU 2 45 00 d4 .... ..00 Link Status: down (2);
				CEQU 1 45 00 d4 .... ..01 Link Status: up (1);
				CEQU 0 45 00 d4 .... ..00 Link Status: Reserved (0);
				LABL 0 0 0 b8;
			DLNG 0 0 90 c2 Downlink Speed:;
				LABL 0 0 0 14 KBit/sec;
			DLNG 0 0 90 c2 Uplink Speed:;
				LABL 0 0 0 14 KBit/sec;
			DBYT 0 0 90 c2 Downlink Load:;
				LABL 0 0 0 14 %;
			DBYT 0 0 90 c2 Uplink Load:;
				LABL 0 0 0 14 %;
			DWRD 0 0 90 c2 LMD:;
		}
		if ( l[2] == 5)
		{
			while (g[2] > 0)
			{
				DBYT 0 45 90 c2 IP Protocol:;
					CST#  0  45  0 14 IP Protocols;
					CLSE 0 0 00 14 Unknown;
				PORT 0 46 90 c2 Port Number:;					
				DBYT 0 47 90 c2 Status:;
					CEQU 0 47 00 14 Closed;
					CEQU 0 47 00 14 Open;
					CEQU 0 47 00 14 Unknown;
					CLSE 0 0 00 14 Reserved;
				g[2] -= 4;
			}
		}
		if ( l[2] == 6)
		{
			DBYT 0 0 90 c2 NAI Home Realm Count:; g[2] -= 1;
			while (g[2] > 0)
			{
				DBYT 0 0 90 c2 NAI Realm Encoding:;
				DBYT 0 19 90 c2 NAI Home Realm Name Length:;
				CHR# 0 19 90 c2 NAI Home Realm Name:;
				g[2] -= g[25]; g[2] -= 2;
			}
		}
		if ( l[2] == 7)
		{
			while (g[2] > 0)
			{
				DBYT 0 0 90 c2 Operating Class Indication:;
				g[2] -= 1;
			}
		}
		if ( l[2] == 8)
		{
			DBYT 0 45 90 c2 OSU SSID Length:; g[2] -= 1;
			CHR# 0 45 90 c2 OSU SSID:; g[2] -= l[5];
			DBYT 0 45 90 c2 Number of OSU Providers:; g[2] -= 1;
			while (g[2] > 0)
			{
				CHR# 0 2 90 c2 OOSU Provider:;
				g[2] -= g[2];
			}
		}
		if ( l[2] == 9)
		{
			CHR# 0 2 90 c2 Unknown Content:;
			g[2] -= g[2];
		}
		if ( l[2] == 10)
		{
			CHR# 0 2 90 c2 Icon Filename:;
			g[2] -= g[2];
		}
		if ( l[2] == 11)
		{
			DBYT 0 45 90 c2 Download Status Code:; g[2] -= 1;
				CEQU 0 45 00 14 Success;
				CEQU 0 45 00 14 File not found;
				CEQU 0 45 00 14 Unspecified file error;
				CLSE 0 0 00 14 Reserved;
			DBYT 0 46 90 c2 Icon Type Length:; g[2] -= 1;
			CHR# 0 46 90 c2 Icon Type:; g[2] -= l[6];
			DWRD 0 46 90 c2 Icon Binary Data Length:; g[2] -= 1;
			HEX# 0 46 90 c2 Icon Binary Data:; g[2] -= l[6];
		}
		if ( l[2] >= 12)
		{
			CHR# 0 2 90 c2 Icon Filename:;
			g[2] -= g[2];
		}
	}
	if (l[22] != 0x506f)
	{
		DBYT 0 41 90 c2 ANQP Subtype:;
		DBYT 0 41 90 c2 Subtype:;
		g[2] -= 5;
		HEX#( 0, g[2], 0x90, 0xc2, "Vendor Specific Content:" );
		g[2] -= g[2];	
	}	
	TRTS;
}

str# 802_11::ANQP_vendor-specific_list_Types;
9	|	P2P;
16	|	Hotspot 2.0 Indication;
17	|	Hotspot 2.0 ANQP;

str# 802_11::ANQP_vendor-specific_list_HS20_Type;
0	|	Reserved;
1	|	HS Query list;
2	|	HS Capability List;
3	|	Operator Friendly Name;
4	|	WAN Metrics;
5	|	Connection Capability;
6	|	NAI Home Realm Query;
7	|	Operating Class Indication;
8	|	OSU Providers list;
9	|	Reserved;
10	|	Icon Request;
11	|	Icon Binary File;

// ------------------------------------
// IP Address Type Availability Information
void 802_11::IP_Address_Type_Availability_information()
{
	BBIT( 6, l[3], 0x90, 0xc2, "IPv4 Address:" );
		CST#( 0, l[3], 0, 0x14, 802_11::IPv4 Address field values );
		CLSE( 0, 0, 0, 0x14, "reserved" );
	BBIT( 2, l[2], 0x90, 0xc2, "802_11::IPv6 Address field values:" );
		CST#( 0, l[2], 0, 0x14, 802_11::IPv6 Address field values );
		CLSE( 0, 0, 0, 0x14, "reserved" );
	g[2] -= 1;
	TRTS;
}
str# 802_11::IPv6 Address field values;
0	|	Address type not available;
1	|	Address type available;
2	|	Availability of the address type not known;
3	|	Reserved;
str# 802_11::IPv4 Address field values;
0	|	Address type not available;
1	|	Public IPv4 address available;
2	|	Port-restricted IPv4 address available;
3	|	Single NATed private IPv4 address available;
4	|	Double NATed private IPv4 address available;
5	|	Port-restricted IPv4 address and single NATed IPv4 address available;
6	|	Port-restricted IPv4 address and double NATed IPv4 address available;
7	|	Availability of the address type is not known;
// ------------------------------------
void 802_11::NAI_Realm_list()
{
	DWRD( 0x40000000, 0, 0x90, 0xc2, "NAI Realm Count:" );
	g[2] -= 2;
	l[2] = 1;
	if (g[2] > 2)
	{
		while( g[2] > 2)
		{
			LABL( 0, 0, 0x90, 0xc9, "NAI Realm Data #" );
			DGLB( 0, l[2], 0x02, 0 );
			LABL( 0, 0, 0, 0x02, ": " );
			DWRD( 0x40000000, l[3], 0x90, 0xc2, "NAI Realm Data Field Length:" );
			HBYT( 0x00000000, l[4], 0x90, 0xc2, "NAI Realm Encoding:" );				
			DBYT( 0x00000000, l[5], 0x90, 0xc2, "NAI Realm Length:" );
			CHR#( 0x00000000, l[5], 0x90, 0xc2, "NAI Realm:" );
			DBYT( 0x00000000, l[6], 0x90, 0xc2, "EAP Method Count:" );
			l[20] = 1;
			while (l[6] != 0)
			{
				LABL( 0, 0, 0x90, 0xc9, "EAP Method #" );
				DGLB( 0, l[20], 0x02, 0 );
				LABL( 0, 0, 0, 0x02, ": " );
				DBYT( 0x00000000, l[21], 0x90, 0xc2, "Length:" );
				DBYT( 0x00000000, l[22], 0x90, 0xc2, "EAP Method:" );
				DBYT( 0x00000000, l[23], 0x90, 0xc2, "Authentication Parameter Count:" );
					l[30] = 1;
					while (l[23] != 0)
					{
						LABL( 0, 0, 0x90, 0xc9, "Authentication Parameter #" );
						DGLB( 0, l[30], 0x02, 0 );
						LABL( 0, 0, 0, 0x02, ": " );
						DBYT( 0x00000000, l[31], 0x90, 0xc2, "ID:" );
							CST#( 0, l[31], 0, 0x14, 802_11::NAI_Realm_list::Authentication Parameter_ID );
							CLSE( 0, 0, 0, 0x14, "Reserved" );
							if (l[31] == 221)
							{
								  TRTS;
							}
						DBYT( 0x00000000, l[32], 0x90, 0xc2, "Length:" );
						CHR#( 0x00000000, l[32], 0x90, 0xc2, "Authentication Parameter Value:" );
						l[30] += 1;
						l[23] -= 1;
					}
				LABL( 0, 0, 0, 0xb8 );
				l[20] += 1;
				l[6] -= 1;
			}
			LABL( 0, 0, 0, 0xb8 );
			
			l[3] += 1;
			g[2] -= l[3];
			l[2] += 1;
		}
	}
	LABL( 0, 0, 0, 0xb8 );
	LABL( 0, 0, 0, 0xb8 );
	TRTS;
}
str# 802_11::NAI_Realm_list::Authentication Parameter_ID;
0 |	Reserved;
1 |	Expanded EAP Method;
2 |	Non-EAP Inner Authentication Type;
3 |	Inner Authentication EAP Method Type;
4 |	Expanded Inner EAP Method;
5 |	Credential Type;
6 |	Tunneled EAP Method Credential Type;
221 | Vendor Specific;
// ------------------------------------
void 802_11::3GPP_Cellular_Network_information()
{
	DBYT( 0, l[1], 0x90, 0xc2, "GUD:" );
	DBYT( 0, l[2], 0x90, 0xc2, "UDHL:" );
	DBYT( 0, l[3], 0x90, 0xc2, "IEI:" );
	DBYT( 0, l[4], 0x90, 0xc2, "PLMN Length:" );
	DBYT( 0, l[5], 0x90, 0xc2, "Number of PLMNs:" );
	HBIT( 0, 12, 0x90, 0xc2, "Mobile Country Code (MCC):");
	HBIT( 0, 12, 0x90, 0xc2, "Mobile Network Code (MNC):");
}
//---------------------eof 802.11u-2011--------------------

//------------------------------------------------------
//Type 113
//Mesh Configuration (see 8.4.2.100 113 9 Yes
void 802_11::Mesh_Configuration()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Active Path Selection Protocol Identifier:" );				g[2] -= 1;
		CST#( 0, l[1], 0, 0x14, 802_11::Mesh_Configuration::APSPI );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[2], 0x90, 0xc2, "Active Path Selection Metric Identifier:" );				g[2] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Mesh_Configuration::APSMI );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[3], 0x90, 0xc2, "Congestion Control Mode Identifier:" );				g[2] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Mesh_Configuration::CCMI );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[4], 0x90, 0xc2, "Synchronization Method Identifier:" );				g[2] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Mesh_Configuration::SMI );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[5], 0x90, 0xc2, "Authentication Protocol Identifier:" );				g[2] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::Mesh_Configuration::API );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	BBYT( 0, l[6], 0x90, 0xc9, "Mesh Formation Info:" );				g[2] -= 1;
		DECR 1;
		BBIT( 1, l[7], 0x90, 0xc2, "Connected to AS:" );
		BBIT( 6, l[8], 0x90, 0xc2, "Number of Peerings:" );
		BBIT( 1, l[9], 0x90, 0xc2, "Connected to Mesh Gate:" );
		LABL 0 0 0 c8;
	BBYT( 0, l[7], 0x90, 0xc9, "Mesh Capability:" );				g[2] -= 1;
		DECR 1;
		BBIT( 1, l[71], 0x90, 0xc2, "Reserved:" );
		BBIT( 1, l[72], 0x90, 0xc2, "Mesh Power Save Level:" );
		BBIT( 1, l[73], 0x90, 0xc2, "TBTT Adjusting:" );
		BBIT( 1, l[74], 0x90, 0xc2, "MBCA Enabled:" );
		BBIT( 1, l[75], 0x90, 0xc2, "Forwarding:" );
		BBIT( 1, l[76], 0x90, 0xc2, "MCCA Enabled:" );
		BBIT( 1, l[77], 0x90, 0xc2, "MCCA Supporte:" );
		BBIT( 1, l[78], 0x90, 0xc2, "Accepting Additional Mesh Peerings:" );
		LABL 0 0 0 c8;
}
str# 802_11::Mesh_Configuration::APSPI;
1	|	Hybrid wireless mesh protocol (default path selection protocol);
255	|	Vendor specific;
str# 802_11::Mesh_Configuration::APSMI;
1	|	Airtime link metric (default path selection metric);
255	|	Vendor specific;
str# 802_11::Mesh_Configuration::CCMI;
0	|	Congestion control is not activated (default congestion control mode);
1	|	Congestion control signaling protocol;
255	|	Vendor specific;
str# 802_11::Mesh_Configuration::SMI;
0	|	Reserved;
1	|	Neighbor offset synchronization method(default synchronization method);
255	|	Vendor specific;
str# 802_11::Mesh_Configuration::API;
0	|	No authentication method is required to establish mesh peerings within the MBSS;
1	|	SAE;
2	|	IEEE 802.1X authentication;
255	|	Vendor specific;
//------------------------------------------------------
//type 114
void 802_11::Mesh_ID()
{
	CHR#( 0, g[2], 0x90, 0xc2, "Mesh ID:" ); 			g[2] -= g[2];
}

//------------------------------------------------------
//type 115 Mesh Link Metric Report 
void 802_11::Mesh_Link_Metric_Report()
{
	DBYT( 0, l[1], 0x90, 0xc9, "Flags:" );				g[2] -= 1;
		DECR 1;
		BBIT( 5, l[11], 0x90, 0xc2, "Reserved:" );
		BBIT( 1, l[12], 0x90, 0xc2, "Reason:" );
		BBIT( 1, l[13], 0x90, 0xc2, "Initiator:" );
		BBIT( 1, l[14], 0x90, 0xc2, "Transmit Restrict:" );
		LABL( 0, 0, 0, 0xc8 );
	CHR#( 0, g[2], 0x90, 0xc2, "Mesh ID:" );			g[2] -= g[2];
}
//------------------------------------------------------
//type 116 8.4.2.103 Congestion Notification element
void 802_11::Congestion_Notification()
{
	ETHR( 0, l[1], 0x90, 0xc2, "Destination Mesh STA Address:" );				g[2] -= 6;
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "Congestion Notification Duration Timer (AC_BK):" );				g[2] -= 2;
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "Congestion Notification Duration Timer (AC_BE):" );				g[2] -= 2;
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "Congestion Notification Duration Timer (AC_VI):" );				g[2] -= 2;
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "Congestion Notification Duration Timer (AC_VO):" );				g[2] -= 2;
}
//------------------------------------------------------
//type 117  Mesh Peering Management element
void 802_11::Mesh_Peering_Management()	
{	
	DWRD( 0x40000003, l[1], 0x90, 0xc2, "Mesh Peering Protocol Identifier:" );				g[2] -= 1;
		CST#( 0, l[1], 0, 0x14, 802_11::Mesh_Peering_Management::MPPI );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	//HEX#( 0, 3, 0x90, 0xc2, "Mesh Peering Protocol OUI:" );	g[2] -= 3;
	//802_11::Print_OUI;			
	
	if (g[2] > 0)
	{
		DWRD( 0x40000000, l[2], 0x90, 0xc2, "Local Link ID:" );				g[2] -= 2;
	}
	if (g[2] > 0)
	{
		DWRD( 0x40000000, l[2], 0x90, 0xc2, "Peer Link ID:" );				g[2] -= 2;
	}
	if (g[2] > 0)
	{
		DWRD( 0x40000000, l[2], 0x90, 0xc2, "Reason Code:" );				g[2] -= 2;
	}
	if (g[2] >= 2)
	{
		DWRD( 0x40000000, l[2], 0x90, 0xc9, "Chosen PMK :" );				g[2] -= 2;
	}
}

str# 802_11::Mesh_Peering_Management::MPPI;
0	|	Mesh peering management protocol;
1	|	Authenticated mesh peering exchange protocol;
255	|	Vendor specific;
//------------------------------------------------------
//type 118 8.4.2.105 Mesh Channel Switch Parameters element
void 802_11::Mesh_Channel_Switch_Parameters()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Time To Live:" );				g[2] -= 1;
	BBYT( 0, l[2], 0x90, 0xc9, "Flags:" );				g[2] -= 1;
		DECR 1;
		BBIT( 5, l[11], 0x90, 0xc2, "Reserved:" );
		BBIT( 1, l[12], 0x90, 0xc2, "Reason:" );
		BBIT( 1, l[13], 0x90, 0xc2, "Initiator:" );
		BBIT( 1, l[14], 0x90, 0xc2, "Transmit Restrict:" );
		LABL( 0, 0, 0, 0xc8 );
	if (g[2] >= 2)
	{
		DWRD( 0x40000000, l[3], 0x90, 0xc2, "Reason Code:" );				g[2] -= 2;
	}
	if (g[2] >= 2)
	{
		DWRD( 0x40000000, l[4], 0x90, 0xc2, "Precedence Value:" );				g[2] -= 2;
	}
}
//------------------------------------------------------
//type 119 8.4.2.105 Mesh Channel Switch Parameters element
void 802_11::Mesh_Awake_Window()
{
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "Mesh Awake Window:" );				g[2] -= 2;
}
//------------------------------------------------------
//type 120 8.4.2.107 Beacon Timing element
void 802_11::Beacon_Timing()
{
	BBYT( 0, l[1], 0x90, 0xc9, "Report Control:" );				g[2] -= 1;
		DECR 1;
		BBIT( 1, l[11], 0x90, 0xc2, "More Beacon Timing Elements:" );
		BBIT( 3, l[12], 0x90, 0xc2, "Beacon Timing Element Number:" );
		BBIT( 4, l[13], 0x90, 0xc2, "Status Number:" );
		LABL( 0, 0, 0, 0xc8 );
	DBYT( 0, l[2], 0x90, 0xc2, "Neighbor STA ID:" );				g[2] -= 1;
	DWRD( 0x40000000, l[3], 0x90, 0xc2, "Neighbor TBTT:" );							g[2] -= 2;
	DBYT( 0, l[4], 0x90, 0xc2, "Neighbor TBTT:" );							g[2] -= 1;
	DWRD( 0x40000000, l[5], 0x90, 0xc2, "Neighbor Beacon Interval:" );				g[2] -= 2;
}

//------------------------------------------------------
//type 121 8.4.2.108 MCCAOP Setup Request element
void 802_11::MCCAOP_Setup_Request()
{
	DBYT( 0, l[1], 0x90, 0xc2, "MCCAOP Reservation ID:" );			g[2] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "MCCAOP Duration:" );				g[2] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "MCCAOP Periodicity:" );				g[2] -= 1;
	DBYT( 3, l[4], 0x90, 0xc2, "MCCAOP Offset:" );					g[2] -= 3;
}
//------------------------------------------------------
//type 122 8.4.2.109 MCCAOP Setup Reply element
void 802_11::MCCAOP_Setup_Reply()
{
	DBYT( 0, l[1], 0x90, 0xc2, "MCCAOP Reservation ID:" );			g[2] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "MCCAOP MCCA Reply Code:" );			g[2] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::MCCAOP_Setup_Request::ReplyCode );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	DBYT( 0, l[3], 0x90, 0xc2, "MCCAOP Duration:" );				g[2] -= 1;
	DBYT( 0, l[4], 0x90, 0xc2, "MCCAOP Periodicity:" );				g[2] -= 1;
	DBYT( 3, l[5], 0x90, 0xc2, "MCCAOP Offset:" );					g[2] -= 3;
}

str# 802_11::MCCAOP_Setup_Request::ReplyCode;
0	|	Accept;
1	|	Reject: MCCAOP reservation conflict;
2	|	Reject: MAF limit exceeded;
3	|	Reject: MCCA track limit (dot11MCCAMaxTrackStates) exceeded;
//------------------------------------------------------
//type 123 8.4.2.110 MCCAOP Advertisement element
void 802_11::MCCAOP_Advertisement()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Advertisement Set Sequence Number:" );			g[2] -= 1;
	BBYT( 0, l[2], 0x90, 0xc2, "MCCAOP Advertisement Element Information:" );		g[2] -= 1;
}

//------------------------------------------------------
//type 174 8.4.2.110 MCCAOP Advertisement Overview element
void 802_11::MCCAOP_Advertisement_Overview()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Advertisement Set Sequence Number:" );			g[2] -= 1;
	BBYT( 0, l[2], 0x90, 0xc2, "Flags:" );										g[2] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "MCCA Access Fraction:" );						g[2] -= 1;
	DBYT( 0, l[4], 0x90, 0xc2, "MAF Limit:" );									g[2] -= 1;
	BWRD( 0x40000000, l[5], 0x90, 0xc2, "Advertisement Elements Bitmap:" );				g[2] -= 2;
}
//------------------------------------------------------
//Type 124 8.4.2.112 MCCAOP Teardown element
void 802_11::MCCAOP_Teardown()
{
	DBYT( 0, l[1], 0x90, 0xc2, "MCCAOP Reservation ID:" );			g[2] -= 1;
	ETHR( 0, l[2], 0x90, 0xc2, "MCCAOP Owner:" );				g[2] -= 6;
}

//------------------------------------------------------
//Type 125 8.4.2.113 GANN element
void 802_11::GANN()
{
	BBYT( 0, l[1], 0x90, 0xc2, "Flags:" );			g[2] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "Hop Count:" );			g[2] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "Element TTL:" );			g[2] -= 1;
	ETHR( 0, l[4], 0x90, 0xc2, "Mesh Gate Address:" );				g[2] -= 6;
	DLNG( 0x40000000, l[5], 0x90, 0xc2, "GANN Sequence Number:" );			g[2] -= 4;
	DWRD( 0x40000000, l[6], 0x90, 0xc2, "Interval:" );				g[2] -= 2;	
}

//------------------------------------------------------
//Type 126 8.4.2.114 RANN element
void 802_11::RANN()
{
	BBYT( 0, l[1], 0x90, 0xc2, "Flags:" );			g[2] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "Hop Count:" );			g[2] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "Element TTL:" );			g[2] -= 1;
	ETHR( 0, l[4], 0x90, 0xc2, "Root Mesh STA Address:" );				g[2] -= 6;
	DLNG( 0x40000000, l[5], 0x90, 0xc2, "HWMP Sequence Number:" );			g[2] -= 4;
	DLNG( 0x40000000, l[6], 0x90, 0xc2, "Interval:" );			g[2] -= 4;
	DLNG( 0x40000000, l[7], 0x90, 0xc2, "Metric:" );			g[2] -= 4;
}

//------------------------------------------------------
//type 127
void 802_11::Extended_Capabilities()
{
	//Bit 0-7
	BBYT 0 41 90 c9 Extended Capabilities:;
	CBIT 7 41 0 d4 1... .... EventsActivated is true;
	CLSE 0 0 0 d4  0... .... EventsActivated is false;
	CBIT 6 41 0 d4 .1.. .... the STA does support S-PSMP;
	CLSE 0 0 0 d4  .0.. .... the STA does not support S-PSMP;
	l[2] = l[1];
	ANDG 40 42;
	SHFR 6 42;
	LABL 0 0 0 d4  ..x. .... Reserved;
	CBIT 4 41 0 d4 ...1 .... the AP supports PSMP operation;
	CLSE 0 0 0 d4  ...0 .... the AP does not support PSMP operation;
	LABL 0 0 0 d4  .... x... Reserved;
	CBIT 2 41 0 d4 .... .1.. Extended Channel Switching Supported;
	CLSE 0 0 0 d4  .... .0.. Extended Channel Switching Not Supported;
	LABL 0 0 0 d4  .... ..x. Reserved;
	CBIT 0 41 0 d4 .... ...1 20/40 BSS Coexistence Management Frame Supported;
	CLSE 0 0 0 d4  .... ...0 20/40 BSS Coexistence Management Frame Not Supported;
	LABL 0 0 0 c8;
	g[2] -= 1;
	if (g[2] >= 1)
	{
		//Bit 8-15
		BBYT 0 41 90 c9 Extended Capabilities:;
		CBIT 7 41 0 d4 1... .... RRMLCIMeasurementEnabled is true;
		CLSE 0 0 0 d4  0... .... RRMLCIMeasurementEnabled is false;	
		CBIT 6 41 0 d4 .1.. .... RRMCivicMeasurementActivated is true;
		CLSE 0 0 0 d4  .0.. .... RRMCivicMeasurementActivated is false;	
		CBIT 5 41 0 d4 ..1. .... CoLocIntfReportingActivated is true;
		CLSE 0 0 0 d4  ..0. .... CoLocIntfReportingActivated is false;	
		CBIT 4 41 0 d4 ...1 .... ProxyARPActivated is true;
		CLSE 0 0 0 d4  ...0 .... ProxyARPActivated is false;
		CBIT 3 41 0 d4 .... 1... FMSActivated is true;
		CLSE 0 0 0 d4  .... 0... FMSActivated is false;
		CBIT 2 41 0 d4 .... .1.. LocationTrackingActivated is true;
		CLSE 0 0 0 d4  .... .0.. LocationTrackingActivated is false;
		CBIT 1 41 0 d4 .... ..1. MulticastDiagnosticsActivated is true;
		CLSE 0 0 0 d4  .... ..0. MulticastDiagnosticsActivated is false;
		CBIT 0 41 0 d4 .... ...1 DiagnosticsActivated is true;
		CLSE 0 0 0 d4  .... ...0 DiagnosticsActivated is false;	
		LABL 0 0 0 c8;
		g[2] -= 1;
		if (g[2] >= 1)
		{
			//Bit 16-23
			BBYT 0 41 90 c9 Extended Capabilities:;
			CBIT 7 41 0 d4 1... .... TimingMsmtActivated is true;
			CLSE 0 0 0 d4  0... .... TimingMsmtActivated is false;	
			CBIT 6 41 0 d4 .1.. .... MultiBSSIDActivated is true;
			CLSE 0 0 0 d4  .0.. .... MultiBSSIDActivated is false;	
			CBIT 5 41 0 d4 ..1. .... ACStationCountActivated is true;
			CLSE 0 0 0 d4  ..0. .... ACStationCountActivated is false;	
			CBIT 4 41 0 d4 ...1 .... QoSTrafficCapabilityActivated is true;
			CLSE 0 0 0 d4  ...0 .... QoSTrafficCapabilityActivated is false;
			CBIT 3 41 0 d4 .... 1... BSSTransitionActivated is true;
			CLSE 0 0 0 d4  .... 0... BSSTransitionActivated is false;
			CBIT 2 41 0 d4 .... .1.. TIMBroadcastActivated is true;
			CLSE 0 0 0 d4  .... .0.. TIMBroadcastActivated is false;
			CBIT 1 41 0 d4 .... ..1. WNMSleepModeActivated is true;
			CLSE 0 0 0 d4  .... ..0. WNMSleepModeActivated is false;
			CBIT 0 41 0 d4 .... ...1 TFSActivated is true;
			CLSE 0 0 0 d4  .... ...0 TFSActivated is false;
			LABL 0 0 0 c8;
			g[2] -= 1;
			if (g[2] >= 1)
			{
				//Bit 24-31
				BBYT 0 41 90 c9 Extended Capabilities:;
				CBIT 7 41 0 d4 1... .... InterworkingServiceActivated is true;
				CLSE 0 0 0 d4  0... .... InterworkingServiceActivated is false;	
				CBIT 6 41 0 d4 .1.. .... TDLS Channel Switching is supported;
				CLSE 0 0 0 d4  .0.. .... TDLS Channel Switching is not supported;	
				CBIT 5 41 0 d4 ..1. .... TDLSPeerPS MActivated is true;
				CLSE 0 0 0 d4  ..0. .... TDLSPeerPS MActivated is false;	
				CBIT 4 41 0 d4 ...1 .... TDLSPeerUAPSDBufferSTAActivated is true;
				CLSE 0 0 0 d4  ...0 .... TDLSPeerUAPSDBufferSTAActivated is false;
				CBIT 3 41 0 d4 .... 1... UTCTSFOffsetActivated is true;
				CLSE 0 0 0 d4  .... 0... UTCTSFOffsetActivated is false;
				CBIT 2 41 0 d4 .... .1.. DMSActivated is true;
				CLSE 0 0 0 d4  .... .0.. DMSActivated is false;
				CBIT 1 41 0 d4 .... ..1. SSIDListActivated is true;
				CLSE 0 0 0 d4  .... ..0. SSIDListActivated is false;
				CBIT 0 41 0 d4 .... ...1 ChannelUsageActivated is true;
				CLSE 0 0 0 d4  .... ...0 ChannelUsageActivated is false;
				LABL 0 0 0 c8;
				g[2] -= 1;
				// This one byte is not necessarily the end.  Keep going.
				// Length is in g2.					
					// Extended Capabilities byte.
				//BIT 32-39
				if( g[2] >= 1 ) 
				{
					BBYT 0 41 90 c9 Extended Capabilities:;
					CBIT 7 41 0 d4 1... .... TDLS Channel Switching is prohibited;
					CLSE 0 0 0 d4  0... .... TDLS Channel Switching is not prohibited;	
					CBIT 6 41 0 d4 .1.. .... TDLS is prohibited;
					CLSE 0 0 0 d4  .0.. .... TDLS is not prohibited;
					CBIT 5 41 0 d4 ..1. .... TunneledDirectLinkSetupImplemented is true;
					CLSE 0 0 0 d4  ..0. .... TunneledDirectLinkSetupImplemented is false;	
					CBIT 4 41 0 d4 ...1 .... MSGCFActivated is true;
					CLSE 0 0 0 d4  ...0 .... MSGCFActivated is false;
					LABL 0 0 0 d4  .... x... Reserved;
					CBIT 2 41 0 d4 .... .1.. SSPNInterfaceActivated is true;
					CLSE 0 0 0 d4  .... .0.. SSPNInterfaceActivated is false;
					CBIT 1 41 0 d4 .... ..1. EBRActivated is true;
					CLSE 0 0 0 d4  .... ..0. EBRActivated is false;
					CBIT 0 41 0 d4 .... ...1 QosMapActivated is true;
					CLSE 0 0 0 d4  .... ...0 QosMapActivated is false;
					LABL 0 0 0 c8;
					g[2] -= 1;
					//BIT 40-47
					if( g[2] >= 1 ) 
					{
						BBYT 0 41 90 c9 Extended Capabilities:;
						LABL 0 0 0 d4  x... .... Reserved;
						CBIT 6 41 0 d4 .1.. .... WNMNotificationActivated is true;
						CLSE 0 0 0 d4  .0.. .... WNMNotificationActivated is false;	
						CBIT 5 41 0 d4 ..1. .... UAPSDCoexistenceActivated is true;
						CLSE 0 0 0 d4  ..0. .... UAPSDCoexistenceActivated is false;	
						CBIT 4 41 0 d4 ...1 .... RMIdentifierMeasurementActivated is true;
						CLSE 0 0 0 d4  ...0 .... RMIdentifierMeasurementActivated is false;
						if (l[2] == 0)
						{
							LABL 0 0 0 d4  .... xxx. Reserved;
						}
						if (l[2] == 1)
						{
							LABL 0 0 0 d4  ....;
							l[2] = l[1];
							ANDG e 42;
							SHFR 1 42;
							CEQU( 0, l[2], 0, 0x54, " 000. Service Interval Granularity: 5 ms");
							CEQU( 1, l[2], 0, 0x54, " 001. Service Interval Granularity: 10 ms");
							CEQU( 2, l[2], 0, 0x54, " 010. Service Interval Granularity: 15 ms");
							CEQU( 3, l[2], 0, 0x54, " 011. Service Interval Granularity: 20 ms");
							CEQU( 4, l[2], 0, 0x54, " 100. Service Interval Granularity: 25 ms");
							CEQU( 5, l[2], 0, 0x54, " 101. Service Interval Granularity: 30 ms");
							CEQU( 6, l[2], 0, 0x54, " 110. Service Interval Granularity: 35 ms");
							CEQU( 7, l[2], 0, 0x54, " 111. Service Interval Granularity: 40 ms");
						}
						CBIT 0 41 0 d4 .... ...1 RejectUnadmittedTraffic is true;
						CLSE 0 0 0 d4  .... ...0 RejectUnadmittedTraffic is false;
						LABL 0 0 0 c8;
						g[2] -= 1;
						if( g[2] >= 1 ) 
						{
							//Bit 48-55
							BBYT 0 41 90 c9 Extended Capabilities:;
							LABL 0 0 0 d4  xxxx xxx. Reserved;					
							CBIT 0 41 0 d4 .... ...1 The SSID in this BSS is interpreted using UTF-8 encoding;
							CLSE 0 0 0 d4  .... ...0 The SSID in this BSS is not interpreted using UTF-8 encoding;					
							LABL 0 0 0 c8;
							g[2] -= 1;
							if( g[2] >= 1 ) 
							{									
								//Bit56-63
								BBYT 0 41 90 c9 Extended Capabilities:;
								LABL 0 0 0 d4  x... .... Reserved;
								CBIT 6 41 0 d4 .1.. .... OperatingModeNotificationImplemented is true;
								CLSE 0 0 0 d4  .0.. .... OperatingModeNotificationImplemented is false;	
								CBIT 5 41 0 d4 ..1. .... TDLS Wider Bandwidth is true;
								CLSE 0 0 0 d4  ..0. .... TDLS Wider Bandwidth is false;	
								LABL 0 0 0 d4  ...x xxxx Reserved;
								LABL 0 0 0 c8;
								g[2] -= 1;
							}
						}
						if( g[2] >= 1 ) 
						{
							
							HEX# 0 2 90 c2 Reserved:;
						}
					}
				}
			}
		}
	}
}

//------------------------------------------------------
void 802_11::TDLS_Extended_Capabilities()
{
	//Bit 0-7
	BBYT 0 41 90 c9 Extended Capabilities:;
	CBIT 7 41 0 d4 1... .... EventsActivated is true;
	CLSE 0 0 0 d4  0... .... EventsActivated is false;
	CBIT 6 41 0 d4 .1.. .... the STA does support S-PSMP;
	CLSE 0 0 0 d4  .0.. .... the STA does not support S-PSMP;
	l[2] = l[1];
	ANDG 40 42;
	SHFR 6 42;
	LABL 0 0 0 d4  ..x. .... Reserved;
	CBIT 4 41 0 d4 ...1 .... the AP supports PSMP operation;
	CLSE 0 0 0 d4  ...0 .... the AP does not support PSMP operation;
	LABL 0 0 0 d4  .... x... Reserved;
	CBIT 2 41 0 d4 .... .1.. Extended Channel Switching Supported;
	CLSE 0 0 0 d4  .... .0.. Extended Channel Switching Not Supported;
	LABL 0 0 0 d4  .... ..x. Reserved;
	CBIT 0 41 0 d4 .... ...1 20/40 BSS Coexistence Management Frame Supported;
	CLSE 0 0 0 d4  .... ...0 20/40 BSS Coexistence Management Frame Not Supported;
	LABL 0 0 0 c8;
	g[2] -= 1;
	if (g[2] >= 1)
	{
		//Bit 8-15
		BBYT 0 41 90 c9 Extended Capabilities:;
		CBIT 7 41 0 d4 1... .... dot11RRMLCIMeasurementEnabled is true;
		CLSE 0 0 0 d4  0... .... dot11RRMLCIMeasurementEnabled is false;	
		CBIT 6 41 0 d4 .1.. .... dot11RRMCivicMeasurementActivated is true;
		CLSE 0 0 0 d4  .0.. .... dot11RRMCivicMeasurementActivated is false;	
		CBIT 5 41 0 d4 ..1. .... CoLocIntfReportingActivated is true;
		CLSE 0 0 0 d4  ..0. .... CoLocIntfReportingActivated is false;	
		CBIT 4 41 0 d4 ...1 .... ProxyARPActivated is true;
		CLSE 0 0 0 d4  ...0 .... ProxyARPActivated is false;
		CBIT 3 41 0 d4 .... 1... FMSActivated is true;
		CLSE 0 0 0 d4  .... 0... FMSActivated is false;
		CBIT 2 41 0 d4 .... .1.. LocationTrackingActivated is true;
		CLSE 0 0 0 d4  .... .0.. LocationTrackingActivated is false;
		CBIT 1 41 0 d4 .... ..1. MulticastDiagnosticsActivated is true;
		CLSE 0 0 0 d4  .... ..0. MulticastDiagnosticsActivated is false;
		CBIT 0 41 0 d4 .... ...1 DiagnosticsActivated is true;
		CLSE 0 0 0 d4  .... ...0 DiagnosticsActivated is false;	
		LABL 0 0 0 c8;
		g[2] -= 1;
		if (g[2] >= 1)
		{
			//Bit 16-23
			BBYT 0 41 90 c9 Extended Capabilities:;
			CBIT 7 41 0 d4 1... .... TimingMsmtActivated is true;
			CLSE 0 0 0 d4  0... .... TimingMsmtActivated is false;	
			CBIT 6 41 0 d4 .1.. .... MultiBSSIDActivated is true;
			CLSE 0 0 0 d4  .0.. .... MultiBSSIDActivated is false;	
			CBIT 5 41 0 d4 ..1. .... ACStationCountActivated is true;
			CLSE 0 0 0 d4  ..0. .... ACStationCountActivated is false;	
			CBIT 4 41 0 d4 ...1 .... QoSTrafficCapabilityActivated is true;
			CLSE 0 0 0 d4  ...0 .... QoSTrafficCapabilityActivated is false;
			CBIT 3 41 0 d4 .... 1... BSSTransitionActivated is true;
			CLSE 0 0 0 d4  .... 0... BSSTransitionActivated is false;
			CBIT 2 41 0 d4 .... .1.. TIMBroadcastActivated is true;
			CLSE 0 0 0 d4  .... .0.. TIMBroadcastActivated is false;
			CBIT 1 41 0 d4 .... ..1. WNMSleepModeActivated is true;
			CLSE 0 0 0 d4  .... ..0. WNMSleepModeActivated is false;
			CBIT 0 41 0 d4 .... ...1 TFSActivated is true;
			CLSE 0 0 0 d4  .... ...0 TFSActivated is false;
			LABL 0 0 0 c8;
			g[2] -= 1;
			if (g[2] >= 1)
			{
				//Bit 24-31
				BBYT 0 41 90 c9 Extended Capabilities:;
				CBIT 7 41 0 d4 1... .... dot11InterworkingServiceActivated is true;
				CLSE 0 0 0 d4  0... .... dot11InterworkingServiceActivated is false;	
				CBIT 6 41 0 d4 .1.. .... TDLS Channel Switching is supported;
				CLSE 0 0 0 d4  .0.. .... TDLS Channel Switching is not supported;	
				CBIT 5 41 0 d4 ..1. .... dot11TDLSPeerPS MActivated is true;
				CLSE 0 0 0 d4  ..0. .... dot11TDLSPeerPS MActivated is false;	
				CBIT 4 41 0 d4 ...1 .... dot11TDLSPeerUAPSDBufferSTAActivated is true;
				CLSE 0 0 0 d4  ...0 .... dot11TDLSPeerUAPSDBufferSTAActivated is false;
				CBIT 3 41 0 d4 .... 1... UTCTSFOffsetActivated is true;
				CLSE 0 0 0 d4  .... 0... UTCTSFOffsetActivated is false;
				CBIT 2 41 0 d4 .... .1.. DMSActivated is true;
				CLSE 0 0 0 d4  .... .0.. DMSActivated is false;
				CBIT 1 41 0 d4 .... ..1. SSIDListActivated is true;
				CLSE 0 0 0 d4  .... ..0. SSIDListActivated is false;
				CBIT 0 41 0 d4 .... ...1 ChannelUsageActivated is true;
				CLSE 0 0 0 d4  .... ...0 ChannelUsageActivated is false;
				LABL 0 0 0 c8;
				g[2] -= 1;
				//BIT 32-39
				if( g[2] >= 1 ) 
				{
					BBYT 0 41 90 c9 Extended Capabilities:;
					LABL 0 0 0 d4  .... x... Reserved;
					CBIT 7 41 0 d4 1... .... TDLS Channel Switching is prohibited;
					CLSE 0 0 0 d4  0... .... TDLS Channel Switching is not prohibited;	
					CBIT 6 41 0 d4 .1.. .... TDLS is prohibited;
					CLSE 0 0 0 d4  .0.. .... TDLS is not prohibited;
					CBIT 5 41 0 d4 ..1. .... dot11TunneledDirectLinkSetupImplemented is true;
					CLSE 0 0 0 d4  ..0. .... dot11TunneledDirectLinkSetupImplemented is false;	
					CBIT 4 41 0 d4 ...1 .... dot11MSGCFActivated is true;
					CLSE 0 0 0 d4  ...0 .... dot11MSGCFActivated is false;
					LABL 0 0 0 d4  .... x... Reserved;
					CBIT 2 41 0 d4 .... .1.. dot11SSPNInterfaceActivated is true;
					CLSE 0 0 0 d4  .... .0.. dot11SSPNInterfaceActivated is false;
					CBIT 1 41 0 d4 .... ..1. dot11EBRActivated is true;
					CLSE 0 0 0 d4  .... ..0. dot11EBRActivated is false;
					CBIT 0 41 0 d4 .... ...1 dot11QosMapActivated is true;
					CLSE 0 0 0 d4  .... ...0 dot11QosMapActivated is false;
					LABL 0 0 0 c8;
					g[2] -= 1;
					//BIT 40-47
					if( g[2] >= 1 ) 
					{
						BBYT 0 41 90 c9 Extended Capabilities:;
						LABL 0 0 0 d4  x... .... Reserved;
						CBIT 6 41 0 d4 .1.. .... WNMNotificationActivated is true;
						CLSE 0 0 0 d4  .0.. .... WNMNotificationActivated is false;	
						CBIT 5 41 0 d4 ..1. .... UAPSDCoexistenceActivated is true;
						CLSE 0 0 0 d4  ..0. .... UAPSDCoexistenceActivated is false;	
						CBIT 4 41 0 d4 ...1 .... dot11RMIdentifierMeasurementActivated is true;
						CLSE 0 0 0 d4  ...0 .... dot11RMIdentifierMeasurementActivated is false;
						if (l[2] == 0)
						{
							LABL 0 0 0 d4  .... xxx. Reserved;
						}
						if (l[2] == 1)
						{
							LABL 0 0 0 d4  ....;
							l[2] = l[1];
							ANDG e 42;
							SHFR 1 42;
							CEQU( 0, l[2], 0, 0x54, " 000. Service Interval Granularity: 5 ms");
							CEQU( 1, l[2], 0, 0x54, " 001. Service Interval Granularity: 10 ms");
							CEQU( 2, l[2], 0, 0x54, " 010. Service Interval Granularity: 15 ms");
							CEQU( 3, l[2], 0, 0x54, " 011. Service Interval Granularity: 20 ms");
							CEQU( 4, l[2], 0, 0x54, " 100. Service Interval Granularity: 25 ms");
							CEQU( 5, l[2], 0, 0x54, " 101. Service Interval Granularity: 30 ms");
							CEQU( 6, l[2], 0, 0x54, " 110. Service Interval Granularity: 35 ms");
							CEQU( 7, l[2], 0, 0x54, " 111. Service Interval Granularity: 40 ms");
						}
						CBIT 0 41 0 d4 .... ...1 dot11RejectUnadmittedTraffic is true;
						CLSE 0 0 0 d4  .... ...0 dot11RejectUnadmittedTraffic is false;
						LABL 0 0 0 c8;
						g[2] -= 1;
						if( g[2] >= 1 ) 
						{
							//Bit 48-55
							BBYT 0 41 90 c9 Extended Capabilities:;
							LABL 0 0 0 d4  xxxx xxx. Reserved;					
							CBIT 0 41 0 d4 .... ...1 The SSID in this BSS is interpreted using UTF-8 encoding;
							CLSE 0 0 0 d4  .... ...0 The SSID in this BSS is not interpreted using UTF-8 encoding;					
							LABL 0 0 0 c8;
							g[2] -= 1;
							if( g[2] >= 1 ) 
							{									
								//Bit56-63
								BBYT 0 41 90 c9 Extended Capabilities:;
								LABL 0 0 0 d4  x... .... Reserved;
								CBIT 7 41 0 d4 1... .... Reserved is true;
								CLSE 0 0 0 d4  0... .... Reserved is false;	
								CBIT 6 41 0 d4 .1.. .... dot11OperatingModeNotificationImplemented is true;
								CLSE 0 0 0 d4  .0.. .... dot11OperatingModeNotificationImplemented is false;	
								CBIT 5 41 0 d4 ..1. .... TDLS Wider Bandwidth is true;
								CLSE 0 0 0 d4  ..0. .... TDLS Wider Bandwidth is false;	
								LABL 0 0 0 d4  ...x xxxx Reserved;
								LABL 0 0 0 c8;
								g[2] -= 1;
							}
						}
						if( g[2] >= 1 ) 
						{
							TRTS;
						}
					}
				}
			}
		}
	}
}

//------------------------------------------------------
//Type 128
void 802_11::IE_Agere;
	802_11::Print_OUI();
	DBYT 0 0 90 C2 Number of clients:;
	SUBG 4 2;
	HEX# 0 2 90 C2 Value:;
	TRTS;

//------------------------------------------------------
//Type 130 8.4.2.115 PREQ element
void 802_11::PREQ()
{
	BBYT( 0, l[1], 0x90, 0xc9, "Flags:" );			g[2] -= 1;
		DECR 1;
		BBIT( 1, l[10], 0x90, 0xc2, "Reserved:" );
		BBIT( 1, l[11], 0x90, 0xc2, "AE:" );
		BBIT( 3, l[12], 0x90, 0xc2, "Reserved:" );
		BBIT( 1, l[13], 0x90, 0xc2, "Proactive PREP:" );
		BBIT( 1, l[14], 0x90, 0xc2, "Addressing Mode:" );
		BBIT( 1, l[15], 0x90, 0xc2, "Gate Announcement:" );
	LABL( 0, 0, 0, 0xc8 );
	DBYT( 0, l[2], 0x90, 0xc2, "Hop Count:" );			g[2] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "Element TTL:" );			g[2] -= 1;
	DLNG( 0x40000000, l[4], 0x90, 0xc2, "Path Discovery ID:" );			g[2] -= 4;
	ETHR( 0, 0, 0x90, 0xc2, "Originator Mesh STA Address:" );				g[2] -= 6;
	DLNG( 0x40000000, l[5], 0x90, 0xc2, "Originator HWMP Sequence Number:" );			g[2] -= 4;
	if ( l[11] == 0x01 )
	{
		ETHR( 0, 0, 0x90, 0xc2, "Originator External Address:" );				g[2] -= 6;
	}
	DLNG( 0x40000000, l[6], 0x90, 0xc2, "Lifetime:" );			g[2] -= 4;
	DLNG( 0x40000000, l[7], 0x90, 0xc2, "Metric:" );			g[2] -= 4;
	DBYT( 0, l[8], 0x90, 0xc2, "Target Count:" );			g[2] -= 1;
	LABL( 0, 0, 0x90, 0xc9, "Target HWMP Sequence Numbers:" );
	while (l[8] != 0)
	{
		DBYT( 0, l[16], 0x90, 0xc2, "Per Target Flags:" );			g[2] -= 1;
		ETHR( 0, 0, 0x90, 0xc2, "Target Address:" );				g[2] -= 6;
		DLNG( 0x40000000, 0, 0x90, 0xc2, "Target HWMP Sequence Number:" );			g[2] -= 4;
		l[8] -= 1;
	}
	LABL( 0, 0, 0, 0xc8 );
}
//------------------------------------------------------
//Type 131 8.4.2.116 PREP element
void 802_11::PREP()
{
	BBYT( 0, l[1], 0x90, 0xc9, "Flags:" );			g[2] -= 1;
		DECR 1;
		BBIT( 1, l[10], 0x90, 0xc2, "Reserved:" );
		BBIT( 1, l[11], 0x90, 0xc2, "AE:" );
		BBIT( 6, l[12], 0x90, 0xc2, "Reserved:" );
	LABL( 0, 0, 0, 0xc8 );
	DBYT( 0, l[2], 0x90, 0xc2, "Hop Count:" );			g[2] -= 1;
	DBYT( 0, l[3], 0x90, 0xc2, "Element TTL:" );			g[2] -= 1;
	ETHR( 0, 0, 0x90, 0xc2, "Target Mesh STA Address:" );				g[2] -= 6;
	DLNG( 0x40000000, 0, 0x90, 0xc2, "Target HWMP Sequence Number:" );			g[2] -= 4;
	if ( l[11] == 0x01 )
	{
		ETHR( 0, 0, 0x90, 0xc2, "Originator External Address:" );				g[2] -= 6;
	}
	DLNG( 0x40000000, l[4], 0x90, 0xc2, "Lifetime:" );			g[2] -= 4;
	DLNG( 0x40000000, l[5], 0x90, 0xc2, "Metric:" );			g[2] -= 4;
	ETHR( 0, 0, 0x90, 0xc2, "Originator Mesh STA Address:" );				g[2] -= 6;
	DLNG( 0x40000000, l[6], 0x90, 0xc2, "Originator HWMP Sequence Number:" );			g[2] -= 4;	
}
//------------------------------------------------------
//Type 132 8.4.2.117 PERR element
void 802_11::PERR()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Element TTL:" );			g[2] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "Number of Destinations:" );			g[2] -= 1;
	LABL( 0, 0, 0x90, 0xc9, "Targets:" );
	l[20] = 1;
	while (l[2] != 0)
	{
		DGLB( 0, l[20], 0, 0xc9, "Target #"  );
		LABL( 0, 0, 0, 0x09, ":" );
		BBYT( 0, l[1], 0x90, 0xc9, "Flags:" );			g[2] -= 1;
			DECR 1;
			BBIT( 1, l[10], 0x90, 0xc2, "Reserved:" );
			BBIT( 1, l[11], 0x90, 0xc2, "AE:" );
			BBIT( 6, l[12], 0x90, 0xc2, "Reserved:" );
		LABL( 0, 0, 0, 0xc8 );
		ETHR( 0, 0, 0x90, 0xc2, "Destination Address #1:" );				g[2] -= 6;
		DLNG( 0x40000000, 0, 0x90, 0xc2, "HWMP Sequence Number:" );			g[2] -= 4;
		if ( l[11] == 0x01 )
		{
			ETHR( 0, 0, 0x90, 0xc2, "Destination External Address:" );				g[2] -= 6;
		}
		DWRD( 0x40000000, 0, 0x90, 0xc2, "Reason Code:" );			g[2] -= 2;
		l[2] -= 1;
		l[20] += 1;
	}
	LABL( 0, 0, 0, 0xc8 );
}
//------------------------------------------------------
//Type 133
void 802_11::IE_Cisco;
	802_11::Print_OUI();
	HEX# 7 0 90 C2 Value:;
	CHR# 10 0 90 C2 AP Name:;
	DBYT 0 0 90 C2 Number of clients:;
	SUBG 1b 2;
	HEX# 0 2 90 C2 Value:;
	//TRTS;
//------------------------------------------------------
//Type 137 8.4.2.118 PXU element
void 802_11::PXU()
{
	DBYT( 0, l[1], 0x90, 0xc2, "PXU ID:" );			g[2] -= 1;
	ETHR( 0, 0, 0x90, 0xc2, "PXU Originator MAC Address:" );				g[2] -= 6;
	DBYT( 0, l[2], 0x90, 0xc2, "Number of Proxy Informations:" );			g[2] -= 1;
	LABL( 0, 0, 0x90, 0xc9, "Informations:" );
	l[20] = 1;
	while (l[2] != 0)
	{
		DGLB( 0, l[20], 0, 0xc9, "Information #"  );
		LABL( 0, 0, 0, 0x09, ":" );
		BBYT( 0, l[1], 0x90, 0xc9, "Flags:" );			g[2] -= 1;
			DECR 1;
			BBIT( 5, l[10], 0x90, 0xc2, "Reserved:" );			
			BBIT( 1, l[11], 0x90, 0xc2, "Lifetime:" );
			BBIT( 1, l[12], 0x90, 0xc2, "Originator Is Proxy:" );
			BBIT( 1, l[13], 0x90, 0xc2, "Delete:" );
		LABL( 0, 0, 0, 0xc8 );
		ETHR( 0, 0, 0x90, 0xc2, "External MAC Address:" );				g[2] -= 6;
		DLNG( 0x40000000, l[6], 0x90, 0xc2, "Proxy Information Sequence #:" );			g[2] -= 4;		
		if ( l[12] == 0x01 )
		{
			ETHR( 0, 0, 0x90, 0xc2, "Proxy MAC Addres:" );				g[2] -= 6;
		}
		if ( l[11] == 0x01 )
		{
			DLNG( 0x40000000, 0, 0x90, 0xc2, "Proxy Information Lifetime:" );			g[2] -= 4;		
		}
		l[2] -= 1;
		l[20] += 1;
	}
	LABL( 0, 0, 0, 0xc8 );
}
//------------------------------------------------------
//Type 138 8.4.2.119 PXUC element
void 802_11::PXUC()
{
	DBYT( 0, l[1], 0x90, 0xc2, "PXU ID:" );			g[2] -= 1;
	ETHR( 0, 0, 0x90, 0xc2, "PXU Recipient MAC Address:" );				g[2] -= 6;
}
//------------------------------------------------------
//Type 139 8.4.2.120 Authenticated Mesh Peering Exchange element
void 802_11::Authenticated_Mesh_Peering_Exchange()
{
	DLNG( 0x40000000, 0, 0x90, 0xc2, "Selected Pairwise Cipher Suite:" );			g[2] -= 4;
	HEX#( 0, 32, 0x90, 0xc2, "Local Nonce:" );			g[2] -= 32;
	HEX#( 0, 32, 0x90, 0xc2, "Peer Nonce:" );			g[2] -= 32;
	D64B( 0x40000000, l[1], 0x90, 0xc2, "Key Replay Counter:" );			g[2] -= 8;	
}
//------------------------------------------------------
//Type 140 8.4.2.121 MIC element
void 802_11::MIC()
{
	HEX#( 0, 16, 0x90, 0xc2, "MIC:" );			g[2] -= 16;
}
//------------------------------------------------------

//------------------------------------------------------

//------------------------------------------------------


//------------------------------------------------------


//------------------------------------------------------
//Type 173
void 802_11::IE_Symbol;
	802_11::Print_OUI();
	SEQU 9 2;
	SKIP 80000001;
	TNXT -Short Symbol IE;
	DWRD 0 0 90 C2 Number of clients:;
	DWRD 0 0 90 C2 Load (kbps):;
	DWRD 0 0 90 C2 Load (kpps):;
	DWRD 0 0 90 C2 Tx power:;
	DLNG 0 0 90 C2 ntp time:;
	//TRTS;

void Short Symbol IE;
	DBYT 0 0 90 C2 Number of clients:;
	DWRD 0 0 90 C2 Load (kbps):;
	DWRD 0 0 90 C2 Load (kpps):;
	DBYT 0 0 90 C2 Tx power:;
	TRTS;

//------------------------------------------------------
void 802_11::IE_Type_221;
	// si: check for cisco vendor specific
	l[1] = pl[0];
	ANDG ffffff00 41;
	TSB# 0 41 0 0 802_11::IE_Type_221_VendorSpecificFuncs; 
	SKIP 1;
	802_11::IE_Type_221_Generic();
	
    TRTS;

void 802_11::IE_Type_221_Generic()
{
	//at least print the OUI of the element
	802_11::Print_OUI();
	//fix up the length of the ie element since we printed 3 bytes
	g[2] -= 3;
	DUMP 0 2 90 c2 Value:;
	TRTS;
}

str# 802_11::VendorSpecificActionFuncs;
	0x506f9a00 | 802_11::VendorSpecificAction::WiFiAlliance;
	
void 802_11::VendorSpecificAction::WiFiAlliance()
{
	802_11::Print_OUI();
	g[2] -= 3;
	DBYT 0 41 90 c2 Subtype:;
	if( l[1] == 9 )
	{
		802_11::WFP2P::PublicAction();
	}
}

str# 802_11::IE_Type_221_VendorSpecificFuncs;
	0x00037f00	|	802_11::IE_Type_221::AtherosCom;
	0x00040e00	|	802_11::IE_Type_221::AVMGMBH;
	0x000fac00	|	802_11::IE_Type_221::KDE;
	0x00409600	|	802_11::IE_Type_221::Cisco;
	0x00504300	|	802_11::IE_Type_221::Marvell;
	0x00904C00	|	802_11::IE_Type_221::Epigram;
	0x0050F200	|	802_11::IE_Type_221::Microsoft;
	0x506f9a00	|	802_11::IE_Type_221::WiFiAlliance;
	

str# 802_11:IE_Type_221_WPFuncs;
	0x0050F201 | 802_11::IE_WPA;
	0x0050F202 | 802_11::IE_WME;
	0x0050F204 | 802_11::IE_WPS;


void 802_11::IE_Type_221::AVMGMBH()
{
	LABL( 0, 0, 0, 0xb7, "AVM GmbH" );
	//print the OUI of the element
	802_11::Print_OUI();
	//fix up the length of the ie element since we printed 3 bytes
	g[2] -= 3;
	DBYT( 0, l[1], 0x90, 0xc2, "Vend. Spec. OUI Type:" );g[2] -= 1;
	DUMP 0 2 90 c2 Value:;
	LABL( 0, 0, 0, 0xc8 );
}

void 802_11::IE_Type_221::AtherosCom()
{
	LABL( 0, 0, 0, 0xb7, "Atheros Communications, Inc." );
	802_11::Print_OUI();
	g[2] -= 3;
	DBYT( 0, l[1], 0x90, 0xc2, "Vend. Spec. OUI Type:" );g[2] -= 1;
	DBYT( 0, l[2], 0x90, 0xc2, "Type:" );g[2] -= 1;
		CST#( 0, l[2], 0, 0x14, 802_11::IE_Type_221::AtherosCom::Type );
		CLSE( 0, 0, 0, 0x14, "Unknown" );
	//DBYT( 0, l[3], 0x90, 0xc2, "Subtype:" );g[2] -= 1;
	DBYT( 0, l[4], 0x90, 0xc2, "Version:" );g[2] -= 1;
	BBYT( 0, l[5], 0x90, 0xc2, "Capabilities:" );g[2] -= 1;
	if (l[2] == 0x01)
	{
		HEX# 0 2 90 c2 Default Key Index:;
	}
	if (l[2] == 0x02)
	{
		DBYT( 0, l[6], 0x90, 0xc2, "Xr Info:" );
		ETHR( 0, 0, 0x90, 0xc2, "Xr Base BSSID:" );
		ETHR( 0, 0, 0x90, 0xc2, "Xr  BSSID:" );
		DWRD( 0, l[7], 0x90, 0xc2, "Xr Beacon:" );
		DBYT( 0, l[8], 0x90, 0xc2, "Xr Base Capabilities:" );
		DBYT( 0, l[9], 0x90, 0xc2, "Xr Capabilities:" );
		g[2] -= 17;
	}
	LABL( 0, 0, 0, 0xc8 );
}

str# 802_11::IE_Type_221::AtherosCom::Type;
1	|	Advanced Capability;
2	|	eXtended Range;

void 802_11::IE_Type_221::Microsoft()
{
	l[1] = pl[0];
	
	TSB# 0 41 0 0 802_11:IE_Type_221_WPFuncs;
	SKIP 1;
	802_11::IE_Type_221_Generic();
	TRTS;
}

void 802_11::IE_WPA;
	g[6] = pb[0];
	g[7] = g[6];
	g[6] = pb[1];
	SHFL 8 7;
	ADDG 6 87;
	g[6] = pb[2];
	SHFL 8 7 0 0;
	ADDG 6 87;
	if (g[7] != 0x0050f2)
	{
		TRTS;						// si: this is not wpa then
	}
	HEX# 80000001 0 90 c2 OUI:;
	HEX# 80000001 0 90 00 -;
	HEX# 80000001 0 90 00 -;
	HEX# 80000001 0 90 00 -;
	DWRD C0000000 0 90 c2 Version:;
	HEX# 80000001 0 90 c2 Multicast cipher OUI:;
	HEX# 80000001 0 90 00 -;
	HEX# 80000001 0 90 00 -;
	HBYT 80000000 8b 90 00 -;
	 CEQU 0 b 0 14 None;
	 CEQU 1 b 0 14 WEP;
	 CEQU 2 b 0 14 TKIP;
	 CEQU 3 b 0 14 WRAP;
	 CEQU 4 b 0 14 CCMP;
	 s[11] = g[11];
	//DGLB( 0, g[11], 0x90, 0xc2, g11: );
	//DGLB( 0, s[11], 0x90, 0xc2, s11: );
	 
	g[2] -= 10;
	DWRD C0000000 83 90 c2 Number of Unicasts:;
	g[2] -= 2;
	802_11::IE_SSN Unicast Loop;
	DWRD C0000000 83 90 c2 Number of Auths:;
	g[2] -= 2;
	802_11::IE_SSN Auth Loop;
	
	TGTE 0  2 0 0 RETURN;
	
	DWRD 40000000 1 5 5;
	DECR 2;
	l[1] = g[1];
	ANDG 30 41;
	SHFR 4 41;
		DGLB 0 41 90 c2 GTKSA Replay Ctr:;
		CEQU 0 41 00 14 0 - 1 replay counter;
		CEQU 1 41 00 14 1 - 2 replay counter;
		CEQU 2 41 00 14 2 - 4 replay counter;
		CEQU 3 41 00 14 3 - 16 replay counter;
	DWRD 0 0 5 5;
	DECR 2;
	
	l[1] = g[1];
	ANDG c 41;
	SHFR 2 41;
		DGLB 0 41 90 c2 PTKSA Replay Ctr:;
		CEQU 0 41 00 14 0 - 1 replay counter;
		CEQU 1 41 00 14 1 - 2 replay counter;
		CEQU 2 41 00 14 2 - 4 replay counter;
		CEQU 3 41 00 14 3 - 16 replay counter;
	DWRD 0 0 5 5;
	g[2] -= 2;
	TGTE 0  2 0 0 RETURN;
	
	
	if (g[2] > 0)
	{	
		DUMP 0 2 90 c2 Remaining Data:;
	}
	TRTS;

void 802_11::IE_Type_221::KDE()
{
	l[1] = pl[0];
	
	TSB# 0 41 0 0 802_11::IE_Type_221::KDEFuncs;
	SKIP 1;
	802_11::IE_Type_221_Generic();
	TRTS;
}

str# 802_11::IE_Type_221::KDEFuncs;
	0x000fac01 | 802_11::IE_Type_221::GTK_KDE;
	0x000fac03 | 802_11::IE_Type_221::MAC_KDE;
	0x000fac04 | 802_11::IE_Type_221::PMKID_KDE;
	0x000fac05 | 802_11::IE_Type_221::SMK_KDE;
	0x000fac06 | 802_11::IE_Type_221::Nonce_KDE;
	0x000fac07 | 802_11::IE_Type_221::Lifetime_KDE;
	0x000fac08 | 802_11::IE_Type_221::Error_KDE;
    0x000fac09 | 802_11::IE_Type_221::IGTK_KDE;
	
//the length of the IE should be in g[2]
void 802_11::IE_Type_221::GTK_KDE()
{
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Type:;
	LABL 0 0 0 14 GTK KDE;
	BBYT 0 41 90 c9 GTK Options:;
	LABL 0 0 0 d4	xxxx x... Reserved;
	CBIT 2 41 0 d4	.... .1.. Key used for both Tx and Rx;
	CLSE 0 0 0 d4	.... .0.. Key used for Rx only;
	l[1] &= 0x03;
	CEQU 0 41 0 d4	.... ..00 Key ID 0;
	CEQU 1 41 0 d4	.... ..01 Key ID 1;
	CEQU 2 41 0 d4	.... ..10 Key ID 2;
	CEQU 3 41 0 d4	.... ..11 Key ID 3;
	LABL 0 0 0 c8;
	HBYT 0 41 90 c2 Reserved:;	
	g[2] -= 6;	
	if( g[2] > 0 )
	{
		HEX# 0 2 90 c2 GTK:;
	}
}

//the length of the IE should be in g[2]
void 802_11::IE_Type_221::MAC_KDE()
{
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Type:;
	LABL 0 0 0 14 MAC KDE;
	g[2] -= 4;	//subtract the oui and data type from the ie length
	if( g[2] == 6 )
	{
		ETHR 0 0 90 c2 MAC Address:;
		TRTS;
	}
	DUMP 0 2 90 c2 MAC Address:;
}

//the length of the IE should be in g[2]
void 802_11::IE_Type_221::PMKID_KDE()
{
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Type:;
	LABL 0 0 0 14 PMKID KDE;
	g[2] -= 4;	//subtract the oui and data type from the ie length	
	HEX# 0 2 90 c2 PMKID:;
}

//the length of the IE should be in g[2]
void 802_11::IE_Type_221::SMK_KDE()
{
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Type:;
	LABL 0 0 0 14 SMK KDE;
	g[2] -= 4;	//subtract the oui and data type from the ie length	
	HEX# 20 0 90 c2 SMK:;
	HEX# 20 0 90 c2 Nonce:;
}

//the length of the IE should be in g[2]
void 802_11::IE_Type_221::Nonce_KDE()
{
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Type:;
	LABL 0 0 0 14 Nonce KDE;	
	g[2] -= 4;	//subtract the oui and data type from the ie length	
	HEX# 20 0 90 c2 Nonce:;
}

//the length of the IE should be in g[2]
void 802_11::IE_Type_221::Lifetime_KDE()
{
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Type:;
	LABL 0 0 0 14 Lifetime KDE;
	g[2] -= 4;	//subtract the oui and data type from the ie length	
	DLNG 0 41 90 c2 Lifetime:;
	LABL 0 0 0 d4 seconds;
}

//the length of the IE should be in g[2]
void 802_11::IE_Type_221::Error_KDE()
{
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Type:;
	LABL 0 0 0 14 Lifetime KDE;
	g[2] -= 4;	//subtract the oui and data type from the ie length	
	HWRD 0 41 90 c2 MUI:;
	CEQU 01 41 0 d4 4 Way PTK Handshake;
	CEQU 02 41 0 d4 4 Way STK Handshake;
	CEQU 03 41 0 d4 GTK Handshake;
	CEQU 04 41 0 d4 SMK Handshake;
	DWRD 0 41 90 c2 Error Type:;
	CEQU 1 41 0 d4 STA is not reachable from AP;
	CEQU 2 41 0 d4 STA to AP secure network not present;
	CEQU 3 41 0 d4 Cipher suites not supported;
	CEQU 4 41 0 d4 No STSL session present;
}

//the length of the IE should be in g[2]
void 802_11::IE_Type_221::IGTK_KDE()
{
	802_11::Print_OUI();
	DBYT 0 41 90 c2 Type:;
	LABL 0 0 0 14 IGTK KDE;   
    DWRD 40000000 41 90 c2 Key ID:;
    HEX# 06 00 90 c2 IPN:;
    
    l[1] = g[2];
    l[1] -= 12;     //IGTK length is IE length - 12 bytes
    
    HEX# 00 41 90 c2 IGTK:;
}

void 802_11::IE_SSN Unicast Loop;
	TGTE 0 3 0 0 RETURN;
	HEX# 80000001 0 90 c2 Unicast cipher OUI:;
	HEX# 80000001 0 90 00 -;
	HEX# 80000001 0 90 00 -;
	HBYT 80000000 8b 90 00 -;
	CEQU 0 b 0 14 None;
	CEQU 1 b 0 14 WEP;
	CEQU 2 b 0 14 TKIP;
	CEQU 3 b 0 14 WRAP;
	CEQU 4 b 0 14 CCMP;
	SUBG 1 3;
	g[2] -= 4;
	TNXT -802_11::IE_SSN Unicast Loop;

void 802_11::IE_SSN Auth Loop;
	TGTE 0 3 0 0 RETURN;
	HEX# 80000001 0 90 C2 Auth OUI:;
	HEX# 80000001 0 90 00 -;
	HEX# 80000001 0 90 00 -;
	HBYT 80000000 8b 90 00 -;
	CEQU 0 b 0 14 None;
	CEQU 1 b 0 14 SSN;
	CEQU 2 b 0 14 SSNPSK;
	SUBG 1 3;
	g[2] -= 4;
	TNXT -802_11::IE_SSN Auth Loop;

	
//-------------------------------------------------

void 802_11::IE_WME;
	// check on length
	if ( g[2] == 7 )
	{
		802_11::Print_OUI();
		DBYT 80000001 0 90 c2 OUI Type:;			// expect 2
		DBYT 80000001 0 90 c2 OUI SubType:;			// expect 0
		LABL		0 0 00 14 Information Element;
		DBYT 80000001 0 90 c2 Version:;				// expect 1
		if (g[0xa] == 0)							// management
		{
			TSB# 0 e 0 0 802_11::IE_WMM::QoSInfo_Management;
		}
		if (g[0xa] == 2)							// data
		{
			TSB# 0 C 0 0 802_11::IE_WMM::QoSInfo_Data;
		}
		TRTS;
	}
	
	if ( g[2] == 24 )
	{
		802_11::Print_OUI();
		DBYT 0 0 90 c2 OUI Type:;					// expect 2
		DBYT 0 0 90 c2 OUI SubType:;				// expect 1
		LABL 0 0 00 14 Parameter Element;
		DBYT 0 0 90 c2 Version:;					// expect 1
		if (g[0xa] == 0)							// management
		{
			TSB# 0 e 0 0 802_11::IE_WMM::QoSInfo_Management;
		}
		if (g[0xa] == 2)							// data
		{
			TSB# 0 C 0 0 802_11::IE_WMM::QoSInfo_Data;
		}
		HBYT 0 0 90 c2 Reserved:;
		LABL 0 0 0 c7 Access Category - Best Effort;
		 802_11::IE_WME::AC;
		 LABL 0 0 0 c8;
		LABL 0 0 0 c7 Access Category - Background;
		 802_11::IE_WME::AC;
		 LABL 0 0 0 c8;
		LABL 0 0 0 c7 Access Category - Video;
		 802_11::IE_WME::AC;
		 LABL 0 0 0 c8;
		LABL 0 0 0 c7 Access Category - Voice;
		 802_11::IE_WME::AC;
		 LABL 0 0 0 c8;
		TRTS;
	}
	if ( g[2] == 61 )
	{
		802_11::Print_OUI();
		DBYT 0 0 90 c2 OUI Type:;					// expect 2
		DBYT 0 0 90 c2 OUI SubType:;				// expect 2
		LABL 0 0 00 14 TSPEC;
		DBYT 0 0 90 c2 Version:;					// expect 1
		802_11::IE_WME::TS_Info;
		DWRD 40000000 4 90 c9 Nominal MSDU Size:;
		 CBIT f 4 00 d4 Size is Fixed;
		 CLSE 0 0 00 d4 Size Might not be Fixed;
		 l[1] = g[4];
		 ANDG 7fff 41;
		 DGLB 0 41 04 d4 "Size: ";
		 LABL 0 0 00 c8;
		DWRD 40000000 0 90 c2 Maximum MSDU Size:;
		DLNG 40000000 0 90 c2 Min Service Interval:;
		DLNG 40000000 0 90 c2 Max Service Interval:;
		DLNG 40000000 0 90 c2 Inactivity Interval:;
		DLNG 40000000 0 90 c2 Suspension Interval:;
		DLNG 40000000 0 90 c2 Service Start Time:;
		DLNG 40000000 0 90 c2 Min Data Rate:;
		DLNG 40000000 0 90 c2 Mean Data Rate:;
		LABL		0 0 00 14 bits per second;
		DLNG 40000000 0 90 c2 Peak Data Rate:;
		DLNG 40000000 0 90 c2 Max Burst Size:;
		DLNG 40000000 0 90 c2 Delay Bound:;
		DLNG 40000000 0 90 c2 Min PHY Rate:;
		LABL		0 0 00 14 bits per second;
		802_11::Print_Surplus_Bandwidth_Allowance;
		DWRD 40000000 0 90 c2 Medium Time:;
		LABL		0 0 00 14 (units of 32 microsecond periods/second);
		TRTS;
	}
	if (g[2] > 0)
	{
		DUMP 0 2 90 c2 Value:;
	}
	TRTS;
	

// WMM Qos Info Field Management frames
str# 802_11::IE_WMM::QoSInfo_Management;
	0	| 802_11::IE_WMM::QoSInfo_STA;		// association request
	1	| 802_11::IE_WMM::QoSInfo_AP;		// association response
	2	| 802_11::IE_WMM::QoSInfo_STA;
	3	| 802_11::IE_WMM::QoSInfo_AP;
	4	| 802_11::IE_WMM::QoSInfo_STA;		// probe request
	5	| 802_11::IE_WMM::QoSInfo_AP;		// probe response
	8	| 802_11::IE_WMM::QoSInfo_AP;		// beacon

// QoS Info field when sent from WMM AP (WMM Spec 1.1)
void 802_11::IE_WMM::QoSInfo_AP()
{
	BBYT 00000001 4 90 c9 QoS Info:;
	CBIT 7 4 00 d4 1... .... WMM AP supports U-APSD;
	CLSE 0 0 00 d4 0... .... WMM AP does not support U-APSD;
	LABL 0 0 00 d4 .xxx .... Reserved;
	ANDG f 4;
	CST# 0 4 00 d4 802_11::IE_WME::QoS_Info_Field;
	CLSE 0 0 00 d4 .... 0000 Parameter Set Count: 0;
	LABL 0 0 00 c8;
}

// QoS Info field when sent from WMM STA (WMM Spec 1.1)
void 802_11::IE_WMM::QoSInfo_STA()
{
	BBYT( 0, l[1], 0x90, 0xc9, "QoS Info:" );
	DECR 1;
	BBIT( 1, l[2], 0x5, 0xc9);										
		CEQU( 1, l[2], 0x0, 0x54, "1... .... More Data Ack: can process Ack frames with the More Data bit" );
		CEQU( 0, l[2], 0x0, 0x54, "0... .... More Data Ack: not Set" );
	BBIT( 2, l[2], 0x5, 0xc9);
		CEQU( 3, l[2], 0x0, 0x54, ".11. .... WMM AP may deliver a maximum of 6 buffered frames" );
		CEQU( 2, l[2], 0x0, 0x54, ".10. .... WMM AP may deliver a maximum of 4 buffered frames" );
		CEQU( 1, l[2], 0x0, 0x54, ".01. .... WMM AP may deliver a maximum of 2 buffered frames" );
		CEQU( 0, l[2], 0x0, 0x54, ".00. .... WMM AP may deliver all buffered frames (MSDUs and MMPDUs)" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, "...1 .... Q-Ack: dot11QAckOptionImplemented Set" );
		CEQU( 0, l[2], 0x0, 0x54, "...0 .... Q-Ack: not set" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, ".... 1... Access category: Best Effort U-APSD - Enabled" );
		CEQU( 0, l[2], 0x0, 0x54, ".... 0... Access category: Best Effort U-APSD - Disabled" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, ".... .1.. Access category: Background U-APSD - Enabled" );
		CEQU( 0, l[2], 0x0, 0x54, ".... .0.. Access category: Background U-APSD - Disabled" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, ".... ..1. Access category: Video U-APSD - Enabled" );
		CEQU( 0, l[2], 0x0, 0x54, ".... ..0. Access category: Video U-APSD - Disabled" );
	BBIT( 1, l[2], 0x5, 0xc9);
		CEQU( 1, l[2], 0x0, 0x54, ".... ...1 Access category: Voice U-APSD - Enabled" );
		CEQU( 0, l[2], 0x0, 0x54, ".... ...0 Access category: Voice U-APSD - Disabled" );
	LABL( 0, 0, 0, 0xc8);
}

str# 802_11::IE_WMM::QoSInfo_Data;
	0 |	802_11::IE_WMM::QoSInfo_STA;		//IBSS			
	1 | 802_11::IE_WMM::QoSInfo_AP;			//From the AP
	2 | 802_11::IE_WMM::QoSInfo_STA;		//To the AP
	3 | 802_11::IE_WMM::QoSInfo_AP;			//Wireless DS

void 802_11::IE_WME::TS_Info;
	/*INCR 2;
	HBYT 00000000 41 90 5 TS InfoByte3:;
	DECR 2;
	HBYT 80000000 42 90 5 TS InfoByte2:;
	DECR 2;
	HBYT 80000000 43 90 5 TS InfoByte1:;
	INCR 2;*/ //this routine messes up the offset counter!
	l[1] = pb[2];
	l[2] = pb[1];
	l[3] = pb[0];
	HEX#( 0x4000003, 3, 0x05, 0xc9, "TS Info:" );
	//HGLB 0  41  0 d4 ;
	//HGLB 0  42  0 d4 ;
	//HGLB 0  43  0 d4 ;
	SHFL( 8, l[1] );
	l[1] += l[2];
	SHFL( 8, l[1] );
	l[1] += l[3];
		HGLB( 0, l[1], 0x90, 0x02);
		g[1] = l[1];
		LABL 0 0 00 d4 xxxxxx.. ........ ........ Reserved;
		l[1] = g[1];
		ANDG 30000 41;
		SHFR 10 41;
		CEQU 3 41 00 d4 ......11 ........ ........ Scheduled APSD;
		CEQU 2 41 00 d4 ......10 ........ ........ Unscheduled APSD;
		CEQU 1 41 00 d4 ......01 ........ ........ Reserved;
		CEQU 0 41 00 d4 ......00 ........ ........ No Schedule;
		l[1] = g[1];
		ANDG c000 41;
		SHFR e 41;
		CEQU 3 41 00 d4 ........ 11...... ........ TSInfo Ack Policy: Block acknowledgement;
		CEQU 2 41 00 d4 ........ 10...... ........ TSInfo Ack Policy: Reserved;
		CEQU 1 41 00 d4 ........ 01...... ........ TSInfo Ack Policy: No acknowledgement;
		CEQU 0 41 00 d4 ........ 00...... ........ TSInfo Ack Policy: Normal IEEE 802.11 acknowledgement;
		l[1] = g[1];
		ANDG 38 41;
		SHFR 3 41;
		CST# 0 41 00 d4 802_11::IE_Type_13::UP_Field;
		CBIT a 1 00 d4 ........ .....1.. ........ PSB: U-APSD;
		CLSE 0 0 00 d4 ........ .....0.. ........ PSB: Legacy;
		CBIT 9 1 00 d4 ........ ......1. ........ Aggregation: Reserved;
		CLSE 0 0 00 d4 ........ ......0. ........ Aggregation: Reserved;
		l[1] = g[1];
		ANDG 180 41;
		SHFR 7 41;
		CEQU 3 41 00 d4 ........ .......1 1....... AP: HEMM - HCCA, EDCA mixed mode;
		CEQU 2 41 00 d4 ........ .......1 0....... AP: HCCA - Controlled channel access;
		CEQU 1 41 00 d4 ........ .......0 1....... AP: EDCA - Contention based channel access;
		CEQU 0 41 00 d4 ........ .......0 0....... AP: Reserved;
		l[1] = g[1];
		ANDG 60 41;
		SHFR 5 41;
		CST# 0 41 00 d4 802_11::IE_WME::TS_INFO::Direction;
		CLSE 0 00 00 d4 ........ ........ .00..... Direction: Uplink;
		l[1] = g[1];
		ANDG 1e 41;
		SHFR 1 41;
		CST# 0 41 00 d4 802_11::IE_WME::TS_INFO::TID;
		CLSE 0 00 00 d4 ........ ........ ...0000. TID: EDCA: 0;
		CBIT 0 01 00 d4 ........ ........ .......1 Traffic Type: Reserved;	//periodic traffic pattern;
		CLSE 0 00 00 d4 ........ ........ .......0 Traffic Type: Reserved;	//unspecified traffic pattern;
		LABL 0 00 00 c8;
	TRTS;



void 802_11::IE_WME::AC;
	BBIT 40000008 4 90 c9 ACI/AIFSN:;
	 LABL 00 00 00 d4 x... .... Reserved;
	 l[4] = g[4];
	 ANDG 60 44;						
	 SHFR 05 44;
	 CST# 00 44 00 d4 802_11::IE_WME::AC::ACI;
	 CLSE 00 00 00 d4 .00. .... ACI: Best Effort;
	 CBIT 04 04 00 d4 ...1 .... ACM: Admission Control Mandatory;
	 CLSE 00 00 00 d4 ...0 .... ACM: Admission Control Not Mandatory;
	 ANDG f 4;
	 CST# 00 04 00 d4 802_11::IE_WME::AC::AIFSN;
	 CLSE 00 00 00 d4 .... 0000 AIFSN: 0;
	 LABL 00 00 00 c8;		
	BBIT 8 4 90 c9 ECW Min/Max:;
	 l[4] = g[4];
	 ANDG f0 44;
	 SHFR 04 44;
	 CST# 00 44 00 d4 802_11::IE_WME::AC::CW_MAX;
	 CLSE 00 00 00 d4 0000 .... CW Max: 0;
	 l[4] = g[4];
	 ANDG 0f 44;
	 CST# 00 44 00 d4 802_11::IE_WME::AC::CW_MIN;
	 CLSE 00 00 00 d4 .... 0000 CW Min: 0;
	 LABL 00 00 00 c8;
	DWRD 40000000 00 90 c2 TXOP Limit:;
	TRTS;

//-------------------------------------------------

void 802_11::IE_Type_221::Cisco;
	802_11::Print_OUI();
	g[2] -= 3;
	l[1] = pb[0];
	if (l[1] == 3)
	{
		DBYT 80000001 0 90 c2 Version:;
		DBYT 80000001 0 90 c2 CCX Version:;
		g[2] -= 2;
		if (g[2] > 0)
		{
			DUMP 0 2 90 c2 Data:;
		}
	}
	if (l[1] != 3)
	{
		DUMP 0 2 90 c2 Data:;
	}
	TRTS;

//-------------------------------------------------
void 802_11::IE_Type_221::Marvell;
	802_11::Print_OUI();
	g[2] -= 3;
	DUMP 0 2 90 c2 Data:;
	TRTS;
//-------------------------------------------------
void 802_11::IE_Type_221::Epigram;
	802_11::Print_OUI();
	g[2] -= 3;
	
	DBYT 0 41 90 c2 OUI Type:;
	//DBYT 0 0 90 c2 OUI SubType:;
	g[2] -= 1;
	if (l[1] == 51)
	{
		802_11::IE_HT_Capability;
		l[1] = 51;
	}
	if (l[1] != 51)
	{
		DUMP 0 2 90 c2 Data:;
	}
	TRTS;
//-------------------------------------------------
void 802_11::IE_Type_221::WiFiAlliance()
{	
	802_11::Print_OUI();
	g[2] -= 3;
	HBYT( 0, l[5], 0x90, 0xc2, "OUI type:" );
	CST# 0 45 90 14 802_11::IE_Type_221::WiFiAlliance::OuiTypes2;
	g[2] -= 1;
	while (g[2] != 0)
	{
		if (l[5] == 0x0a)
		{		
			802_11::IE_Type_221::WiFiAlliance::LOOP;
		}
		if (l[5] == 0x09)
		{		
			while (g[2] != 0)
			{
				while (g[2] > 0)
				{
					802_11::WFP2P::Attributes;
				}
			}
		}
		if (l[5] == 0x10)
		{
			//LABL( 0, 0, 0, 0x14, "Hotspot 2.0 Indication" );
			//DBYT( 0, 0, 0x90, 0xc2, "OUI type:" );
			BBYT( 0, l[21], 0x90, 0xc9, "Flags:" );
			LABL 0 0 0 d4  xxxx xxx. Reserved;
			CBIT( 0, l[21], 0, 0xd4, ".... ...1 DGAF Disabled: Yes" );
			CLSE( 0, 0, 0, 0xd4, ".... ...0 DGAF Disabled: No" );
			LABL 00 00 00 c8;
			g[2] -= 1;
		}
		if (l[5] == 0x13)
		{
			while( g[2] > 0 )
			{
				DBYT( 0, l[21], 0x90, 0xc2, "Attribute ID:" );
					CST#( 0, l[21], 0, 0x14, 802_11::IE_Type_221::WiFiAlliance::NAN::Types );
					CLSE( 0, 0, 0, 0x14, "Reserved" );
				DWRD( 0, l[22], 0x90, 0xc2, "Length:" );
				g[2] -= 3;
				if(l[22] > 0)
				{
					CST#( 0, l[21], 0, 0xb7, 802_11::IE_Type_221::WiFiAlliance::NAN::Types );
					TSB#( 0, l[21], 0, 0, 802_11::IE_Type_221::WiFiAlliance::NAN::Types::Ldr );
					if (l[21] <= 13)
					{
						if (l[21] != 221)
						{
							HEX# 0 2 90 c2 Unknown WiFi Alliance NAN Data:;
							g[2] -= g[2];
						}
					}
					LABL 0 0 0 c8;
				}
			}
		}
		if (l[5] != 0x0a)
		{
			if (l[5] != 0x09)
			{
				if (l[5] != 0x10)
				{
					if (l[5] != 0x13)
					{
						HEX# 0 2 90 c2 Unknown OUI Type Data:;
						g[2] -= g[2];
					}
				}
			}
		}
	}
}

str# 802_11::IE_Type_221::WiFiAlliance::NAN::Types;
0	|	Master Indication Attribute;
1	|	Cluster Attribute;
2	|	Service ID List Attribute;
3	|	Service Descriptor Attribute;
4	|	NAN Connection Capability Attribute;
5	|	WLAN Infrastructure Attribute;
6	|	P2P Operation Attribute;
7	|	IBSS Attribute;
8	|	Mesh Attribute;
9	|	Further NAN Service Discovery Attribute;
10	|	Further Availability Map Attribute;
11	|	Country Code Attribute;
12	|	Ranging Attribute;
13	|	Cluster Discovery Attribute2;
//14-220	|	Reserved;
221	|	Vendor Specific Attribute;
//222-255	|	Reserved;

str# 802_11::IE_Type_221::WiFiAlliance::NAN::Types::Ldr;
0	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::MasterIndicationAttribute;
1	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::ClusterAttribute;
2	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::ServiceIDListAttribute;
3	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::ServiceDescriptorAttribute;
4	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::NANConnectionCapabilityAttribute;
5	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::WLANInfrastructureAttribute;
6	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::P2POperationAttribute;
7	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::IBSSAttribute;
8	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::MeshAttribute;
9	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::FurtherNANServiceDiscoveryAttribute;
10	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::FurtherAvailabilityMapAttribute;
11	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::CountryCodeAttribute;
12	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::RangingAttribute;
13	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::ClusterDiscoveryAttribute2;
221	|	802_11::IE_Type_221::WiFiAlliance::NAN::Types::VendorSpecificAttribute;

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::MasterIndicationAttribute()
{
	DBYT( 0, l[1], 0x90, 0xc2, "Master Preference:" );
	DBYT( 0, l[2], 0x90, 0xc2, "Random Factor:" );
	g[2] -= 2;
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::ClusterAttribute()
{
	D64B( 0x40000000, l[1], 0x90, 0xc2, "Anchor Master Rank:" );
	DBYT( 0, l[2], 0x90, 0xc2, "Hop Count to Anchor Master:" );
	DLNG( 0x40000000, l[3], 0x90, 0xc2, "Anchor Master Beacon Transmission Time:" );
	g[2] -= 13;
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::ServiceIDListAttribute()
{
	while (g[2] > 0)
	{
		HEX#( 6, 0, 0x90, 0xc2, "Service ID:" );
		g[2] -= 6;
	}
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::ServiceDescriptorAttribute()
{
	HEX#( 6, 0, 0x90, 0xc2, "Service ID:" );
	DBYT( 0, l[2], 0x90, 0xc2, "Instance ID:" );
	DBYT( 0, l[3], 0x90, 0xc2, "Requestor Instance ID:" );
	DBYT( 0, l[4], 0x90, 0xc2, "Service Control:" );
	g[2] -= 9;
	l[5] = l[4];
	l[5] &= 0x40;
	SHFR( 6, l[5] );
	if (l[5] >= 1)
	{
		BWRD( 0x40000000, l[6], 0x90, 0xc2, "Binding Bitmap:" );
		g[2] -= 2;
	}
	l[5] = l[4];
	l[5] &= 0x4;
	SHFR( 2, l[5] );
	if (l[5] >= 1)
	{
		DBYT( 0, l[6], 0x90, 0xc2, "Matching Filter Length:" );
		CHR#( 0, l[6], 0x90, 0xc2, "Matching Filter:" );
		g[2] -= 1;
		g[2] -= l[6];
	}
	l[5] = l[4];
	l[5] &= 0x4;
	SHFR( 3, l[5] );
	if (l[5] >= 1)
	{
		DBYT( 0, l[6], 0x90, 0xc2, "Service Response Length:" );
		CHR#( 0, l[6], 0x90, 0xc2, "Service Response Filter:" );
		g[2] -= 1;
		g[2] -= l[6];
	}
	l[5] = l[4];
	l[5] &= 0x10;
	SHFR( 4, l[5] );
	if (l[5] >= 1)
	{
		DBYT( 0, l[6], 0x90, 0xc2, "Service Info Length:" );
		CHR#( 0, l[6], 0x90, 0xc2, "Service Info:" );
		g[2] -= 1;
		g[2] -= l[6];
	}
	l[5] = l[4];
	l[5] &= 0x7;
	if (l[5] >= 1)
	{
		DGLB( 0, l[5], 0x90, 0xc2, "Service Control Type:" );
			CEQU( 0, l[5], 0, 0x14, "Publish" );
			CEQU( 1, l[5], 0, 0x14, "Subscribe" );
			CEQU( 2, l[5], 0, 0x14, "Follow up" );
			CEQU( 3, l[5], 0, 0x14, "Reserved" );
	}
	if (g[2] != 0)
	{
		HEX#( 0, g[2], 0x90, 0xc2, "Unknown:" ); 
		g[2] -= g[2];
	}
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::NANConnectionCapabilityAttribute()
{
	BWRD( 0x40000000, l[1], 0x90, 0xc2, "Connection Capability Bitmap:" );
		CBIT( 0, l[1], 0x90, 0xc2, "Wi-Fi Direct supported by NAN: true " );
		CLSE( 0, l[1], 0x90, 0xc2, "Wi-Fi Direct supported by NAN: false " );
		CBIT( 1, l[1], 0x90, 0xc2, "P2Ps supported by NAN: true " );
		CLSE( 0, l[1], 0x90, 0xc2, "P2Ps supported by NAN: false " );
		CBIT( 2, l[1], 0x90, 0xc2, "TDLS supported by NAN: true " );
		CLSE( 0, l[1], 0x90, 0xc2, "TDLS supported by NAN: false " );
		CBIT( 3, l[1], 0x90, 0xc2, "WLAN Infrastructure supported by NAN: true " );
		CLSE( 0, l[1], 0x90, 0xc2, "WLAN Infrastructure supported by NAN: false " );
		CBIT( 4, l[1], 0x90, 0xc2, "IBSS supported by NAN: true " );
		CLSE( 0, l[1], 0x90, 0xc2, "IBSS supported by NAN: false " );
		CBIT( 5, l[1], 0x90, 0xc2, "Mesh supported by NAN: true " );
		CLSE( 0, l[1], 0x90, 0xc2, "Mesh supported by NAN: false " );
	g[2] -= 2;
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::WLANInfrastructureAttribute()
{
	ETHR( 0, 0, 0x90, 0xc2, "BSSID:" );
	ETHR( 0, 0, 0x90, 0xc2, "MAC Address:" );
	BBYT( 0, l[1], 0x90, 0xc2, "Map Control:" );
	l[3] = l[1];
	l[3] &= 0x7;
	DGLB( 0, l[3], 0x90, 0xc2, "Map ID:" );
	l[3] = l[1];
	l[3] &= 0x18;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Availability Interval Duration:" );
		CEQU( 0, l[3], 0, 0x14, "16" );
		CEQU( 1, l[3], 0, 0x14, "32" );
		CEQU( 2, l[3], 0, 0x14, "64" );
		CEQU( 3, l[3], 0, 0x14, "reserved" );
	l[3] = l[1];
	l[3] &= 0x20;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Repeat:" );
		CEQU( 0, l[3], 0, 0x14, "applies on to the time interval between the beginnings of two consecutive DWs" );
		CEQU( 1, l[3], 0, 0x14, "signaled availability repeats for future intervals between DWs for 16 intervals" );
	g[2] -= 13;
	g[2] -= 1;
	HEX#( 0, g[2], 0x90, 0xc2, "Availability Intervals Bitmap:" );
	DBYT( 0, l[2], 0x90, 0xc2, "Device Role:" );
		CEQU( 0, l[2], 0, 0x14, "AP" );
		CEQU( 1, l[2], 0, 0x14, "non-AP STA" );
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::P2POperationAttribute()
{	
	BBYT( 0, l[1], 0x90, 0xc2, "P2P Device Role:" );
		CEQU( 0, l[1], 0, 0x14, "P2P Device" );
		CEQU( 1, l[1], 0, 0x14, "P2P Group Owner" );
		CEQU( 2, l[1], 0, 0x14, "P2P Client" );
		CLSE( 0, 0, 0, 0x14, "Reserved" );
	ETHR( 0, 0, 0x90, 0xc2, "MAC Address:" );	
	BBYT( 0, l[2], 0x90, 0xc2, "Map Control:" );
	l[3] = l[2];
	l[3] &= 0x7;
	DGLB( 0, l[3], 0x90, 0xc2, "Map ID:" );
	l[3] = l[1];
	l[3] &= 0x18;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Availability Interval Duration:" );
		CEQU( 0, l[3], 0, 0x14, "16" );
		CEQU( 1, l[3], 0, 0x14, "32" );
		CEQU( 2, l[3], 0, 0x14, "64" );
		CEQU( 3, l[3], 0, 0x14, "reserved" );
	l[3] = l[1];
	l[3] &= 0x20;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Repeat:" );
		CEQU( 0, l[3], 0, 0x14, "applies on to the time interval between the beginnings of two consecutive DWs" );
		CEQU( 1, l[3], 0, 0x14, "signaled availability repeats for future intervals between DWs for 16 intervals" );
	g[2] -= 13;
	g[2] -= 1;
	HEX#( 0, g[2], 0x90, 0xc2, "Availability Intervals Bitmap:" );
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::IBSSAttribute()
{ 
	802_11::IE_Type_221::WiFiAlliance::NAN::Types::WLANInfrastructureAttribute;
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::MeshAttribute()
{
	ETHR( 0, 0, 0x90, 0xc2, "MAC Address:" );	
	BBYT( 0, l[2], 0x90, 0xc2, "Map Control:" );
	l[3] = l[2];
	l[3] &= 0x7;
	DGLB( 0, l[3], 0x90, 0xc2, "Map ID:" );
	l[3] = l[1];
	l[3] &= 0x18;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Availability Interval Duration:" );
		CEQU( 0, l[3], 0, 0x14, "16" );
		CEQU( 1, l[3], 0, 0x14, "32" );
		CEQU( 2, l[3], 0, 0x14, "64" );
		CEQU( 3, l[3], 0, 0x14, "reserved" );
	l[3] = l[1];
	l[3] &= 0x20;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Repeat:" );
		CEQU( 0, l[3], 0, 0x14, "applies on to the time interval between the beginnings of two consecutive DWs" );
		CEQU( 1, l[3], 0, 0x14, "signaled availability repeats for future intervals between DWs for 16 intervals" );
	g[2] -= 7;
	HEX#( 0, g[2], 0x90, 0xc2, "Availability Intervals Bitmap:" );
	g[2] -= g[2];
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::FurtherNANServiceDiscoveryAttribute()
{
	BBYT( 0, l[2], 0x90, 0xc2, "Map Control:" );
	l[3] = l[2];
	l[3] &= 0x7;
	DGLB( 0, l[3], 0x90, 0xc2, "Map ID:" );
	l[3] = l[1];
	l[3] &= 0x18;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Availability Interval Duration:" );
		CEQU( 0, l[3], 0, 0x14, "16" );
		CEQU( 1, l[3], 0, 0x14, "32" );
		CEQU( 2, l[3], 0, 0x14, "64" );
		CEQU( 3, l[3], 0, 0x14, "reserved" );
	l[3] = l[1];
	l[3] &= 0x20;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Repeat:" );
		CEQU( 0, l[3], 0, 0x14, "applies on to the time interval between the beginnings of two consecutive DWs" );
		CEQU( 1, l[3], 0, 0x14, "signaled availability repeats for future intervals between DWs for 16 intervals" );
	g[2] -= 1;
	HEX#( 0, g[2], 0x90, 0xc2, "Availability Intervals Bitmap:" );
	g[2] -= g[2];
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::FurtherAvailabilityMapAttribute()
{
	DBYT( 0, l[2], 0x90, 0xc2, "Map ID:" );
	g[2] -= 1;
	HEX#( 0, g[2], 0x90, 0xc2, "Availability Entry List:" );
	g[2] -= g[2];
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::CountryCodeAttribute()
{
	if (g[2] == 2)
	{
		CHR#( 0, 2, 0x90, 0xc2, "Condensed Country String:" );
	}
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::RangingAttribute()
{
	ETHR( 0, 0, 0x90, 0xc2, "MAC Address:" );
	BBYT( 0, l[2], 0x90, 0xc2, "Map Control:" );
	l[3] = l[2];
	l[3] &= 0x7;
	DGLB( 0, l[3], 0x90, 0xc2, "Map ID:" );
	l[3] = l[1];
	l[3] &= 0x18;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Availability Interval Duration:" );
		CEQU( 0, l[3], 0, 0x14, "16" );
		CEQU( 1, l[3], 0, 0x14, "32" );
		CEQU( 2, l[3], 0, 0x14, "64" );
		CEQU( 3, l[3], 0, 0x14, "reserved" );
	l[3] = l[1];
	l[3] &= 0x20;
	SHFR( 3, l[3] );
	DGLB( 0, l[3], 0x90, 0xc2, "Repeat:" );
		CEQU( 0, l[3], 0, 0x14, "applies on to the time interval between the beginnings of two consecutive DWs" );
		CEQU( 1, l[3], 0, 0x14, "signaled availability repeats for future intervals between DWs for 16 intervals" );
	DBYT( 0, l[4], 0x90, 0xc2, "Ranging Protocol:" );
	g[2] -= 8;
	HEX#( 0, g[2], 0x90, 0xc2, "Availability Intervals Bitmap:" );
	g[2] -= g[2];
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::ClusterDiscoveryAttribute2()
{	
	ETHR( 0, 0, 0x90, 0xc2, "Cluster ID:" );
	D64B( 0, 0, 0x90, 0xc2, "Cluster Time Offset:" );
	D64B( 0, 0, 0x90, 0xc2, "Anchor Master Rank:" );
	g[2] -= 22;
}

void 802_11::IE_Type_221::WiFiAlliance::NAN::Types::VendorSpecificAttribute()
{
	l[2] = pb[0];
	CST# 0 42 90 b7 802_11::IE_Type_221::WiFiAlliance::OuiTypes;
	g[55] = g[2];
	802_11::IE_Type_221::WiFiAlliance::DUMP;
	LABL 0 0 0 b8;
}

void 802_11::IE_Type_221::WiFiAlliance::LOOP()
{
	l[2] = pb[0];
	CST# 0 42 90 b7 802_11::IE_Type_221::WiFiAlliance::OuiTypes;
	DBYT( 0, l[2], 0x90, 0xc2, "Subelement ID:" );
	DWRD( 0, l[3], 0x90, 0xc2, "Length:" );
	g[55] = l[3];
	g[2] -= 3;
	TSB# 0 42 0 0 802_11::IE_Type_221::WiFiAlliance::OuiTypes::LDR;
	XLSE 0 0 0 0 802_11::IE_Type_221::WiFiAlliance::DUMP;
	LABL 0 0 0 b8;
}

void 802_11::IE_Type_221::WiFiAlliance::DUMP()
{
	HEX# 0 37 90 c2 Data:;
	g[2] -= g[55];
}

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Device Information;
{
	BWRD( 0, l[1], 0x90, 0xc9, "WFD Device Information:" );
	l[4] = l[1];
	ANDG( 0x03, l[4]);
	CEQU( 0, l[4], 0, 0xd4, "........ ......00 WFD Device Type: WFD Source" );
	CEQU( 1, l[4], 0, 0xd4, "........ ......01 WFD Device Type: Primary Sink" );
	CEQU( 2, l[4], 0, 0xd4, "........ ......10 WFD Device Type: Secondary Sink" );
	CEQU( 3, l[4], 0, 0xd4, "........ ......11 WFD Device Type: dual-role possible" );
	CBIT( 2, l[1], 0, 0xd4, "........ .....1.. Coupled Sink Operation Support at WFD Source: yes" );
	CLSE( 0, 0, 0, 0xd4, "........ .....0.. Coupled Sink Operation Support at WFD Source: no" );
	CBIT( 3, l[1], 0, 0xd4, "........ ....1... Coupled Sink Operation Support at WFD Sink: yes" );
	CLSE( 0, 0, 0, 0xd4, "........ ....0... Coupled Sink Operation Support at WFD Sink: no" );
	l[4] = l[1];
	ANDG( 0x30, l[4]);
	SHFR( 4, l[4]);
	CEQU( 0, l[4], 0, 0xd4, "........ ..00.... WFD Session Availability: Not available for WFD Session" );
	CEQU( 1, l[4], 0, 0xd4, "........ ..01.... WFD Session Availability: Available for WFD Session" );
	CEQU( 2, l[4], 0, 0xd4, "........ ..10.... WFD Session Availability: Reserved" );
	CEQU( 3, l[4], 0, 0xd4, "........ ..11.... WFD Session Availability: Reserved" );
	CBIT( 6, l[1], 0, 0xd4, "........ .1...... WFD Service Discovery (WSD): Supported " );
	CLSE( 0,    0, 0, 0xd4, "........ .0...... WFD Service Discovery (WSD): Not supported" );
	CBIT( 7, l[1], 0, 0xd4, "........ 1....... Preferred Connectivity (PC): TDLS" );
	CLSE( 0,    0, 0, 0xd4, "........ 0....... Preferred Connectivity (PC): P2P" );
	CBIT( 8, l[1], 0, 0xd4, ".......1 ........ Content Protection using the HDCP system 2.0/2.1: Supported" );
	CLSE( 0,    0, 0, 0xd4, ".......0 ........ Content Protection using the HDCP system 2.0/2.1: Not supported" );
	CBIT( 9, l[1], 0, 0xd4, "......1. ........ Time Synchronization using 802.1AS: Supported" );
	CLSE( 0,    0, 0, 0xd4, "......0. ........ Time Synchronization using 802.1AS: Not supported" );
	CBIT( 0xa, l[1], 0, 0xd4, ".....1.. ........ Audio un-supported: this WFD Device does not support audio rendering when acting as a Primary Sink" );
	CLSE( 0,      0, 0, 0xd4, ".....0.. ........ Audio un-supported: this WFD Device does support audio rendering when acting as a Primary Sink" );
	CBIT( 0xb, l[1], 0, 0xd4, "....1... ........ Audio only support at WFD Source: yes" );
	CLSE( 0, 0, 0, 0xd4, "....0... ........ Audio only support at WFD Source: No support" );
	CBIT( 0xc, l[1], 0, 0xd4, "...1.... ........ TDLS Persistent Group: TDLS persistent group intended" );
	CLSE( 0, 0, 0, 0xd4, "...0.... ........ TDLS Persistent Group: TDLS persistent group not intended" );
	CBIT( 0xd, l[1], 0, 0xd4, "..1..... ........ TDLS Persistent Group Re-invoke: The request is for re-invocation of TDLS persistent group" );
	CLSE( 0, 0, 0, 0xd4, "..0..... ........ TDLS Persistent Group Re-invoke: The request is not for re-invocation of TDLS persistent group" );
	LABL( 0, 0, 0, 0xd4, "xx...... ........ Reserved: Shall be zeros" );
	LABL 0 0 0 b8;
	DWRD( 0, l[2], 0x90, 0xc2, "Session Management Control Port: " );
	DWRD( 0, l[3], 0x90, 0xc2, "WFD Device Maximum Throughput: " );
	LABL( 0, 0, 0, 0x04, " Mbps" );
	g[2] -= 6; g[55] -= 6;
}

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::Associated BSSID()
{
	ETHR( 0, 0, 0x90, 0xc2, "Associated BSSID:" );
	g[2] -= 6; g[55] -= 6;
}

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::Coupled Sink Information()
{
	if (g[55] >= 1)
	{
		BBYT( 0, l[1], 0x90, 0xc9, "Coupled Sink Status bitmap:" );
		l[4] = l[1];
		ANDG( 0x03, l[4]);
		CEQU( 0, l[4], 0, 0xd4, "......00 Coupled Sink Status: Not coupled/Available for Coupling" );
		CEQU( 1, l[4], 0, 0xd4, "......01 Coupled Sink Status: Coupled" );
		CEQU( 2, l[4], 0, 0xd4, "......10 Coupled Sink Status: Teardown Coupling" );
		CEQU( 3, l[4], 0, 0xd4, "......11 Coupled Sink Status: Reserved" );
		LABL( 0, 0, 0, 0xd4, "xxxxxx.. Reserved: Shall be zeros" );
		LABL 0 0 0 b8;
		g[2] -= 1;	g[55] -= 1;
	}
	if (g[55] >= 6)
	{
		ETHR( 0, 0, 0x90, 0xc2, "Coupled Sink MAC Address:" );
		g[2] -= 6;	g[55] -=6;
	}
}

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Video Formats()
{
	BLNG( 0x40000000, l[1], 0x90, 0xc9, "CEA Resolutions/Refresh Rates bitmap:" );
		BST#( 0, l[1], 0, 0xd4, 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Video Formats::CEAR );
	LABL 0 0 0 b8;
	BLNG( 0x40000000, l[2], 0x90, 0xc9, "VESA Resolutions/Refresh Rates bitmap:" );
		BST#( 0, l[1], 0, 0xd4, 802_11::IE_Type_221::WiFiAlliance::OuiTypes::VESA ResolutionsRefresh Rates bitmap );
	LABL 0 0 0 b8;
	BLNG( 0x40000000, l[3], 0x90, 0xc9, "HH Resolutions/Refresh Rates bitmap:" );
		BST#( 0, l[1], 0, 0xd4, 802_11::IE_Type_221::WiFiAlliance::OuiTypes::HH ResolutionsRefresh Rates bitmap );
	LABL 0 0 0 b8;
	BBYT( 0, l[4], 0x90, 0xc9, "Native Resolutions/Refresh Rates bitmap:" );
		l[11] = l[4];
		ANDG( 0x03, l[11]);
		CEQU( 0, l[11], 0, 0xd4, "......00 Table Selection: Index to CEA resolution/refresh rates" );
		CEQU( 1, l[11], 0, 0xd4, "......01 Table Selection: Index VESA resolution/refresh rates" );
		CEQU( 2, l[11], 0, 0xd4, "......10 Table Selection: Index HH resolutions/refresh rates" );
		CEQU( 3, l[11], 0, 0xd4, "......11 Table Selection: Reserved" );
		l[11] = l[4];
		ANDG( 0xfc, l[11]);
		DGLB( 0, l[11], 0x90, 0xc2, "Index:" );
	LABL 0 0 0 b8;
	BBYT( 0, l[5], 0x90, 0xc9, "Profiles bitmap:" );
		CBIT( 0, l[5], 0, 0xd4, "00000001 CBP: supported" );
		CLSE( 0, l[5], 0, 0xd4, "00000000 CBP: not supported" );
		CBIT( 1, l[5], 0, 0xd4, "00000010 CHP: supported" );
		CLSE( 0, l[5], 0, 0xd4, "00000000 CHP: not supported" );
	LABL 0 0 0 b8;
	BBYT( 0, l[6], 0x90, 0xc9, "Levels bitmap:" );
		BST#( 0, l[6], 0, 0xd4, 802_11::IE_Type_221::WiFiAlliance::OuiTypes::Levels bitmap );
	LABL 0 0 0 b8;
	DBYT( 0, l[7], 0x90, 0xc2, "Latency field:" );
	DWRD( 0x40000000, l[8], 0x90, 0xc2, "Minimum slice size field:" );
	BWRD( 0x40000000, l[9], 0x90, 0xc9, "Slice Encoding Parameters bitmap:" );
		l[11] = l[9];
		ANDG( 0x03, l[11]);
		DGLB( 0, l[11], 0x90, 0xc2, "Max Slice Num:" );
		l[11] = l[9];
		ANDG( 0x600, l[11]);
		DGLB( 0, l[11], 0x90, 0xc2, "Max Slice Size Ratio:" );
	LABL 0 0 0 b8;	
	BBYT( 0, l[10], 0x90, 0xc9, "Video  Frame  Rate Control Support bitmap:" );
		CBIT( 0, l[10], 0, 0xd4, "00000001 Video Frame Skipping Support: supported" );
		CLSE( 0, 0, 0, 0xd4, "00000000 Video Frame Skipping Support: not supported" );
		l[11] = l[10];
		ANDG( 0x03, l[11]);
		DGLB( 0, l[11], 0x90, 0xc2, "Max Skip Interval:" );
		CEQU( 0, l[11], 0, 0xd4, "....000. Max Skip Interval: No limitation" );
		CBIT( 0, l[10], 0, 0xd4, "00001000 Dynamic video refresh rate change without user intervention supported" );
		CLSE( 0, 0, 0, 0xd4, "00000000 Dynamic video refresh rate change without user intervention not supported" );
	LABL 0 0 0 b8;
	g[2] -= 21;	g[55] -= 21;
}

str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Video Formats::CEAR;
0	|	00000000 00000000 00000000 00000001 640x480 p60: yes;
	|	00000000 00000000 00000000 00000000 640x480 p60: no;
1	|	00000000 00000000 00000000 00000010 720x480 p60: yes;
	|	00000000 00000000 00000000 00000000 720x480 p60: no;
2 	|	00000000 00000000 00000000 00000100 720x480 i60: yes;
	|	00000000 00000000 00000000 00000000 720x480 i60: no;
3 	|	00000000 00000000 00000000 00001000 720x576 p50: yes;
	|	00000000 00000000 00000000 00000000 720x576 p50: no;
4	|	00000000 00000000 00000000 00010000 720x576 i50: yes;
	|	00000000 00000000 00000000 00000000 720x576 i50: no;
5	|	00000000 00000000 00000000 00100000 1280x720 p30: yes;
	|	00000000 00000000 00000000 00000000 1280x720 p30: no;
6	|	00000000 00000000 00000000 01000000 1280x720 p60: yes;
	|	00000000 00000000 00000000 00000000 1280x720 p60: no;
7	|	00000000 00000000 00000000 10000000 1920x1080 p30: yes;
	|	00000000 00000000 00000000 00000000 1920x1080 p30: no;
8	|	00000000 00000000 00000001 00000000 1920x1080 p60: yes;
	|	00000000 00000000 00000000 00000000 1920x1080 p60: no;
9	|	00000000 00000000 00000010 00000000 1920x1080 i60: yes;
	|	00000000 00000000 00000000 00000000 1920x1080 i60: no;
10	|	00000000 00000000 00000100 00000000 1280x720 p25: yes;
	|	00000000 00000000 00000000 00000000 1280x720 p25: no;
11	|	00000000 00000000 00001000 00000000 1280x720 p50: yes;
	|	00000000 00000000 00000000 00000000 1280x720 p50: no;
12	|	00000000 00000000 00010000 00000000 1920x1080 p25: yes;
	|	00000000 00000000 00000000 00000000 1920x1080 p25: no;
13	|	00000000 00000000 00100000 00000000 1920x1080 p50: yes;
	|	00000000 00000000 00000000 00000000 1920x1080 p50: no;
14	|	00000000 00000000 01000000 00000000 1920x1080 i50: yes;
	|	00000000 00000000 00000000 00000000 1920x1080 i50: no;
15	|	00000000 00000000 10000000 00000000 1280x720 p24: yes;
	|	00000000 00000000 00000000 00000000 1280x720 p24: no;
16	|	00000000 00000001 00000000 00000000 1920x1080 p24: yes;
	|	00000000 00000000 00000000 00000000 1920x1080 p24: no;

str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes::VESA ResolutionsRefresh Rates bitmap;
0	|	00000000 00000000 00000000 00000001  800x600 p30: yes;
	|	00000000 00000000 00000000 00000000  800x600 p30: no;
1	|	00000000 00000000 00000000 00000010  800x600 p60: yes;
	|	00000000 00000000 00000000 00000000  800x600 p60: no;
2	|	00000000 00000000 00000000 00000100  1024x768 p30: yes;
	|	00000000 00000000 00000000 00000000  1024x768 p30: no;
3	|	00000000 00000000 00000000 00001000  1024x768 p60 : yes;
	|	00000000 00000000 00000000 00000000  1024x768 p60 : no;
4	|	00000000 00000000 00000000 00010000  1152x864 p30: yes;
	|	00000000 00000000 00000000 00000000  1152x864 p30: no;
5	|	00000000 00000000 00000000 00100000  1152x864 p60: yes;
	|	00000000 00000000 00000000 00000000  1152x864 p60: no;
6	|	00000000 00000000 00000000 01000000  1280x768 p30: yes;
	|	00000000 00000000 00000000 00000000  1280x768 p30: no;
7	|	00000000 00000000 00000000 10000000  1280x768 p60: yes;
	|	00000000 00000000 00000000 00000000  1280x768 p60: no;
8	|	00000000 00000000 00000001 00000000  1280x800 p30: yes;
	|	00000000 00000000 00000000 00000000  1280x800 p30: no;
9	|	00000000 00000000 00000010 00000000  1280x800 p60: yes;
	|	00000000 00000000 00000000 00000000  1280x800 p60: no;
10	|	00000000 00000000 00000100 00000000  1360x768 p30: yes;
	|	00000000 00000000 00000000 00000000  1360x768 p30: no;
11	|	00000000 00000000 00001000 00000000  1360x768 p60: yes;
	|	00000000 00000000 00000000 00000000  1360x768 p60: no;
12	|	00000000 00000000 00010000 00000000  1366x768 p30: yes;
	|	00000000 00000000 00000000 00000000  1366x768 p30: no;
13	|	00000000 00000000 00100000 00000000  1366x768 p60: yes;
	|	00000000 00000000 00000000 00000000  1366x768 p60: no;
14	|	00000000 00000000 01000000 00000000  1280x1024 p30: yes;
	|	00000000 00000000 00000000 00000000  1280x1024 p30: no;
15	|	00000000 00000000 10000000 00000000  1280x1024 p60: yes;
	|	00000000 00000000 00000000 00000000  1280x1024 p60: no;
16	|	00000000 00000001 00000000 00000000  1400x1050 p30: yes;
	|	00000000 00000000 00000000 00000000  1400x1050 p30: no;
17	|	00000000 00000010 00000000 00000000  1400x1050 p60: yes;
	|	00000000 00000000 00000000 00000000  1400x1050 p60: no;
18	|	00000000 00000100 00000000 00000000  1440x900 p30: yes;
	|	00000000 00000000 00000000 00000000  1440x900 p30: no;
19	|	00000000 00001000 00000000 00000000  1440x900 p60: yes;
	|	00000000 00000000 00000000 00000000  1440x900 p60: no;
20	|	00000000 00010000 00000000 00000000  1600x900 p30: yes;
	|	00000000 00000000 00000000 00000000  1600x900 p30: no;
21	|	00000000 00100000 00000000 00000000  1600x900 p60: yes;
	|	00000000 00000000 00000000 00000000  1600x900 p60: no;
22	|	00000000 01000000 00000000 00000000  1600x1200 p30: yes;
	|	00000000 00000000 00000000 00000000  1600x1200 p30: no;
23	|	00000000 10000000 00000000 00000000  1600x1200 p60: yes;
	|	00000000 00000000 00000000 00000000  1600x1200 p60: no;
24	|	00000001 00000000 00000000 00000000  1680x1024 p30: yes;
	|	00000000 00000000 00000000 00000000  1680x1024 p30: no;
25	|	00000010 00000000 00000000 00000000  1680x1024 p60: yes;
	|	00000000 00000000 00000000 00000000  1680x1024 p60: no;
26	|	00000100 00000000 00000000 00000000  1680x1050 p30: yes;
	|	00000000 00000000 00000000 00000000  1680x1050 p30: no;
27	|	00001000 00000000 00000000 00000000  1680x1050 p60: yes;
	|	00000000 00000000 00000000 00000000  1680x1050 p60: no;
28	|	00010000 00000000 00000000 00000000  1920x1200 p30: yes;
	|	00000000 00000000 00000000 00000000  1920x1200 p30: no;
29	|	00100000 00000000 00000000 00000000  1920x1200 p60: yes;
	|	00000000 00000000 00000000 00000000  1920x1200 p60: no;

str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes::HH ResolutionsRefresh Rates bitmap;
0	|	00000000 00000000 00000000 00000001  800x480 p30: yes;
	|	00000000 00000000 00000000 00000000  800x480 p30: no;
1	|	00000000 00000000 00000000 00000010  800x480 p60: yes;
	|	00000000 00000000 00000000 00000000  800x480 p60: no;
2	|	00000000 00000000 00000000 00000100  854x480 p30: yes;
	|	00000000 00000000 00000000 00000000  854x480 p30: no;
3	|	00000000 00000000 00000000 00001000  854x480 p60: yes;
	|	00000000 00000000 00000000 00000000  854x480 p60: no;
4	|	00000000 00000000 00000000 00010000  864x480 p30: yes;
	|	00000000 00000000 00000000 00000000  864x480 p30: no;
5	|	00000000 00000000 00000000 00100000  864x480 p60: yes;
	|	00000000 00000000 00000000 00000000  864x480 p60: no;
6	|	00000000 00000000 00000000 01000000  640x360 p30: yes;
	|	00000000 00000000 00000000 00000000  640x360 p30: no;
7	|	00000000 00000000 00000000 10000000  640x360 p60: yes;
	|	00000000 00000000 00000000 00000000  640x360 p60: no;
8	|	00000000 00000000 00000001 00000000  960x540 p30: yes;
	|	00000000 00000000 00000000 00000000  960x540 p30: no;
9	|	00000000 00000000 00000010 00000000  960x540 p60: yes;
	|	00000000 00000000 00000000 00000000  960x540 p60: no;
10	|	00000000 00000000 00000100 00000000  848x480 p30: yes;
	|	00000000 00000000 00000000 00000000  848x480 p30: no;
11	|	00000000 00000000 00001000 00000000  848x480 p60: yes;
	|	00000000 00000000 00000000 00000000  848x480 p60: no;

str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes::Levels bitmap;
0	|	00000001  H.264 Level 3.1 bit : supported;
	|	00000000  H.264 Level 3.1 bit : not supported;
1	|	00000010  H.264 Level 3.2 bit : supported;
	|	00000000  H.264 Level 3.2 bit : not supported;
2	|	00000100  H.264 Level 4 bit : supported;
	|	00000000  H.264 Level 4 bit : not supported;
3	|	00001000  H.264 Level 4.1 bit : supported;
	|	00000000  H.264 Level 4.1 bit : not supported;
4	|	00010000  H.264 Level 4.2 bit : supported;
	|	00000000  H.264 Level 4.2 bit : not supported;
5	|	00100000  Reserved: supported;
	|	00000000  Reserved: not supported;
6	|	01000000  Reserved: supported;
	|	00000000  Reserved: not supported;
7	|	10000000  Reserved: supported;
	|	00000000  Reserved: not supported;

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD 3D Video Formats()
{
	D64B( 0x40000000, l[1], 0x90, 0xc9, "3D Video Capability bitmap:" );
		BST#( 0, l[1], 0, 0xd4, 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD 3D Video Formats::3D Video Capability bitmap );
	LABL 0 0 0 b8;	
	BBYT( 0, l[4], 0x90, 0xc9, "Native Resolutions/Refresh Rates bitmap:" );
		l[11] = l[4];
		ANDG( 0x03, l[11]);
		CEQU( 0, l[11], 0, 0xd4, "......00 Table Selection: Index to CEA resolution/refresh rates" );
		CEQU( 1, l[11], 0, 0xd4, "......01 Table Selection: Index VESA resolution/refresh rates" );
		CEQU( 2, l[11], 0, 0xd4, "......10 Table Selection: Index HH resolutions/refresh rates" );
		CEQU( 3, l[11], 0, 0xd4, "......11 Table Selection: Reserved" );
		l[11] = l[4];
		ANDG( 0xfc, l[11]);
		DGLB( 0, l[11], 0x90, 0xc2, "Index:" );
	LABL 0 0 0 b8;
	BBYT( 0, l[5], 0x90, 0xc9, "Profiles bitmap:" );
		CBIT( 0, l[5], 0, 0xd4, "00000001 CBP: supported" );
		CLSE( 0, l[5], 0, 0xd4, "00000000 CBP: not supported" );
		CBIT( 1, l[5], 0, 0xd4, "00000010 CHP: supported" );
		CLSE( 0, l[5], 0, 0xd4, "00000000 CHP: not supported" );
	LABL 0 0 0 b8;
	BBYT( 0, l[6], 0x90, 0xc9, "Levels bitmap:" );
		BST#( 0, l[6], 0, 0xd4, 802_11::IE_Type_221::WiFiAlliance::OuiTypes::Levels bitmap );
	LABL 0 0 0 b8;
	DBYT( 0, l[7], 0x90, 0xc2, "Latency field:" );
	DWRD( 0x40000000, l[8], 0x90, 0xc2, "Minimum slice size field:" );
	BWRD( 0x40000000, l[9], 0x90, 0xc9, "Slice Encoding Parameters bitmap:" );
		l[11] = l[9];
		ANDG( 0x03, l[11]);
		DGLB( 0, l[11], 0x90, 0xc2, "Max Slice Num:" );
		l[11] = l[9];
		ANDG( 0x600, l[11]);
		DGLB( 0, l[11], 0x90, 0xc2, "Max Slice Size Ratio:" );
	LABL 0 0 0 b8;
	BBYT( 0, l[10], 0x90, 0xc9, "Video Frame Rate Control Support bitmap:" );
		CBIT( 0, l[10], 0, 0xd4, "00000001 Video Frame Skipping Support: supported" );
		CLSE( 0, 0, 0, 0xd4, "00000000 Video Frame Skipping Support: not supported" );
		l[11] = l[10];
		ANDG( 0x03, l[11]);
		DGLB( 0, l[11], 0x90, 0xc2, "Max Skip Interval:" );
		CEQU( 0, l[11], 0, 0xd4, "....000. Max Skip Interval: No limitation" );
		CBIT( 0, l[10], 0, 0xd4, "00001000 Dynamic video refresh rate change without user intervention supported" );
		CLSE( 0, 0, 0, 0xd4, "00000000 Dynamic video refresh rate change without user intervention not supported" );
	LABL 0 0 0 b8;
	g[2] -= 17;	g[55] -= 17;
}

str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD 3D Video Formats::3D Video Capability bitmap;
0	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001  1920x(540+540) p24, Top & Bottom[Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x(540+540) p24, Top & Bottom[Half]: no;
1	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000010  1280x(360+360) p60, Top & Bottom[Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(360+360) p60, Top & Bottom[Half]: no;
2	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000100  1280x(360+360) p50, Top & Bottom[Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(360+360) p50, Top & Bottom[Half]: no;
3	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00001000  1920x1080 (p24L+p24R), Frame Sequential: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x1080 (p24L+p24R), Frame Sequential: no;
4	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00010000  1280x720 (p60L+p60R), Frame Sequential: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x720 (p60L+p60R), Frame Sequential: no;
5	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00100000  1280x720 (p30L+p30R), Frame Sequential: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x720 (p30L+p30R), Frame Sequential: no;
6	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 01000000  1280x720 (p50L+p50R), Frame Sequential: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x720 (p50L+p50R), Frame Sequential: no;
7	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 10000000  1280x720 (p25L+p25R), Frame Sequential: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x720 (p25L+p25R), Frame Sequential: no;
8	|	00000000 00000000 00000000 00000000 00000000 00000000 00000001 00000000  1920x(1080+45+1080) p24, Frame Packing : yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x(1080+45+1080) p24, Frame Packing : no;
9	|	00000000 00000000 00000000 00000000 00000000 00000000 00000010 00000000  1280x(720+30+720) p60, Frame Packing: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(720+30+720) p60, Frame Packing: no;
10	|	00000000 00000000 00000000 00000000 00000000 00000000 00000100 00000000  1280x(720+30+720) p30, Frame Packing: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(720+30+720) p30, Frame Packing: no;
11	|	00000000 00000000 00000000 00000000 00000000 00000000 00001000 00000000  1280x(720+30+720) p50, Frame Packing: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(720+30+720) p50, Frame Packing: no;
12	|	00000000 00000000 00000000 00000000 00000000 00000000 00010000 00000000  1280x(720+30+720) p25, Frame Packing: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(720+30+720) p25, Frame Packing: no;
13	|	00000000 00000000 00000000 00000000 00000000 00000000 00100000 00000000  (960+960)x1080 i60, Side by Side[Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (960+960)x1080 i60, Side by Side[Half]: no;
14	|	00000000 00000000 00000000 00000000 00000000 00000000 01000000 00000000  (960+960)x1080 i50, Side by Side[Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (960+960)x1080 i50, Side by Side[Half]: no;
15	|	00000000 00000000 00000000 00000000 00000000 00000000 10000000 00000000  640x(240 + 240) p60, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  640x(240 + 240) p60, Top & Bottom [Half]: no;
16	|	00000000 00000000 00000000 00000000 00000000 00000001 00000000 00000000  (320+320)x480 p60, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (320+320)x480 p60, Side by Side [Half]: no;
17	|	00000000 00000000 00000000 00000000 00000000 00000010 00000000 00000000  720x(240+240) p60, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  720x(240+240) p60, Top & Bottom [Half]: no;
18	|	00000000 00000000 00000000 00000000 00000000 00000100 00000000 00000000  (360+360)x480 p60, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (360+360)x480 p60, Side by Side [Half]: no;
19	|	00000000 00000000 00000000 00000000 00000000 00001000 00000000 00000000  720x(288+288) p50, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  720x(288+288) p50, Top & Bottom [Half]: no;
20	|	00000000 00000000 00000000 00000000 00000000 00010000 00000000 00000000   (360+360)x576 p50, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (360+360)x576 p50, Side by Side [Half]: no;
21	|	00000000 00000000 00000000 00000000 00000000 00100000 00000000 00000000  1280x(360+360) p24, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(360+360) p24, Top & Bottom [Half]: no;
22	|	00000000 00000000 00000000 00000000 00000000 01000000 00000000 00000000  (640+640)x720 p24, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (640+640)x720 p24, Side by Side [Half]: no;
23	|	00000000 00000000 00000000 00000000 00000000 10000000 00000000 00000000  1280x(360+360) p25, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(360+360) p25, Top & Bottom [Half]: no;
24	|	00000000 00000000 00000000 00000000 00000001 00000000 00000000 00000000  (640+640)x720 p25, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (640+640)x720 p25, Side by Side [Half]: no;
25	|	00000000 00000000 00000000 00000000 00000010 00000000 00000000 00000000  1280x(360+360) p30, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1280x(360+360) p30, Top & Bottom [Half]: no;
26	|	00000000 00000000 00000000 00000000 00000100 00000000 00000000 00000000  (640+640)x720 p30, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (640+640)x720 p30, Side by Side [Half]: no;
27	|	00000000 00000000 00000000 00000000 00001000 00000000 00000000 00000000  1920x(540+540) p30, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x(540+540) p30, Top & Bottom [Half]: no;
28	|	00000000 00000000 00000000 00000000 00010000 00000000 00000000 00000000  1920x(540+540) p50, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x(540+540) p50, Top & Bottom [Half]: no;
29	|	00000000 00000000 00000000 00000000 00100000 00000000 00000000 00000000  1920x(540+540) p60, Top & Bottom [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x(540+540) p60, Top & Bottom [Half]: no;
30	|	00000000 00000000 00000000 00000000 01000000 00000000 00000000 00000000  (640+640)x720 p50, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (640+640)x720 p50, Side by Side [Half]: no;
31	|	00000000 00000000 00000000 00000000 10000000 00000000 00000000 00000000  (640+640)x720 p60, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (640+640)x720 p60, Side by Side [Half]: no;
32	|	00000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000  (960+960)x1080 p24, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (960+960)x1080 p24, Side by Side [Half]: no;
33	|	00000000 00000000 00000000 00000010 00000000 00000000 00000000 00000000  (960+960)x1080 p50, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (960+960)x1080 p50, Side by Side [Half]: no;
34	|	00000000 00000000 00000000 00000100 00000000 00000000 00000000 00000000  (960+960)x1080 p60, Side by Side [Half]: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  (960+960)x1080 p60, Side by Side [Half]: no;
35	|	00000000 00000000 00000000 00001000 00000000 00000000 00000000 00000000  1920x(1080+45+1080) p30, Frame Packing: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x(1080+45+1080) p30, Frame Packing: no;
36	|	00000000 00000000 00000000 00010000 00000000 00000000 00000000 00000000  1920x(1080+45+1080) i50, Frame Packing: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x(1080+45+1080) i50, Frame Packing: no;
37	|	00000000 00000000 00000000 00100000 00000000 00000000 00000000 00000000  1920x(1080+45+1080) i60, Frame Packing: yes;
	|	00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000  1920x(1080+45+1080) i60, Frame Packing: no;

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Audio Formats()
{
	BLNG( 0x40000000, l[1], 0x90, 0xc9, "LPCM Modes bitmap:" );
		CBIT( 0, l[1], 0, 0xd4, "00000000 00000000 00000000 00000001 Sampling Frequency: 44.1 kHz, Bit-width: 16 bits, channels: 2" );
		CBIT( 1, l[1], 0, 0xd4, "00000000 00000000 00000000 00000010 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 2" );
	LABL 0 0 0 b8;
	DBYT( 0, l[2], 0x90, 0xc2, "LPCM decoder latency:" );
	BLNG( 0x40000000, l[1], 0x90, 0xc9, "AAC Modes bitmap:" );
		CBIT( 0, l[1], 0, 0xd4, "00000000 00000000 00000000 00000001 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 2, Codec Option: AAC-LC" );
		CBIT( 1, l[1], 0, 0xd4, "00000000 00000000 00000000 00000010 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 4, Codec Option: AAC-LC" );
		CBIT( 2, l[1], 0, 0xd4, "00000000 00000000 00000000 00000100 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 6, Codec Option: AAC-LC" );
		CBIT( 3, l[1], 0, 0xd4, "00000000 00000000 00000000 00001000 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 8, Codec Option: AAC-LC" );
	LABL 0 0 0 b8;
	DBYT( 0, l[2], 0x90, 0xc2, "AAC decoder latency:" );
	BLNG( 0x40000000, l[1], 0x90, 0xc9, "AC3 Modes bitmap:" );
		CBIT( 0, l[1], 0, 0xd4, "00000000 00000000 00000000 00000001 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 2, Codec Option: AC-3" );
		//does not work: CBIT( 0, l[1], 0, 0xd4, "00000000 00000000 00000000 00000001 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 2, Codec Option: Dolby Digital (AC-3)" );
		CBIT( 1, l[1], 0, 0xd4, "00000000 00000000 00000000 00000010 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 4, Codec Option: AC-3" );
		CBIT( 2, l[1], 0, 0xd4, "00000000 00000000 00000000 00000100 Sampling Frequency: 48 kHz, Bit-width: 16 bits, channels: 6, Codec Option: AC-3" );
	LABL 0 0 0 b8;
	DBYT( 0, l[2], 0x90, 0xc2, "AC3 decoder latency:" );
	g[2] -= 15;	g[55] -= 15;
}

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Content Protection()
{
	DBYT( 0, l[2], 0x90, 0xc9, "Content Protection bitmap:" );
		CBIT( 0, l[1], 0, 0xd4, "00000000 00000000 00000000 00000001 HDCP system 2.0: suppported" );
		CLSE( 0, l[1], 0, 0xd4, "00000000 00000000 00000000 00000000 HDCP system 2.0: not suppported" );
		CBIT( 1, l[1], 0, 0xd4, "00000000 00000000 00000000 00000010 HDCP system 2.1: suppported" );
		CLSE( 0, l[1], 0, 0xd4, "00000000 00000000 00000000 00000000 HDCP system 2.0: not suppported" );
	LABL 0 0 0 b8;
	g[2] -= 15;	g[55] -= 1;
}

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::Local IP Address()
{
	IPLG( 0, 0, 0x90, 0xc2, "IPv4 address:" );
	g[2] -= 4;	g[55] -= 4;
}

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::Alternative MAC Address()
{
	ETHR( 0, 0, 0x90, 0xc2, "Alternative MAC address:" );
	g[2] -= 6;	g[55] -= 6;
}

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Extended Capability()
{
	DWRD( 0x40000000, 0, 0x90, 0xc9, "WFD Extended capabilities:" );
		BST#( 0, l[1], 0, 0xd4, 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Extended capabilitiesstr );
	LABL 0 0 0 b8;
	g[2] -= 2;	g[55] -= 2;
}

str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Extended capabilitiesstr;
0	|	00000000 00000001  UIBC: supported;
	|	00000000 00000000  UIBC: not supported;
1	|	00000000 00000010  I2C Read/Write: supported;
	|	00000000 00000000  I2C Read/Write: not supported;
2	|	00000000 00000100  Preferred Display mode: supported;
	|	00000000 00000000  Preferred Display mode: not supported;
3	|	00000000 00001000  Standby and Resume Control: supported;
	|	00000000 00000000  Standby and Resume Control: not supported;
4	|	00000000 00010000  TDLS Persistent: supported;
	|	00000000 00000000  TDLS Persistent: not supported;
5	|	00000000 00100000  TDLS Persistent BSSID: supported;
	|	00000000 00000000  TDLS Persistent BSSID: not supported;

void 802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Session Information()
{
	l[1] = 1;
	while (g[55] != 0)
	{
		ETHR( 0, 0, 0x90, 0xc2, "Device address:" );
		ETHR( 0, 0, 0x90, 0xc2, "Associated BSSID:" );
		DWRD( 0x40000000, 0, 0x90, 0xc9, "WFD  Device Information:" );
		DWRD( 0x40000000, 0, 0x90, 0xc9, "Maximum Throughput:" );
		g[56] = g[55];
		g[55] = 7;
		802_11::IE_Type_221::WiFiAlliance::OuiTypes::Coupled Sink Information;
		g[55] = g[56];
		g[2] -= 17;	g[55] -= 17;
	}
}


str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes2;
0x09	| 	WFA P2P v1.0;
0x0a	| 	WFA WFD v1.0;
0x10	| 	Hotspot 2.0 Indication;
0x13	| 	Neighbor Awareness Networking;

str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes::LDR;
0	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Device Information;
1	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::Associated BSSID;
2	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Audio Formats;
3	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Video Formats;
4	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD 3D Video Formats;
5	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Content Protection;
6	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::Coupled Sink Information;
7	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Extended Capability;
8	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::Local IP Address;
9	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::WFD Session Information;
10	|	802_11::IE_Type_221::WiFiAlliance::OuiTypes::Alternative MAC Address;

str# 802_11::IE_Type_221::WiFiAlliance::OuiTypes;
0	|	WFD Device Information;
1	|	Associated BSSID;
2	|	WFD Audio Formats;
3	|	WFD Video Formats;
4	|	WFD 3D Video Formats;
5	|	WFD Content Protection;
6	|	Coupled Sink Information;
7	|	WFD Extended Capability;
8	|	Local IP Address;
9	|	WFD Session Information;
10	|	Alternative MAC Address;

* SamChen
//------------------------------------------------------
void 802_11::IE_Aruba;
	802_11::Print_OUI();
	* SamChen:  worked..
	* DBYT 0 0 90 c2 Sam 1:;
	* DBYT 0 0 90 c2 Sam 2:;
	* DECR 2;
	* LABL( 0, 0, 0x90, 0xc2, "### Sam 1: " );
	* DGLB( 0, l[1], 0x02, 0 );

	l[1] = 0;
	l[2] = 0;
	l[3] = g[2];
	l[3] -= 3;

	* SamChen:  Look ahead 2 bytes
	GBYT( 0, l[1] );
	GBYT( 1, l[2] );

	if (l[1] == 65)      * SamChen:  Is this 'A'?
	{
		if (l[2] == 80)  * SamChen:  Is this 'P'?
		{
			CHR#( 0, l[3], 0x90, 0xc2, "AP Name:" );
			TRTS;
		}
	}
	
	HEX#( 0, l[3], 0x90, 0xc2, "Value:" );

	TRTS;
//------------------------------------------------------


//-------------------------------------------------
str# 802_11::Access_Network_Options;
0x00	|	Private network;
0x01	|	Private network with guest access;
0x02	|	Chargable public network;
0x03	|	Free public network;
0x04	|	Personal device network;
0x05	|	Emergency services only network;
0x0E	|	Test or experimental;
0x0F	|	Wildcard;

//------------------------------------------------------
// Type 198
void 802_11::Quiet_Channel()
{
	DBYT( 0, 0, 0x90, 0xc9, "AP Quiet Mode:" );	
	g[2] -= 1;
	if (g[2] > 0)
	{
		DBYT( 0, 0, 0x90, 0xc2, "Quiet Count:" );
		g[2] -= 1;
	}
	if (g[2] > 0)
	{
		DBYT( 0, 0, 0x90, 0xc2, "Quiet Period:" );
		g[2] -= 1;
	}
	if (g[2] >= 2)
	{
		DBYT( 0, 0, 0x90, 0xc2, "Quiet Duration:" );
		g[2] -= 2;
	}
	if (g[2] >= 2)
	{
		DBYT( 0, 0, 0x90, 0xc2, "Quiet Offset:" );
		g[2] -= 2;
	}
	LABL( 0, 0, 0, 0xb8 );
}

//----------------------------------------------------
// Type 199
void 802_11::Operation_Mode_Notification()
{
	BBYT( 0, l[1], 0x90, 0xc2, "Operating Mode:" );
	l[2] = l[1]; l[3] = l[1]; l[4] = l[1];
	l[2] &= 0x80;
	SHFR 6 42;
	l[3] &= 0x70;
	SHFR 4 43;
	l[4] &= 0x3;	
	CEQU( 0, l[4], 0, 0xd4, ".... ..00 Channel Width: 20 MHz");
	CEQU( 1, l[4], 0, 0xd4, ".... ..01 Channel Width: 40 MHz");
	CEQU( 2, l[4], 0, 0xd4, ".... ..10 Channel Width: 80 MHz");
	CEQU( 3, l[4], 0, 0xd4, ".... ..11 Channel Width:: 160 MHz");
	LABL( 0, 0, 0, 0xd4, ".... xx.. Reserved");
	CEQU( 0, l[3], 0, 0xd4, ".000 .... Rx NSS: 1");
	CEQU( 1, l[3], 0, 0xd4, ".001 .... Rx NSS: 2");
	CEQU( 2, l[3], 0, 0xd4, ".010 .... Rx NSS: 3");
	CEQU( 3, l[3], 0, 0xd4, ".011 .... Rx NSS: 4");
	CEQU( 4, l[3], 0, 0xd4, ".100 .... Rx NSS: 5");
	CEQU( 5, l[3], 0, 0xd4, ".101 .... Rx NSS: 6");
	CEQU( 6, l[3], 0, 0xd4, ".110 .... Rx NSS: 7");
	CEQU( 7, l[3], 0, 0xd4, ".111 .... Rx NSS: 8");
	CEQU( 0, l[2], 0, 0xd4, "0... .... Rx NSS Type: Rx NSS carries the maximum number of spatial stream that the STA can receive");
	CEQU( 1, l[2], 0, 0xd4, "1... .... Rx NSS Type: Rx NSS carries the maximum number of spatial stream that the STA can receive as an SU PPDU");	
	g[2] -= 1;
}


//---------------------

void 802_11::AID()
{
	BWRD( 0x40000000, 0, 0x90, 0xc2, " AID:" );
	//LABL( 0, 0, 0, 0xb8 );
	g[2] -= 2;
}

void 802_11::Control_Switch_Wrapper()
{
	HEX#( 0, g[2], 0x90, 0xc2, "Control Switch Wrapper:" );	
	//LABL( 0, 0, 0, 0xb8 );
	g[2] -= g[2];
}

void 802_11::VHT_Transmit_Power_Envelope()
{
	HBYT( 0, l[1], 0x90, 0xc9, "Transmit Power Information:" );
		l[21] = l[1];
		l[21] &= 0xc0;
		SHFR( 6, l[21] );
		LABL( 0, , 0x0, 0xd4, "xx.. .... Reserved" );
		l[22] = l[1];
		l[22] &= 0x38;
		SHFR( 3, l[22] );	
		CEQU( 0, l[22], 0, 0xd4, "..00 0... Local Maximum Transmit Power Units Interpretation: EIRP");
		CEQU( 1, l[22], 0, 0xd4, "..00 1... Local Maximum Transmit Power Units Interpretation: Reserved");
		CEQU( 2, l[22], 0, 0xd4, "..01 0... Local Maximum Transmit Power Units Interpretation: Reserved");
		CEQU( 3, l[22], 0, 0xd4, "..01 1... Local Maximum Transmit Power Units Interpretation: Reserved");
		CEQU( 4, l[22], 0, 0xd4, "..10 0... Local Maximum Transmit Power Units Interpretation: Reserved");
		CEQU( 5, l[22], 0, 0xd4, "..10 1... Local Maximum Transmit Power Units Interpretation: Reserved");
		CEQU( 6, l[22], 0, 0xd4, "..11 0... Local Maximum Transmit Power Units Interpretation: Reserved");
		CEQU( 7, l[22], 0, 0xd4, "..11 1... Local Maximum Transmit Power Units Interpretation: Reserved");
		l[23] = l[1];
		l[23] &= 0x07;
		CEQU( 0, l[23], 0, 0xd4, ".... .000 Local Maximum Transmit Power for: 20 MHz");
		CEQU( 1, l[23], 0, 0xd4, ".... .001 Local Maximum Transmit Power for: 20 MHz / 40 MHz");
		CEQU( 2, l[23], 0, 0xd4, ".... .010 Local Maximum Transmit Power for: 20 MHz / 40 MHz / 80 MHz");
		CEQU( 3, l[23], 0, 0xd4, ".... .011 Local Maximum Transmit Power for: 20 MHz / 40 MHz / 80 MHz/ 160 MHz");
		CEQU( 4, l[23], 0, 0xd4, ".... .100 Local Maximum Transmit Power for: Reserved");
		CEQU( 5, l[23], 0, 0xd4, ".... .101 Local Maximum Transmit Power for: Reserved");
		CEQU( 6, l[23], 0, 0xd4, ".... .110 Local Maximum Transmit Power for: Reserved");
		CEQU( 7, l[23], 0, 0xd4, ".... .111 Local Maximum Transmit Power for: Reserved");
		g[2] -= 1;
	LABL( 0, 0, 0, 0xb8 );	
	if (g[2] >= 1)
	{
		DBYT( 0, l[3], 0x90, 0xc2, "Local Maximum Transmit Power For 20 MHz:" );
		g[2] -= 1;
		// SamChen
		l[5] = l[3];
		ANDG 80 43;
		SHFR 7 43;
		ANDG 7f 45;

		if (l[3] == 1)
		{
			l[5] -= 128;
			NOTG(0, l[5]);
			l[5] += 1;
			LABL 0 0 0 14 Max limit -;
		}

		if (l[3] != 1)
		{
			LABL 0 0 0 14 Max limit ;
		}

		l[3] = l[5];
		l[5] /= 2;
		MODG 2 43;
		DGLB( 0x80000000, l[5], 0x04, 0, );

		if (l[3] == 1)
		{
			LABL( 0, 0, 0, 0x04, ".5 dBm" );
		}

		if (l[3] != 1)
		{
			LABL( 0, 0, 0, 0x04, " dBm" );
		}
	}
	if (g[2] >= 1)
	{
		DBYT( 0, l[3], 0x90, 0xc2, "Local Maximum Transmit Power For 40 MHz:" );
		g[2] -= 1;
		// SamChen
		l[5] = l[3];
		ANDG 80 43;
		SHFR 7 43;
		ANDG 7f 45;

		if (l[3] == 1)
		{
			l[5] -= 128;
			NOTG(0, l[5]);
			l[5] += 1;
			LABL 0 0 0 14 Max limit -;
		}

		if (l[3] != 1)
		{
			LABL 0 0 0 14 Max limit ;
		}

		l[3] = l[5];
		l[5] /= 2;
		MODG 2 43;
		DGLB( 0x80000000, l[5], 0x04, 0, );

		if (l[3] == 1)
		{
			LABL( 0, 0, 0, 0x04, ".5 dBm" );
		}

		if (l[3] != 1)
		{
			LABL( 0, 0, 0, 0x04, " dBm" );
		}
	}

	if (g[2] >= 1)
	{
		DBYT( 0, l[3], 0x90, 0xc2, "Local Maximum Transmit Power For 80 MHz:" );
		g[2] -= 1;
		// SamChen
		l[5] = l[3];
		ANDG 80 43;
		SHFR 7 43;
		ANDG 7f 45;

		if (l[3] == 1)
		{
			l[5] -= 128;
			NOTG(0, l[5]);
			l[5] += 1;
			LABL 0 0 0 14 Max limit -;
		}

		if (l[3] != 1)
		{
			LABL 0 0 0 14 Max limit ;
		}

		l[3] = l[5];
		l[5] /= 2;
		MODG 2 43;
		DGLB( 0x80000000, l[5], 0x04, 0, );

		if (l[3] == 1)
		{
			LABL( 0, 0, 0, 0x04, ".5 dBm" );
		}

		if (l[3] != 1)
		{
			LABL( 0, 0, 0, 0x04, " dBm" );
		}
	}
	if (g[2] >= 1)
	{
		DBYT( 0, l[4], 0x90, 0xc2, "Local Maximum Transmit Power For 160/80+80 MHz:" );
		g[2] -= 1;
		// SamChen
		l[5] = l[4];
		ANDG 80 44;
		SHFR 7 44;
		ANDG 7f 45;

		if (l[4] == 1)
		{
			l[5] -= 128;
			NOTG(0, l[5]);
			l[5] += 1;
			LABL 0 0 0 14 Max limit -;
		}

		if (l[4] != 1)
		{
			LABL 0 0 0 14 Max limit ;
		}

		l[4] = l[5];
		l[5] /= 2;
		MODG 2 44;
		DGLB( 0x80000000, l[5], 0x04, 0, );

		if (l[4] == 1)
		{
			LABL( 0, 0, 0, 0x04, ".5 dBm" );
		}

		if (l[4] != 1)
		{
			LABL( 0, 0, 0, 0x04, " dBm" );
		}
	}
	//LABL( 0, 0, 0, 0xb8 );	
}


void 802_11::Wide_Bandwidth_Channel_Switch()
{
	HEX#( 0, 0x03, 0x90, 0xc9, "Wide Bandwidth Channel Switch:" );
	DECR 3;
	HBYT( 0x40000000, l[1], 0x90, 0xc2, "New Channel Width:" );
	HBYT( 0x40000000, l[2], 0x90, 0xc2, "New Channel Center Frequency Segment 0:" );
	HBYT( 0x40000000, l[3], 0x90, 0xc2, "New Channel Center Frequency Segment 1:" );
	LABL( 0, 0, 0, 0xb8 );
	g[2] -= 3;
}

void 802_11::Extended_BSS_Load()
{
	HEX#( 0, 0x06, 0x90, 0xc9, "Extended BSS Load:" );
	DECR 6;
	DWRD( 0x40000000, l[1], 0x90, 0xc2, "MU-MIMO Capable STA Count:" );
	DBYT( 0x40000000, l[2], 0x90, 0xc2, "Spatial Stream Underutilization:" );
	DBYT( 0x40000000, l[3], 0x90, 0xc2, "VHT 40 MHz Utilization:" );
	DBYT( 0x40000000, l[4], 0x90, 0xc2, "80 MHz Utilization:" );
	DBYT( 0x40000000, l[5], 0x90, 0xc2, "160 MHz Utilization:" );
	LABL( 0, 0, 0, 0xb8 );
	g[2] -= 6;
}

void 802_11::VHT_Operations()
{
	
	LABL( 0, 0, 0x90, 0xc9, "VHT Operation Information:" );
	
	DBYT( 0x40000000, l[1], 0x90, 0xc2, "Channel Width:" );
		CEQU( 0, l[1], 0x0, 0x14, "20 MHz or 40 MHz" );
		CEQU( 1, l[1], 0x0, 0x14, "80 MHz" );
		CEQU( 2, l[1], 0x0, 0x14, "160 MHz" );
		CEQU( 3, l[1], 0x0, 0x14, "80+80 MHz" );
	DBYT( 0x40000000, l[2], 0x90, 0xc2, "Center Frequency Channel for 80 and 160 MHz operation: ");
	LABL( 0, 0, 0, 0x14, "MHz" );
	DBYT( 0x40000000, l[3], 0x90, 0xc2, "Center Frequency Channel for 80+80 MHz operation: ");
	LABL( 0, 0, 0, 0x14, "MHz" );
	BWRD( 0x40000000, l[4], 0x90, 0xc9, "VHT Basic MCS Set:" );
		l[5] = l[4];
		ANDG C000 44;
		SHFR e 44;
			CEQU( 0, l[4], 0, 0xd4, "00...... ........ Max MCS for 1 SS: support for MCS 0-7");
			CEQU( 1, l[4], 0, 0xd4, "01...... ........ Max MCS for 1 SS: support for MCS 0-8");
			CEQU( 2, l[4], 0, 0xd4, "10...... ........ Max MCS for 1 SS: support for MCS 0-9");
			CEQU( 3, l[4], 0, 0xd4, "11...... ........ Max MCS for 1 SS: support for n Spatial Streams");
		l[4] = l[5];
		ANDG 3000 44;
		SHFR c 44;
			CEQU( 0, l[4], 0, 0xd4, "..00.... ........ Max MCS for 2 SS: support for MCS 0-7");
			CEQU( 1, l[4], 0, 0xd4, "..01.... ........ Max MCS for 2 SS: support for MCS 0-8");
			CEQU( 2, l[4], 0, 0xd4, "..10.... ........ Max MCS for 2 SS: support for MCS 0-9");
			CEQU( 3, l[4], 0, 0xd4, "..11.... ........ Max MCS for 2 SS: support for n Spatial Streams");
		l[4] = l[5];
		ANDG c00 44;
		SHFR b 44;
			CEQU( 0, l[4], 0, 0xd4, "....00.. ........ Max MCS for 3 SS: support for MCS 0-7");
			CEQU( 1, l[4], 0, 0xd4, "....01.. ........ Max MCS for 3 SS: support for MCS 0-8");
			CEQU( 2, l[4], 0, 0xd4, "....10.. ........ Max MCS for 3 SS: support for MCS 0-9");
			CEQU( 3, l[4], 0, 0xd4, "....11.. ........ Max MCS for 3 SS: support for n Spatial Streams");
			l[4] = l[5];
		ANDG 300 44;
		SHFR 9 44;
			CEQU( 0, l[4], 0, 0xd4, "......00 ........ Max MCS for 4 SS: support for MCS 0-7");
			CEQU( 1, l[4], 0, 0xd4, "......01 ........ Max MCS for 4 SS: support for MCS 0-8");
			CEQU( 2, l[4], 0, 0xd4, "......10 ........ Max MCS for 4 SS: support for MCS 0-9");
			CEQU( 3, l[4], 0, 0xd4, "......11 ........ Max MCS for 4 SS: support for n Spatial Streams");
		
		l[5] = l[4];
		ANDG C0 44;
		SHFR e 44;
			CEQU( 0, l[4], 0, 0xd4, "........ 00...... Max MCS for 5 SS: support for MCS 0-7");
			CEQU( 1, l[4], 0, 0xd4, "........ 01...... Max MCS for 5 SS: support for MCS 0-8");
			CEQU( 2, l[4], 0, 0xd4, "........ 10...... Max MCS for 5 SS: support for MCS 0-9");
			CEQU( 3, l[4], 0, 0xd4, "........ 11...... Max MCS for 5 SS: support for n Spatial Streams");
		l[4] = l[5];
		ANDG 30 44;
		SHFR c 44;
			CEQU( 0, l[4], 0, 0xd4, "........ ..00.... Max MCS for 6 SS: support for MCS 0-7");
			CEQU( 1, l[4], 0, 0xd4, "........ ..01.... Max MCS for 6 SS: support for MCS 0-8");
			CEQU( 2, l[4], 0, 0xd4, "........ ..10.... Max MCS for 6 SS: support for MCS 0-9");
			CEQU( 3, l[4], 0, 0xd4, "........ ..11.... Max MCS for 6 SS: support for n Spatial Streams");
		l[4] = l[5];
		ANDG c 44;
		SHFR b 44;
			CEQU( 0, l[4], 0, 0xd4, "........ ....00.. Max MCS for 7 SS: support for MCS 0-7");
			CEQU( 1, l[4], 0, 0xd4, "........ ....01.. Max MCS for 7 SS: support for MCS 0-8");
			CEQU( 2, l[4], 0, 0xd4, "........ ....10.. Max MCS for 7 SS: support for MCS 0-9");
			CEQU( 3, l[4], 0, 0xd4, "........ ....11.. Max MCS for 7 SS: support for n Spatial Streams");
			l[4] = l[5];
		ANDG 3 44;
		SHFR 9 44;
			CEQU( 0, l[4], 0, 0xd4, "........ ......00 Max MCS for 8 SS: support for MCS 0-7");
			CEQU( 1, l[4], 0, 0xd4, "........ ......01 Max MCS for 8 SS: support for MCS 0-8");
			CEQU( 2, l[4], 0, 0xd4, "........ ......10 Max MCS for 8 SS: support for MCS 0-9");
			CEQU( 3, l[4], 0, 0xd4, "........ ......11 Max MCS for 8 SS: support for n Spatial Streams");
	LABL( 0, 0, 0, 0xb8 );
	LABL( 0, 0, 0, 0xb8 );
	g[2] -= 5;
}

void 802_11::VHT_Capabilities( )
{
	BLNG( 0x40000000, g[1], 0x90, 0xc9, "VHT Capabilities Info:" );
	LABL( 0,	0, 0, 0xd4, "xx...... ........ ........ ........ Reserved");
	CBIT( 0x1D, g[1], 0, 0xd4, "..1..... ........ ........ ........ Tx Antenna Pattern Consistency: Tx antenna pattern does not change");
		CLSE( , g[1], 0, 0xd4, "..0..... ........ ........ ........ Tx Antenna Pattern Consistency: Tx antenna pattern might change");
	CBIT( 0x1C, g[1], 0, 0xd4, "...1.... ........ ........ ........ Rx Antenna Pattern Consistency: Rx antenna pattern does not change");
		CLSE( , g[1], 0, 0xd4, "...0.... ........ ........ ........ Rx Antenna Pattern Consistency: Rx antenna pattern might change");
	l[1] = g[1];
	ANDG c000000 41;
	SHFR 1a 41;
		CEQU( 0, l[1], 0, 0xd4, "....00.. ........ ........ ........ VHT Link Adaptation Capable: No Feedback");
		CEQU( 1, l[1], 0, 0xd4, "....01.. ........ ........ ........ VHT Link Adaptation Capable: reserved");
		CEQU( 2, l[1], 0, 0xd4, "....10.. ........ ........ ........ VHT Link Adaptation Capable: Unsolicited");
		CEQU( 3, l[1], 0, 0xd4, "....11.. ........ ........ ........ VHT Link Adaptation Capable: Both");
	l[1] = g[1];
	ANDG 3800000 41;
	SHFR 17 41;
		CEQU( 0, l[1], 0, 0xd4, "......00 0....... ........ ........ Maximum AMPDU Length Exponent: 8191");
		CEQU( 1, l[1], 0, 0xd4, "......00 1....... ........ ........ Maximum AMPDU Length Exponent: 16383");
		CEQU( 2, l[1], 0, 0xd4, "......01 0....... ........ ........ Maximum AMPDU Length Exponent: 32767");
		CEQU( 3, l[1], 0, 0xd4, "......01 1....... ........ ........ Maximum AMPDU Length Exponent: 65535");
		CEQU( 4, l[1], 0, 0xd4, "......10 0....... ........ ........ Maximum AMPDU Length Exponent: 131071");
		CEQU( 5, l[1], 0, 0xd4, "......10 1....... ........ ........ Maximum AMPDU Length Exponent: 262143");
		CEQU( 6, l[1], 0, 0xd4, "......11 0....... ........ ........ Maximum AMPDU Length Exponent: 524287");
		CEQU( 7, l[1], 0, 0xd4, "......11 1....... ........ ........ Maximum AMPDU Length Exponent: 1048575");
	CBIT( 0x16, g[1], 0, 0xd4, "........ .1...... ........ ........ +HTC-VHT Capable: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ .0...... ........ ........ +HTC-VHT Capable: Not Supported");
	CBIT( 0x15, g[1], 0, 0xd4, "........ ..1..... ........ ........ VHT TXOP PS: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ..0..... ........ ........ VHT TXOP PS: Not Supported");
	CBIT( 0x14, g[1], 0, 0xd4, "........ ...1.... ........ ........ MU Beamformee Capable: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ...0.... ........ ........ MU Beamformee Capable: Not Supported");
	CBIT( 0x13, g[1], 0, 0xd4, "........ ....1... ........ ........ MU Beamformer Capable: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ....0... ........ ........ MU Beamformer Capable: Not Supported");
	l[1] = g[1];
	ANDG 70000 41;
	SHFR 10 41;
		CEQU( 0, l[1], 0, 0xd4, "........ .....000 ........ ........ Number of Sounding Dimensions: 1");
		CEQU( 1, l[1], 0, 0xd4, "........ .....001 ........ ........ Number of Sounding Dimensions: 2");
		CEQU( 2, l[1], 0, 0xd4, "........ .....010 ........ ........ Number of Sounding Dimensions: 3");
		CEQU( 3, l[1], 0, 0xd4, "........ .....011 ........ ........ Number of Sounding Dimensions: 4");
		CEQU( 4, l[1], 0, 0xd4, "........ .....100 ........ ........ Number of Sounding Dimensions: 5");
		CEQU( 5, l[1], 0, 0xd4, "........ .....101 ........ ........ Number of Sounding Dimensions: 6");
		CEQU( 6, l[1], 0, 0xd4, "........ .....110 ........ ........ Number of Sounding Dimensions: 7");
		CEQU( 7, l[1], 0, 0xd4, "........ .....111 ........ ........ Number of Sounding Dimensions: 8");
	l[1] = g[1];
	ANDG E000 41;
	SHFR d 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ........ 000..... ........ Compressed Steering Number of Beamformer Antennas Supported: reserved");
		CEQU( 1, l[1], 0, 0xd4, "........ ........ 001..... ........ Compressed Steering Number of Beamformer Antennas Supported: 2");
		CEQU( 2, l[1], 0, 0xd4, "........ ........ 010..... ........ Compressed Steering Number of Beamformer Antennas Supported: 3");
		CEQU( 3, l[1], 0, 0xd4, "........ ........ 011..... ........ Compressed Steering Number of Beamformer Antennas Supported: 4");
		CEQU( 4, l[1], 0, 0xd4, "........ ........ 100..... ........ Compressed Steering Number of Beamformer Antennas Supported: 5");
		CEQU( 5, l[1], 0, 0xd4, "........ ........ 101..... ........ Compressed Steering Number of Beamformer Antennas Supported: 6");
		CEQU( 6, l[1], 0, 0xd4, "........ ........ 110..... ........ Compressed Steering Number of Beamformer Antennas Supported: 7");
		CEQU( 7, l[1], 0, 0xd4, "........ ........ 111..... ........ Compressed Steering Number of Beamformer Antennas Supported: 8");
	CBIT( 0xC, g[1], 0, 0xd4, "........ ........ ...1.... ........ SU Beamformee Capable: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ........ ...0.... ........ SU Beamformee Capable: Not Supported");
	CBIT( 0xB, g[1], 0, 0xd4, "........ ........ ....1... ........ SU Beam-former Capable: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ........ ....0... ........ SU Beam-former Capable: Not Supported");
	l[1] = g[1];
	ANDG 700 41;
	SHFR 8 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ........ .....000 ........ Rx STBC: no support");
		CEQU( 1, l[1], 0, 0xd4, "........ ........ .....001 ........ Rx STBC: support of one spatial stream");
		CEQU( 2, l[1], 0, 0xd4, "........ ........ .....010 ........ Rx STBC: support of one and two spatial streams");
		CEQU( 3, l[1], 0, 0xd4, "........ ........ .....011 ........ Rx STBC: support of one, two and three spatial streams");
		CEQU( 4, l[1], 0, 0xd4, "........ ........ .....100 ........ Rx STBC: for support of one, two, three and four spatial streams");
		CEQU( 5, l[1], 0, 0xd4, "........ ........ .....101 ........ Rx STBC: Reserved");
		CEQU( 6, l[1], 0, 0xd4, "........ ........ .....110 ........ Rx STBC: Reserved");
		CEQU( 7, l[1], 0, 0xd4, "........ ........ .....111 ........ Rx STBC: Reserved");
	CBIT( 0x7, g[1], 0, 0xd4, "........ ........ ........ 1....... Tx STBC: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ........ ........ 0....... Tx STBC: Not Supported");
	CBIT( 0x6, g[1], 0, 0xd4, "........ ........ ........ .1...... Short GI for 160 and 80+80 MHz: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ........ ........ .0...... Short GI for 160 and 80+80 MHz: Not Supported");
	CBIT( 0x5, g[1], 0, 0xd4, "........ ........ ........ ..1..... Short GI for 80 MHz: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ........ ........ ..0..... Short GI for 80 MHz: Not Supported");
	CBIT( 0x4, g[1], 0, 0xd4, "........ ........ ........ ...1.... Rx LDPC: Supported");
	CLSE( 0, g[1], 0, 0xd4, "........ ........ ........ ...0.... Rx LDPC: Not Supported");
	l[1] = g[1];
	ANDG C 41;
	SHFR 2 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ........ ........ ....00.. Supported Channel Width Set:  no support for 160 or 80+80 MHz");
		CEQU( 1, l[1], 0, 0xd4, "........ ........ ........ ....01.. Supported Channel Width Set:  160 MHz");
		CEQU( 2, l[1], 0, 0xd4, "........ ........ ........ ....10.. Supported Channel Width Set: 160 MHz and 80+80 MHz");
		CEQU( 3, l[1], 0, 0xd4, "........ ........ ........ ....11.. Supported Channel Width Set: reserved");
	l[1] = g[1];
	ANDG 3 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ........ ........ ......00 Maximum MPDU Length: 3895 octets");
		CEQU( 1, l[1], 0, 0xd4, "........ ........ ........ ......01 Maximum MPDU Length: 7991 octets");
		CEQU( 2, l[1], 0, 0xd4, "........ ........ ........ ......10 Maximum MPDU Length: 11454 octets");
		CEQU( 3, l[1], 0, 0xd4, "........ ........ ........ ......11 Maximum MPDU Length: reserved");
	g[2] -= 4;
	LABL( 0, 0, 0, 0xc8 );

	LABL 0 0 0 c7 VHT Supported MCS Set;

	BWRD( 0x40000000, g[1], 0x90, 0xc9, "Rx MCS Map:" );
	l[1] = g[1];
	ANDG 3 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ......00 Supported MCS index for 1 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "........ ......01 Supported MCS index for 1 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "........ ......10 Supported MCS index for 1 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "........ ......11 Supported MCS index for 1 SS: Not provided");
	l[1] = g[1];
	ANDG C 41;
	SHFR 2 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ....00.. Supported MCS index for 2 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "........ ....01.. Supported MCS index for 2 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "........ ....10.. Supported MCS index for 2 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "........ ....11.. Supported MCS index for 2 SS: Not provided");
	l[1] = g[1];
	ANDG 30 41;
	SHFR 4 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ..00.... Supported MCS index for 3 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "........ ..01.... Supported MCS index for 3 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "........ ..10.... Supported MCS index for 3 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "........ ..11.... Supported MCS index for 3 SS: Not provided");
	l[1] = g[1];
	ANDG C0 41;
	SHFR 6 41;
		CEQU( 0, l[1], 0, 0xd4, "........ 00...... Supported MCS index for 4 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "........ 01...... Supported MCS index for 4 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "........ 10...... Supported MCS index for 4 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "........ 11...... Supported MCS index for 4 SS: Not provided");
	l[1] = g[1];
	ANDG 300 41;
	SHFR 8 41;
		CEQU( 0, l[1], 0, 0xd4, "......00 ........ Supported MCS index for 5 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "......01 ........ Supported MCS index for 5 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "......10 ........ Supported MCS index for 5 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "......11 ........ Supported MCS index for 5 SS: Not provided");
	l[1] = g[1];
	ANDG C00 41;
	SHFR A 41;
		CEQU( 0, l[1], 0, 0xd4, "....00.. ........ Supported MCS index for 6 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "....01.. ........ Supported MCS index for 6 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "....10.. ........ Supported MCS index for 6 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "....11.. ........ Supported MCS index for 6 SS: Not provided");		
	l[1] = g[1];
	ANDG 3000 41;
	SHFR C 41;
		CEQU( 0, l[1], 0, 0xd4, "..00.... ........ Supported MCS index for 7 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "..01.... ........ Supported MCS index for 7 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "..10.... ........ Supported MCS index for 7 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "..11.... ........ Supported MCS index for 7 SS: Not provided");	
	l[1] = g[1];
	ANDG C000 41;
	SHFR e 41;
		CEQU( 0, l[1], 0, 0xd4, "00...... ........ Supported MCS index for 8 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "01...... ........ Supported MCS index for 8 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "10...... ........ Supported MCS index for 8 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "11...... ........ Supported MCS index for 8 SS: Not provided");	
	LABL( 0, 0, 0, 0xc8 );
	INCR 80000003;
	DBIT( 0x4000000D, g[1], 0x90, 0xc2, "Rx Highest Supported Data Rate:\");
		CEQU( 0, g[1], 0, 0x14, "(Subfield not in use)");
		CNEQ( 0, g[1], 0, 0x14, "Mbps");

	BWRD( 0x40000000, g[1], 0x90, 0xc9, "Tx MCS Map:" );
	l[1] = g[1];
	ANDG 3 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ......00 Supported MCS index for 1 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "........ ......01 Supported MCS index for 1 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "........ ......10 Supported MCS index for 1 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "........ ......11 Supported MCS index for 1 SS: Not provided");
	l[1] = g[1];
	ANDG C 41;
	SHFR 2 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ....00.. Supported MCS index for 2 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "........ ....01.. Supported MCS index for 2 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "........ ....10.. Supported MCS index for 2 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "........ ....11.. Supported MCS index for 2 SS: Not provided");
	l[1] = g[1];
	ANDG 30 41;
	SHFR 4 41;
		CEQU( 0, l[1], 0, 0xd4, "........ ..00.... Supported MCS index for 3 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "........ ..01.... Supported MCS index for 3 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "........ ..10.... Supported MCS index for 3 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "........ ..11.... Supported MCS index for 3 SS: Not provided");
	l[1] = g[1];
	ANDG C0 41;
	SHFR 6 41;
		CEQU( 0, l[1], 0, 0xd4, "........ 00...... Supported MCS index for 4 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "........ 01...... Supported MCS index for 4 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "........ 10...... Supported MCS index for 4 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "........ 11...... Supported MCS index for 4 SS: Not provided");
	l[1] = g[1];
	ANDG 300 41;
	SHFR 8 41;
		CEQU( 0, l[1], 0, 0xd4, "......00 ........ Supported MCS index for 5 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "......01 ........ Supported MCS index for 5 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "......10 ........ Supported MCS index for 5 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "......11 ........ Supported MCS index for 5 SS: Not provided");
	l[1] = g[1];
	ANDG C00 41;
	SHFR A 41;
		CEQU( 0, l[1], 0, 0xd4, "....00.. ........ Supported MCS index for 6 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "....01.. ........ Supported MCS index for 6 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "....10.. ........ Supported MCS index for 6 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "....11.. ........ Supported MCS index for 6 SS: Not provided");
		l[1] = g[1];
	ANDG 3000 41;
	SHFR C 41;
		CEQU( 0, l[1], 0, 0xd4, "..00.... ........ Supported MCS index for 7 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "..01.... ........ Supported MCS index for 7 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "..10.... ........ Supported MCS index for 7 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "..11.... ........ Supported MCS index for 7 SS: Not provided");		
	l[1] = g[1];
	ANDG C000 41;
	SHFR e 41;
		CEQU( 0, l[1], 0, 0xd4, "00...... ........ Supported MCS index for 8 SS: 0, 1, 2, 3, 4, 5, 6, 7");
		CEQU( 1, l[1], 0, 0xd4, "01...... ........ Supported MCS index for 8 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8");
		CEQU( 2, l[1], 0, 0xd4, "10...... ........ Supported MCS index for 8 SS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9");
		CEQU( 3, l[1], 0, 0xd4, "11...... ........ Supported MCS index for 8 SS: Not provided");
	LABL( 0, 0, 0, 0xc8 );
	INCR 80000003;
	DBIT( 0x4000000D, g[1], 0x90, 0xc2, "Tx Highest Supported Data Rate:\");
		CEQU( 0, g[1], 0, 0x14, "(Subfield not in use)");
		CNEQ( 0, g[1], 0, 0x14, "Mbps");

	LABL 0 0 0 c8;  * Enclose VHT MCS Layer
	g[2] -= 12;
}
//-------------------------------------------------
void 802_11::Print_OUI()
{
	//get the oui so we can look up the company
	GLNG 0 41 5 5;
	HEX# 80000001 0 90 c2 OUI:;
	HEX# 80000001 0 90 00 -;
	HEX# 80000001 0 90 00 -;
	SHFR 8 41;
	CST# 0 41 0 14 802_11::OUI_Strings;
	TRTS;
}

//-------------------------------------------------

str# 802_11::IE_WME::AC::ACI;
	.01. .... ACI: Background;
	.10. .... ACI: Video;
	.11. .... ACI: Voice;

str# 802_11::IE_WME::AC::AIFSN;
	.... 0001 AIFSN: 1;
	.... 0010 AIFSN: 2;
	.... 0011 AIFSN: 3;
	.... 0100 AIFSN: 4;
	.... 0101 AIFSN: 5;
	.... 0110 AIFSN: 6;
	.... 0111 AIFSN: 7;
	.... 1000 AIFSN: 8;
	.... 1001 AIFSN: 9;
	.... 1010 AIFSN: 10;
	.... 1011 AIFSN: 11;
	.... 1100 AIFSN: 12;
	.... 1101 AIFSN: 13;
	.... 1110 AIFSN: 14;
	.... 1111 AIFSN: 15;

str# 802_11::IE_WME::AC::CW_MAX;		
	0001 .... ECW Max: 1 (CW Max: 1);
	0010 .... ECW Max: 2 (CW Max: 3);
	0011 .... ECW Max: 3 (CW Max: 7);
	0100 .... ECW Max: 4 (CW Max: 15);
	0101 .... ECW Max: 5 (CW Max: 31);
	0110 .... ECW Max: 6 (CW Max: 63);
	0111 .... ECW Max: 7 (CW Max: 127);
	1000 .... ECW Max: 8 (CW Max: 257);
	1001 .... ECW Max: 9 (CW Max: 511);
	1010 .... ECW Max: 10 (CW Max: 1,023);
	1011 .... ECW Max: 11 (CW Max: 2,047);
	1100 .... ECW Max: 12 (CW Max: 4,095);
	1101 .... ECW Max: 13 (CW Max: 8,191);
	1110 .... ECW Max: 14 (CW Max: 16,383);
	1111 .... ECW Max: 15 (CW Max: 32,767);

str# 802_11::IE_WME::AC::CW_MIN;
	.... 0001 ECW Min: 1 (CW Min: 1);
	.... 0010 ECW Min: 2 (CW Min: 3);
	.... 0011 ECW Min: 3 (CW Min: 7);
	.... 0100 ECW Min: 4 (CW Min: 15);
	.... 0101 ECW Min: 5 (CW Min: 31);
	.... 0110 ECW Min: 6 (CW Min: 63);
	.... 0111 ECW Min: 7 (CW Min: 127);
	.... 1000 ECW Min: 8 (CW Min: 257);
	.... 1001 ECW Min: 9 (CW Min: 511);
	.... 1010 ECW Min: 10 (CW Min: 1,023);
	.... 1011 ECW Min: 11 (CW Min: 2,047);
	.... 1100 ECW Min: 12 (CW Min: 4,095);
	.... 1101 ECW Min: 13 (CW Min: 8,191);
	.... 1110 ECW Min: 14 (CW Min: 16,383);
	.... 1111 ECW Min: 15 (CW Min: 32,767);

str# 802_11::IE_WME::QoS_Info_Field;
	.... 0001 Parameter Set Count: 1;
	.... 0010 Parameter Set Count: 2;
	.... 0011 Parameter Set Count: 3;
	.... 0100 Parameter Set Count: 4;
	.... 0101 Parameter Set Count: 5;
	.... 0110 Parameter Set Count: 6;
	.... 0111 Parameter Set Count: 7;
	.... 1000 Parameter Set Count: 8;
	.... 1001 Parameter Set Count: 9;
	.... 1010 Parameter Set Count: 10;
	.... 1011 Parameter Set Count: 11;
	.... 1100 Parameter Set Count: 12;
	.... 1101 Parameter Set Count: 13;
	.... 1110 Parameter Set Count: 14;
	.... 1111 Parameter Set Count: 15;
	
str# 802_11::IE_WME::TS_INFO::UP;
	........ ..001... ........ UP: 1;
	........ ..010... ........ UP: 2;
	........ ..011... ........ UP: 3;
	........ ..100... ........ UP: 4;
	........ ..101... ........ UP: 5;
	........ ..110... ........ UP: 7;
	........ ..111... ........ UP: 7;

str# 802_11::IE_WME::TS_INFO::Direction;
	........ ........ .01..... Direction: Downlink;
	........ ........ .10..... Direction: Reserved;
	........ ........ .11..... Direction: Bi-directional;

str# 802_11::IE_WME::TS_INFO::TID;
	........ ........ ...0001. TID: EDCA: 1;
	........ ........ ...0010. TID: EDCA: 2;
	........ ........ ...0011. TID: EDCA: 3;
	........ ........ ...0100. TID: EDCA: 4;
	........ ........ ...0101. TID: EDCA: 5;
	........ ........ ...0110. TID: EDCA: 6;
	........ ........ ...0111. TID: EDCA: 7;
	........ ........ ...1000. TID: HCCA/HEMM: 8;
	........ ........ ...1001. TID: HCCA/HEMM: 9;
	........ ........ ...1010. TID: HCCA/HEMM: 10;
	........ ........ ...1011. TID: HCCA/HEMM: 11;
	........ ........ ...1100. TID: HCCA/HEMM: 12;
	........ ........ ...1101. TID: HCCA/HEMM: 13;
	........ ........ ...1110. TID: HCCA/HEMM: 14;
	........ ........ ...1111. TID: HCCA/HEMM: 15;

str# LSAPsLT6;
	Null LSAP;
	;
	Individual LLC Sublayer Management Function;
	Group LLC Sublayer Management Function;
	SNA (individual);
	SNA (group);
	IP;
	
str# LLC::XID Fmt Types;
	Fixed;
	Variable (T1 or T2.0 to T4 or T5);
	Reserved;
	Variable (T2.1 to T2.1 or T4 or T5);
	
str# LLC::XID Send Node Types;
	Undefined;
	T1;
	T2;
	Reserved;
	Subarea Node (T4 or T5);
	
str# LLC::Link-Stn Tran-Rec Cap Types;
	Capable of Two-Way Alternating;
	Capable of Two-Way Simultaneous;
	
str# LLC::Seg Assem Cap Of Pth Cntrl Elmnt Of Nd;
	The Mapping field is ignored and PIUs are forwarded unchanged;
	Segments are assembled on a link-station basis;
	Segments are assembled on a session basis;
	Only whole BIUs are allowed;
	
str# LLC::DLC Types;
	SDLC;
	System/370 channel to controller DLC;
	
str# Hex Digits;
	0;
	1;
	2;
	3;
	4;
	5;
	6;
	7;
	8;
	9;
	A;
	B;
	C;
	D;
	E;
	F;
str# LLC::XID Exch States;
	Exchange state indicators not supported;
	Negotiation-proceeding exchange;
	Prenegotiation exchange;
	Nonactivation exchange;
str# LLC::XID Adpt Pacing Supt;
	Independent & Dependent adaptive BIND pacing support non-negotiable;
	Independent & Dependent adaptive BIND pacing support unless overridden;
	Adaptive BIND pacing support state reserved;
	Adaptive BIND pacing support applies only to independent LUs;
str# LLC::XID Link Stn Roles;
	Sender is secondary link (nonnegotiable);
	Sender is primary link (nonnegotiable);
	Reserved;
	Sender is negotiable primary/secondary link station;
str# LLC::XID Link Stn xmit recv;
	Transmit & receive are two-way alternating;
	Transmit & receive are two-way simultaneous;
	Transmit & receive are undefined;
	Transmit & receive are undefined;
str# LLC::XID Time Units;
	100-millisecond time units;
	1-millisecond time units;
str# MV Class Types;
	Ring Station;
	LLC Manager;
	;
	;
	Network Manager;
	Ring Parameter Server;
	Ring Error Monitor;
str# MV Command Types;
	Response;
	;
	Beacon;
	Claim Token;
	Ring Purge;
	Active Monitor Present;
	Standby Monitor Present;
	Duplicate Address Test;
	Lobe Media Test;
	Transmit Forward;
	;
	Remove Ring Station;
	Change Parameters;
	Initialize Ring Station;
	Request Station Address;
	Request Station State;
	Request Station Attachment;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	Request Initialization;
	;
	Report Station Address;
	Report Station State;
	Report Station Attachment;
	Report New Monitor;
	Report SUA Change;
	Report Ring Poll Failure;
	Report Monitor Error;
	Report Error;
	Report Transmit Forward;
	
void PAD;  * CBB - this should probably do something
	TRTS;  
	
str# MV Subvector Types;
	PAD;
	Beacon Type;
	Upstream Neighbor Address;
	Local Ring Number;
	Assign Physical Drop Number;
	Soft Error Report Timer Value;
	Enabled Function Classes;
	Allowed Access Priority;
	;
	Correlator;
	Address of Last Ring Poll;
	Physical Drop Number;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	;
	Response Code;
	Reserved;
	Product ID;
	Adapter Software Level;
	;
	;
	Wrap Data;
	Frame Forward;
	;
	Adapter Status Vector;
	Transmit Status Code;
	Group Address;
	Functional Address;
	Isolating Errors;
	Nonisolating Errors;
	;
	Error Code;
str# MV Beacon Types;
	Set Recovery Mode;
	Ring Signal Loss Detected;
	Monitor Contention Failed: No Frames Received;
	Monitor Contention Failed: Frames Received;
str# MV Response Codes;
	MAC Data Frame Incomplete;
	Major Vector Length Inconsistent;
	Major Vector Command Not Supported;
	Inappropriate Source Class;
	Subvector Length Invalid;
	Transmit Forward Frame Error;
	Required Subvector Missing;
	Required Subvector Unknown;
	MAC Frame Exceeds Maximum Length;
	Function Disabled;
str# MV Error Types;
	Monitor Error;
	Duplicate Monitor;
	Duplicate Address;
str# Brd Bit Types;
	Nonbroadcast;
	;
	;
	;
	All Routes Brdcast, Nonbrdcast Return;
	;
	Single Route Brdcast, All Routes Brdcast Return;
	Single Route Brdcast, Nonbrdcast Return;
str# Long Frame Types;
	maximum 516 bytes in info field;
	maximum 1,470 bytes in info field;
	maximum 2,052 bytes in info field;
	maximum 4,472 bytes in info field;
	maximum 8,144 bytes in info field;
	maximum 11,407 bytes in info field;
	maximum 17,800 bytes in info field;
	initial value of broadcast frames;
str# 802.11 Bands;
	undef0;							* 0	undefined
	802.11;							* 1   vanilla 802.11 band (2MBit, 2.4GHz)
	802.11b;						* 2   802.11b band (11MBit 2.4GHz)
	802.11a;						* 3   802.11a band (54MBit 5GHz)
	802.11bg;						* 4   802.11g and bg band (54MBit 2.4GHz)
	undef5;							* 5 undefined
	802.11n;						* 6   802.11n beam forming band 100MBit+ (still not released)   
	802.11 turbo a;					* 7   802.11a doubled speed (108 Mbit 5GHz)
	802.11 turbo g;					* 8   802.11g doubled speed (108Mbit 5Ghz)
	802.11 super g;					* 9   802.11g dynamic turbo band

str# 802.11a Bands;					* 
	802.11a 1MHz;					* 100  [La1]"802.11a 1MHz licensed band" (FCC only for now)
	802.11a 5MHz;					* 101  [La5]"802.11a 5MHz licensed band" (FCC only for now)
	802.11a 10MHz;					* 102  [La10]"802.11a 10MHz licensed band" (FCC only for now)
	802.11a 15MHz;					* 103  [La15]"802.11a 15MHz licensed band" (FCC only for now)
	802.11a 20MHz;					* 104  [La20]"802.11a 20MHz licensed band" (FCC only for now)

// Ralkink uses 201-204 for ac

str# 802.11u Bands;
	802.11ac 20MHz;					* 200  [ac]	
	802.11ac 40MHz;					* 201  [ac]
	802.11ac 80MHz;					* 202  [ac]
	802.11ac 160MHz;				* 203  [ac]
	802.11ac u4;					* 204  [ac]
	802.11 u5;						* 205  [u5]"Unknown 5"
	802.11 u6;						* 206  [u6]"Unknown 6"
	802.11 u7;						* 207  [u7]"Unknown 7"
	802.11 u8;						* 208  [u8]"Unknown 8"
	802.11 u9;						* 209  [u9]"Unknown 9"
	
str# 802.11n Bands
	802.11n 20MHz;					* 300  [n20] "802.11n 20MHz"
	802.11n 40MHz;					* 301  [n40] "802.11n 40MHz"
	802.11n 40MHz low;				* 302  [n40l] "802.11n 40MHz low"
	802.11n 40MHz high;				* 303  [n40h] "802.11n 40MHz high"

str# 802_11::Type;
	Management;
	Control;
	Data;
	Reserved;
	
str# 802_11::Subtype;
* Management
	Association Request;
	Association Response;
	Reassociation Request;
	Reassociation Response;
	Probe Request;
	Probe Response;
	Reserved;
	Reserved;
	Beacon;
	ATIM;
	Disassociation;
	Authentication;
	Deauthentication;
	Action;
	Action No Ack;
	Reserved;
* Control
	Reserved;
	Reserved;
	Reserved;
	Reserved;
	Beamforming Report Poll;				*IEEE P802.11ac D3.0 June 2012
	VHT NDP Announcement;					*IEEE P802.11ac D3.0 June 2012
	Reserved;
	Control Wrapper;
	Block Acknowledgement Request (BlockAckReq);
	Block Acknowledgement (BlockAck);
	Power Save (PS)-Poll;
	Request To Send (RTS);
	Clear To Send (CTS);
	Acknowledgment (ACK);
	Contention Free (CF)-End;
	CF-End + CF-Ack;
* Data
	Data;
	Data + CF-Ack;
	Data + CF-Poll;
	Data + CF-Ack + CF-Poll;
	Null (No Data);
	CF-Ack (No Data);
	CF-Poll (No Data);
	CF-Ack + CF-Poll (No Data);
	QoS Data;
	QoS Data + CF-Ack;
	QoS Data + CF-Poll;
	QoS Data + CF-Ack + CF-Poll;
	QoS Null (No Data);
	Reserved;
	QoS CF-Poll (no data);
	QoS CF-Ack + CF Poll (no data);
	
str# 802_11::Element_Id_Str;
	SSID;
	Supported Rates\Rates:;
	Frequency Hopping Parameter Set\FHPS:;
	Direct Sequence Parameter Set\DSPS:;
	Contention Free Parameter Set\CFPS:;
	Traffic Indication Map\TIM:;
	IBSS Parameter Set\IBSS:;
	Country;
	FH Hopping Pattern Parameters\FH Params:;
	FH Hopping Pattern Table\FH Table:;
	Request;
	QBSS Load\QBSS:;					
	EDCA Parameter\EDCA:;				
	Traffic Specification\TSPEC:;		
	Traffic Classification\TCLASS:;		
	Schedule Information\SCHED:;
	Challenge text;
	Reserved 17;
	Reserved 18;
	Reserved 19;
	Reserved 20;
	Reserved 21;
	Reserved 22;
	Reserved 23;
	Reserved 24;
	Reserved 25;
	Reserved 26;
	Reserved 27;
	Reserved 28;
	Reserved 29;
	Reserved 30;
	Reserved 31;
	Power Constraint;
	Power Capability;
	TPC Request;
	TPC Report;
	Supported Channels;
	Channel Switch Announcement;
	Measurement Request;
	Measurement Report;
	Quiet;
	IBSS DFS;
	ERP Information\ERP:;
	TS Delay\TSD:;
	TCLAS Processing\TCLAS:;
	HT Capability Info\HT Cap:;
	QoS Capability\QoS Cap:;
	Reserved 47;
	RSN Information\RSN:;
	Reserved 49;
	Extended Supported Rates;
	AP Channel Report;
	Neighbor Report;
	RCPI;
	Mobility Domain;
	Fast BSS Transition (FTE);
	Timeout Interval;
	RIC Data (RDE);
	DSE Registered Location;
	Supported Regulatory Classes;
	Extended Channel Switch Announcement;
	HT Operation Information\HT Info:;
	Secondary Channel Offset;
	BSS Average Access Delay;
	Antenna;
	RSNI;
	Measurement Pilot Transmission;
	BSS Available Admission Capacity;
	WAPI;
	Wave Service Information; //TT23761 but it's 802.11p
	RM Enabled Capabilities;
	Multiple BSSID;
	20/40 BSS Coexistence;
	20/40 BSS Intolerant Channel Report;
	Overlapping BSS Scan Parameters;
	RIC Descriptor;
	Management MIC;
	Reserved 77;
	Event Request;	//TT23184: 802.11v
	Event Report;	//TT23184: 802.11v
	Diagnostic Request;	//TT23184: 802.11v
	Diagnostic Report;	//TT23184: 802.11v
	Location Parameters;	//TT23184: 802.11v
	Non-transmitted BSSID Capability;	//TT23184: 802.11v
	SSID List;	//TT23184: 802.11v
	Multiple BSSID-Index;	//TT23184: 802.11v
	FMS Descriptor;	//TT23184: 802.11v
	FMS Request;	//TT23184: 802.11v
	FMS Response;	//TT23184: 802.11v
	QoS Traffic Capability;	//TT23184: 802.11v
	BSS Max Idle Period;	//TT23184: 802.11v
	TFS Request;	//TT23184: 802.11v
	TFS Response;	//TT23184: 802.11v
	WNM-Sleep Mode;	//TT23184: 802.11v
	TIM Broadcast Request;	//TT23184: 802.11v
	TIM Broadcast Response;	//TT23184: 802.11v
	Collocated Interference Report;	//TT23184: 802.11v
	Channel Usage;	//TT23184: 802.11v
	Time Zone;	//TT23184: 802.11v
	DMS Request;	//TT23184: 802.11v
	DMS Response;	//TT23184: 802.11v
	Link Identifier;
	Wakeup Schedule;
	Reserved 103;
	Channel Switch Timing;
	PTI Control;
	TPU Buffer Status;
	Interworking;
	Advertisement Protocol;
	Expedited Bandwidth Request;
	QoS Map Set;
	Roaming Consortium;
	Emergency Alert Identifier;
	Mesh Configuration;
	Mesh ID;
	Mesh Link Metric Report;
	Congestion Notification;
	Mesh Peering Management;
	Mesh Channel Switch Parameters;
	Mesh Awake Window;
	Beacon Timing;
	MCCAOP Setup Request;
	MCCAOP Setup Reply;
	MCCAOP Advertisement;
	MCCAOP Teardown;
	GANN;
	RANN;
	Extended Capabilities;
	Agere Proprietary;
	Reserved 129;
	PREQ;
	PREP;
	PERR;
	Cisco Proprietary;
	Reserved 134;
	Reserved 135;
	Reserved 136;
	Reserved 137;
	Reserved 138;
	Reserved 139;
	Reserved 140;
	Destination URI;			//TT23184: 802.11v
	U-APSD Coexistence ;		//TT23184: 802.11v
	Reserved 143;
	Reserved 144;
	Reserved 145;
	Reserved 146;
	Reserved 147;
	Reserved 148;
	Reserved 149;
	Reserved 150;
	Reserved 151;
	Reserved 152;
	Reserved 153;
	Reserved 154;
	Reserved 155;
	Reserved 156;
	Reserved 157;
	Reserved 158;
	Reserved 159;
	Reserved 160;
	Reserved 161;
	Reserved 162;
	Reserved 163;
	Reserved 164;
	Reserved 165;
	Reserved 166;
	Reserved 167;
	Reserved 168;
	Reserved 169;
	Reserved 170;
	Reserved 171;
	Reserved 172;
	Symbol Proprietary;
    MCCAOP Advertisement Overview;
    Reserved 175;
    Reserved 176;
    Reserved 177;
    Reserved 178;
    Reserved 179;
    Reserved 180;
    Reserved 181;
    Reserved 182;
    Reserved 183;
    Reserved 184;
    Reserved 185;
    Reserved 186;
    Reserved 187;
    Reserved 188;
    Reserved 189;
    Reserved 190;
    VHT Capabilities element;		//IEEE P802.11ac D3.0 June 2012
    VHT Operation element;		//IEEE P802.11ac D3.0 June 2012
    Extended BSS Load;				//IEEE P802.11ac D3.0 June 2012
	Wide Bandwidth Channel Switch;				//IEEE P802.11ac D3.0 June 2012
    VHT Transmit Power Envelope;				//IEEE P802.11ac D3.0 June 2012
    Channel Switch Wrapper;				//IEEE P802.11ac D3.0 June 2012
    AID;				//IEEE P802.11ac D3.0 June 2012
    Quiet Channel;				//IEEE P802.11ac D3.0 June 2012
	Operating Mode Notification;				//IEEE P802.11ac D3.0 June 2012
    Reserved 200;
    Reserved 201;
    Reserved 202;
    Reserved 203;
    Reserved 204;
    Reserved 205;
    Reserved 206;
    Reserved 207;
    Reserved 208;
    Reserved 209;
    Reserved 210;
    Reserved 211;
    Reserved 212;
    Reserved 213;
    Reserved 214;
    Reserved 215;
    Reserved 216;
    Reserved 217;
    Reserved 218;
    Reserved 219;
    Reserved 220;
    WPA;
	
str# 802_11::Authentication Algorithm;
	Open System;
	Shared Key;
	Fast BSS Transition;
	Simultaneous authentication of equals (SAE);
	
str# 802_11::Status Code;
	 0 | Successful;
	 1 | Unspecified failure;
	 2 | TDLS wakeup schedule rejected but alternative schedule provided;	
	 3 | TDLS wakeup schedule rejected;
	 4 | Reserved;
	 5 | Security disabled;
	 6 | Unacceptable lifetime;
	 7 | Not in same BSS;
	 8 | Reserved;
	 9 | Reserved;
	10 | Cannot Support all requested capabilities...;
	11 | Reassociation denied due to inability to confirm...;
	12 | Association denied due to reason outside the scope...;
	13 | Responding station does not support the specified auth...;
	14 | Received an authentication frame with authentication...;
	15 | Authentication rejected because of challenge failure;
	16 | Authentication rejected due to timeout waiting for next...;
	17 | Association denied because AP is unable to handle additional...;
	18 | Association denied due to requesting station not supporting all rates;
	19 | Association denied due to requesting station not supporting short preamble;
	20 | Association denied due to requesting station not supporting PBCC;
	21 | Association denied due to requesting station not supporting channel agility;
	22 | Association request rejected because Spectrum Management capability is required;
	23 | Association request rejected because the information in the Power Capability element is unacceptable;
	24 | Association request rejected because the information in the Supported Channels element is unacceptable;
	25 | Association denied due to requesting STA not supporting the Short Slot Time option;
	26 | Association denied due to requesting STA not supporting the DSSS-OFDM option;
	27 | Association denied because the requesting STA does not support HT features;
	28 | R0KH unreachable;
	29 | Association denied because the requesting STA does not support the PCO transition time required by the AP;
	32 | Unspecified, QoS-related failure;
	33 | Association denied due to QAP having insufficient bandwidth to handle another QSTA;
	34 | Association denied due to excessive frame loss rates and/or poor conditions on current operating channel;
	35 | Association (with QBSS) denied due to requesting station not supporting the QoS facility;
	37 | The request has been declined;
	38 | The request has not been successful as one or more parameters have invalid values;
	39 | The TS has not been created because the request cannot be honored;
	40 | Invalid information element;
	41 | Invalid group cipher;
	42 | Invalid pairwise cipher;
	43 | Invalid AKMP;
	44 | Unsupported RSN information element version;
	45 | Invalid RSN information element capabilities;
	46 | Cipher suite rejected per security policy;
	47 | The TS has not been created;
	48 | Direct Link is not allowed in the BSS by policy;
	49 | Destination STA is not present within this QBSS;
	50 | The Destination STA is not a QSTA;
	51 | Association denied because the ListenInterval is too large;
	52 | Invalid FT Action frame count;
	53 | Invalid pairwise master key identifier (PMKID);
	54 | Invalid MDIE;
	55 | Invalid FTIE;
	56 | Requested TCLAS processing is not sup ported by the AP;			//TT23184 802.11v
	57 | The AP has insufficient TC LAS processing resources to satisfy the request;			//TT23184 802.11v
	58 | The TS has not been created because the request can't be honored, however, the HC suggests the STA transitions to other BSSs to setup the TS;			//TT23184 802.11v
	59 | GAS Advertisement Protocol not supported;				//TT23761: 802.11u
	60 | No outstanding GAS request;				//TT23761: 802.11u
	61 | GAS Response not received from the Advertisement Server;				//TT23761: 802.11u
	62 | STA timed out waiting for GAS Query Response;				//TT23761: 802.11u
	63 | GAS Response is larger than query response length limit;				//TT23761: 802.11u
	64 | Request refused because home network does not support request;				//TT23761: 802.11u
	65 | Advertisement Server in the network is not currently reachable;				//TT23761: 802.11u
	67 | Request refused due to permissions received via SSPN interface;				//TT23761: 802.11u
	68 | Request refused because AP does not support unauthenticated access;				//TT23761: 802.11u
	73 | U-APSD Coexistence is  not supported;			//TT23184 802.11v
	74 | Requested U-APSD Coexistence mode is not supported;			//TT23184 802.11v
	75 | Requested Interval/Duration value cannot be supported with U-APSD Coexistence;			//TT23184 802.11v
	79 | Transmission failure;
	80 | Requested TCLAS Not Supported;			//TT23184 802.11v
	81 | TCLAS Resources Exhausted;			//TT23184 802.11v
	82 | Rejected with Suggested BSS Transition;			//TT23184 802.11v
	92 | REFUSED_EXTERNAL_REASON (Re)association refused for some external reason;
	93 | REFUSED_AP_OUT_OF_MEMORY (Re)association refused because of memory limits at the AP;
	94 | REJECTED_EMERGENCY_SERVICES_NOT_SUPPORTED (Re)association refused because emergency services are not supported at the AP;
	95 | QUERY_RESPONSE_OUTSTANDING GAS query response not yet received;
	100 | MCCAOP_RESERVATION_CONFLICT The request failed due toa reservation conflict;
	101 | MAF_LIMIT_EXCEEDED The request failed due to exceeded MAF limit;
	102 | MCCA_TRACK_LIMIT_EXCEEDED The request failed due to exceeded MCCA track limit;
//103ï¿½65 535 Reserved
	
str# 802_11::Reason Code;
	 0 | Reserved;
	 1 | Unspecified reason;
	 2 | Previous authentication no longer valid;
	 3 | Deauthenticated because sending station is leaving;
	 4 | Disassociated due to inactivity;
	 5 | Disassociated because AP is unable to handle all currently...;
	 6 | Class 2 frame received from nonauthenticated station;
	 7 | Class 3 frame received from nonassociated station;
	 8 | Disassociated because sending station is leaving;
	 9 | Station requesting (re)association is not authenticated with...;
	10 | Disassociated because the information in the Power Capability element is unacceptable;
	11 | Disassociated because the information in the Supported Channels element is unacceptable;
	12 | Disassociated due to BSS Transition Management;			//TT23184 802.11v
	13 | Invalid information element;
	14 | MIC failure;
	15 | 4-Way Handshake timeout;
	16 | Group Key Handshake timeout;
	17 | IE in 4-Way Handshake different from (Re)Assoc Req-Probe Res-Beacon frame;
	18 | Invalid group cipher;
	19 | Invalid pairwise cipher;
	20 | Invalid AKMP;
	21 | Unsupported RSN information element version;
	22 | Invalid RSN information element capabilities;
	23 | IEEE 802.1X authentication failed;
	24 | Cipher suite rejected because of the security policy;
	27 | Disassociated because session terminated by SSP request; //TT23761: 802.11u
	28 | Disassociated because of lack of SSP roaming agreement; //TT23761: 802.11u
	29 | Requested service rejected because of SSP ciphersuite or AKM requirement; //TT23761: 802.11u
	30 | Requested service not authorized in this location; //TT23761: 802.11u	
	32 | Disassociated for unspecified, QoS-related reason;
	33 | Disassociated because QAP lacks sufficient bandwidth for this QSTA;
	34 | Disassociated because of excessive number of frames that need to be acknowledged, but are not acknowledged for AP transmissions and-or poor channel conditions;
	35 | Disassociated because QSTA is transmitting outside the limits of its TXOPs;
	36 | Requested from peer QSTA as the QSTA is leaving the QBSS (or resetting);
	37 | Requested from peer QSTA as it does not want to use the mechanism;
	38 | Requested from peer QSTA as the QSTA received frames using the mechanism for which a set up is required;
	39 | Requested from peer QSTA due to time out;
	45 | Peer QSTA does not support the requested cipher suite;
	46 | Disassociated because authorized access limit reached; //TT23761: 802.11u
	47 | Disassociated due to external service requirements; //TT23761: 802.11u
	48 | Invalid FT Action frame count;
	49 | Invalid pairwise masterkey identifier (PMKI);
	50 | Invalid MDE;
	51 | Invalid FTE;
	52 | MESH-PEERING-CANCELLED, SME cancels the mesh peering instance with the reason other than reaching the maximum number of peer mesh STAs;
	53 | MESH-MAX-PEERS, The mesh STA has reached the supported maximum number of peer mesh STAs;
	54 | MESH-CONFIGURATION-POLICY-VIOLATION, The received information violates the Mesh Configuration policy configured in the mesh STA profile;
	55 | MESH-CLOSE-RCVD, The mesh STA has received a Mesh Peering Close message requesting to close the mesh peering;
	56 | MESH-MAX-RETRIES, The mesh STA has resent dot11MeshMaxRetries Mesh Peering Open messages, without receiving a Mesh Peering Confirm message;
	57 | MESH-CONFIRM-TIMEOUT, The confirmTimer for the mesh peering instance times out;
	58 | MESH-INVALID-GTK, The mesh STA fails to unwrap the GTK or the values in the wrapped contents do not match;
	59 | MESH-INCONSISTENT-PARAMETERS, The mesh STA receives inconsistent information about the mesh parameters between MeshPeering Management frames;
	60 | MESH-INVALID-SECURITY-CAPABILITY, The mesh STA fails the authenticated mesh peering exchange because due to failure in selecting either the pairwise ciphersuite or group ciphersuite;
	61 | MESH-PATH-ERROR-NO-PROXY-INFORMATION, The mesh STA does not have proxy information for this external destination;
	62 | MESH-PATH-ERROR-NO-FORWARDING-INFORMATION, The mesh STA does not have forwarding information for this destination;
	63 | MESH-PATH-ERROR-DESTINATION-UNREACHABLE, The mesh STA determines that the link to the next hop of an active path in its forwarding information is no longer usable;
	64 | MAC-ADDRESS-ALREADY-EXISTS-IN-MBSS, The Deauthentication frame was sent because the MAC address of the STA already existsin the mesh BSS;
	65 | MESH-CHANNEL-SWITCH-REGULATORY-REQUIREMENTS, The mesh STA performs channel switch to meet regulatory requirements;
	66 | MESH-CHANNEL-SWITCH-UNSPECIFIED, The mesh STA performs channel switch with unspecified reason;
